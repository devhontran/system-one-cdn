var qe = Object.defineProperty; var Qe = (k, A, w) => A in k ? qe(k, A, { enumerable: !0, configurable: !0, writable: !0, value: w }) : k[A] = w; var R = (k, A, w) => (Qe(k, typeof A != "symbol" ? A + "" : A, w), w); import { f as Fe, u as He, b as U, P as re, s as ne, S as le, d as me, e as we, g as H, h as oe, i as ie, j as Je, k as Ze, l as Ke, m as Xe, _ as Ve, n as Ye, L as je, A as _e, o as et, p as ve, q as tt, r as it, R as Le, U as Be, a as N, t as nt, c as xe, v as st, w as se, M as Se, x as rt, y as at } from "./global.js"; const ot = k => { Fe.measure(k) }, We = k => { Fe.mutate(k) }, be = (k, A, w, O, p) => parseFloat(((k - A) * (p - O) / (w - A) + O).toFixed(3)), ce = ({ el: k, elObServer: A = null, animIn: w, offsetPercent: O = null, animUnset: p, inScreen: e, outScreen: l }) => { let a = null, r = null, f = null, i = !1; const u = !!k.getAttribute("data-enteronly"), o = k.getAttribute("data-trigger-for"); o && (r = document.getElementById(o)); const t = () => { if (!i) return; const { isPageEnter: d } = me; if (d) { const m = me.isScrolled() ? parseFloat(k.getAttribute("data-offset") || "0") : parseFloat(k.getAttribute("data-screen-offset") || "0"); k.classList.add("anim-in"), w && w(m) } e && e() }, s = () => { const { winSize: d } = me; O === null && ot(() => { const { height: m, top: S } = k.getBoundingClientRect(); S >= d.height && (O = be(m / d.height, 0, 1, .3, 0), O = Math.max(Math.min(O, .3), 0)) }), O = Number(k.getAttribute("data-threshold") || 0) || O, o ? ne(() => { f = new IntersectionObserver(m => { i = m[0].isIntersecting, i ? t() : l && l() }, { threshold: O || 0 }), f.observe(k) }) : ne(() => { a = le.create({ trigger: A || k, markers: !1, invalidateOnRefresh: !0, start: `${Number(O) * 100}% bottom`, onEnter: () => { i = !0, t() }, onLeave: () => { u && !e && !l && (p && p(), c(), i = !1), l && l() } }) }) }, n = () => i, c = () => { U.off(re, t), a && a.kill(), o && r && (f == null || f.unobserve(r), f == null || f.disconnect()) }; return He(() => (s(), U.on(re, t), c)), { getIsVisible: n, removeEvent: c } }; class pe {
    constructor(A, w, O) { R(this, "DOM"); R(this, "textSplit"); R(this, "input"); R(this, "old"); R(this, "isSpecial"); R(this, "planPricing"); this.DOM = { el: A, listChars: [] }, ne(this.init.bind(this)), this.old = [1, 1, 0], this.input = w, this.isSpecial = O } init() {
        const A = new we(this.DOM.el, { types: "chars, chars" }); H.killTweensOf([this.DOM.el, ...this.DOM.listChars]), this.textSplit = A, this.DOM.el.classList.add(oe.counter); const w = A.chars, O = globalThis.getComputedStyle(this.DOM.el).fontSize; if (w != null && w.length) for (const p in w) {
            const e = w[p], l = document.createElement("span"), a = e.innerText === "1"; if (l.classList.add(oe.counter_text), l.style.height = O, a && e.classList.add("char__one"), this.isSpecial && e.classList.add("char__special"), !isNaN(parseFloat(e.innerText))) {
                const r = parseFloat(e.innerText); l.insertAdjacentHTML("beforeend", `<span data-value="${r}"
                  class=${a ? `${oe.textSpacing}` : ""}>
                  <span>&ndash;</span>
                        ${Array(r + 1).join("0").split("0").map((u, o) => `
                                <span>
                                ${o}
                                </span>
                            `).join("")}
        			</span>`), e.removeChild(e.firstChild), e.appendChild(l); const f = l.querySelector("span[data-value]"); this.DOM.listChars.push(f); const { removeEvent: i } = ce({ el: this.DOM.el, animIn: u => { this.animIn(u), i() } }); ie(() => { i() })
            }
        }
    } handleSlide({ type: A, valSaleUp: w, planUser: O, basePrice: p }) { var e; (e = this.input) == null || e.addEventListener("input", l => { var a, r, f, i; return this.handleCalcPricing({ currentValue: l.target.value, type: ((a = this.planPricing) == null ? void 0 : a.type) || A, valSaleUp: ((r = this.planPricing) == null ? void 0 : r.valSaleUp) || w, planUser: ((f = this.planPricing) == null ? void 0 : f.planUser) || O, basePrice: ((i = this.planPricing) == null ? void 0 : i.basePrice) || p }) }) } handleCalcPricing({ currentValue: A, type: w, valSaleUp: O, planUser: p, basePrice: e, isReinit: l }) { var f, i; this.planPricing = { planUser: p, basePrice: e, valSaleUp: O, type: w }, (f = this.textSplit) == null || f.revert(); const a = w === "month", r = (parseFloat(A || ((i = this.input) == null ? void 0 : i.value) || "1") * p + e) * (a ? 1 : (100 - O) / 100 * 12); this.DOM.el.innerHTML = `${Math.floor(r)}`.replace(/\B(?=(\d{3})+(?!\d))/g, "."), l && (this.init(), this.animIn()) } animIn(A) { H.to(this.DOM.listChars, { duration: 1.2, ease: "power1", y: (w, O) => `-${(parseInt(O.getAttribute("data-value") || "0") + 1) * 100}%`, stagger: { amount: .025, from: "end" }, delay: A }) } createNumberArray(A) { const w = A.toString().split(""); for (let O = 0; w.length < 3; O++)w[0] === "-" && (w[0] = "0"), w.unshift("0"); return w.map(O => parseInt(O)) } createNumberHTML(A, w, O) { var e; const p = O.querySelectorAll("span[data-value]"); for (let l = 0; l < p.length; l++) { const a = p[l], r = this.calcDeltaBetweenNumbers(w[l], A[l]); a.setAttribute("data-between", String(r.length)), a.setAttribute("data-value", String(A[l])), a.innerHTML = r.join(""); const f = (e = a.parentElement) == null ? void 0 : e.parentElement; f && (A[l] === 1 ? (f.classList.add("char__one"), f.classList.remove(oe.textSpacing)) : (f.classList.remove("char__one"), f.classList.remove(oe.textSpacing))) } return O } calcDeltaBetweenNumbers(A, w) { let O = [A], p = !0; if (A === w) return O.map(e => `<span>${e}</span>`); for (; p;)A++, A > 9 && (A = 0), O.push(A), A === w && (p = !1); return O.map(e => `<span>${e}</span>`) } animateNumber(A) { const w = this.createNumberArray(A); this.createNumberHTML(w, this.old, this.DOM.el); let O; O && clearTimeout(O), O = setTimeout(() => { const p = Array.from(this.DOM.el.querySelectorAll("span[data-between]")); H.killTweensOf([...p]), H.set(p, { y: 0 }); for (let e of p) { let l = Number(e.getAttribute("data-between")) - 1; H.to(e, { duration: 1, ease: "ease", y: `-${l * 100}%`, stagger: { amount: .025, from: "end" } }) } this.old = w }, 1) }
} class lt { constructor(A) { R(this, "DOM"); R(this, "animation"); this.DOM = { el: A, splitType: new we(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var w; this.DOM.el.classList.add(Je.text__fade), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const p = document.createElement("div"); p.appendChild(O), p.classList.add("line__fade"), this.DOM.el.appendChild(p) }), (w = this.DOM.splitType.lines) != null && w.length && H.set(this.DOM.splitType.lines, { yPercent: 100, opacity: 0 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert(), this.revert() }) } animIn(A) { this.animation = H.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3.out", opacity: 1, stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } class ct { constructor(A) { R(this, "DOM"); R(this, "animation"); this.DOM = { el: A, splitType: new we(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var w; this.DOM.el.classList.add(Ze.text__mask), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const p = document.createElement("div"); p.appendChild(O), p.classList.add("line__mask"), this.DOM.el.appendChild(p) }), (w = this.DOM.splitType.lines) != null && w.length && H.set(this.DOM.splitType.lines, { yPercent: 100 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert() }) } animIn(A) { this.animation = H.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3", stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } const Me = (k, A, w, O, p) => parseFloat(((k - A) * (p - O) / (w - A) + O).toFixed(3)), Re = k => { const A = parseFloat(getComputedStyle(document.documentElement).fontSize); return k / A }; class ft { constructor(A, w = {}) { R(this, "onHover"); R(this, "DOM"); R(this, "options"); R(this, "removeEvent"); this.DOM = { el: A }, this.options = { ...w }, this.addAnimType() } addAnimType() { this.DOM.el.classList.add(Ke.fade); let A; switch (this.options.type) { case "fade_tran": H.set(this.DOM.el, { opacity: 0, y: "3rem" }), A = { to: { keyframes: [{ opacity: 1, ease: "power3.inOut", duration: .8 }, { y: 0, ease: "power3.out", duration: .8, delay: -.6 }], delay: this.options.delay || 0 }, out: { opacity: 0, y: -30, ease: "power3.inOut", duration: .6 } }; break; default: H.set(this.DOM.el, { opacity: 0 }), A = { to: { opacity: 1, ease: "power3.inOut", duration: .8, delay: this.options.delay || 0, clearProps: "all" }, out: { opacity: 0, ease: "power3.inOut", duration: .6 } }; break }this.options.to = { ...A.to, ...this.options.to }, this.options.out = { ...A.out, ...this.options.out }, We(() => { const { removeEvent: w } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), w() } }); this.removeEvent = w, ie(() => { w() }) }), this.options.from && H.set(this.DOM.el, this.options.from) } animIn(A = 0) { const w = Object.assign({ delay: 0 }, this.options.to); w.delay += A, H.killTweensOf(this.DOM.el), this.options.to && H.to(this.DOM.el, w), this.removeEvent && this.removeEvent() } } class ut { init() { this.loadImages() } maskText(A) { const w = A.querySelectorAll(".js-text-mask"); w.length && w.forEach(O => { new ct(O) }) } fadeWrap(A) { const w = A.querySelectorAll(".js-fade"); w.length && w.forEach(O => { new ft(O, { type: "fade_tran" }) }) } fadeText(A) { const w = A.querySelectorAll(".js-text-fade"); w.length && w.forEach(O => { new lt(O) }) } countText(A) { const w = A.querySelectorAll(".js-text-counter"); w.length && w.forEach(O => { new pe(O) }) } loadImages() { const A = document.querySelectorAll("img"); for (let w = 0; w < A.length; w++) { const O = A[w]; if (O.getAttribute("srcset")) { const e = O.getAttribute("width") || O.width, l = O.getBoundingClientRect().y; if (O.setAttribute("sizes", `(max-width: ${e}px) 100vw, ${e}px`), l > window.innerHeight) { const a = O.srcset.split(" ")[0]; O.style.background = `url(${a}) no-repeat center / cover` } } } } loadPage() { const A = H.timeline(), w = document.querySelector(".pageloader"); A.set(w, { display: "block" }), A.to(w, { opacity: 0, duration: 3, ease: "power3.out", onComplete: () => { H.to(w, { display: "none" }) } }) } handleResize() { let A = window.innerWidth; function w() { const O = window.innerWidth; Math.abs(O - A) > 10 && window.location.reload(), A = O } window.addEventListener("resize", Xe(w, 200)) } } const Q = new ut, ht = "_parallax_79i64_1", pt = "_wrapper_79i64_5", vt = "_inner_79i64_12", ye = { parallax: ht, wrapper: pt, inner: vt }; class Ce { constructor({ el: A, offset: w, scale: O, direction: p, ...e }) { R(this, "DOM"); R(this, "offset"); R(this, "scale"); R(this, "direction"); R(this, "options"); this.DOM = { el: A }, this.offset = w || 0, this.scale = O || 1.1, this.direction = p || -1, this.options = e, this.init() } init() { const A = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const w = document.createElement("div"); w.style.scale = `${this.scale}`, w.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, w.classList.add(ye.inner), A.classList.add(ye.parallax), this.DOM.el.classList.add(ye.wrapper), w.appendChild(A), this.DOM.el.appendChild(w), this.DOM.elInner = this.DOM.el; const { removeEvent: O } = ce({ el: this.DOM.el, animIn: () => { this.animIn(), O() } }); ie(() => { O() }) } animIn() { if (!this.DOM.elInner) return; const A = 100 + this.offset * 2, w = this.offset * A / 100 * this.direction, O = { trigger: this.DOM.el, start: "top bottom", end: "bottom top", scrub: 1 }; H.timeline({ scrollTrigger: O }).to(this.DOM.elInner, { y: `${w}%` }) } } class dt { constructor() { R(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.DOM.el && (this.hander(), this.movingImageFooter(), this.initMotion()) } initMotion() { this.DOM.el && (Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el)) } hander() { var w; const A = (w = this.DOM.el) == null ? void 0 : w.querySelector(".footer-bottom-inner-back"); A == null || A.addEventListener("click", () => { Ve.lenis.scrollTo("top", { lock: !0, duration: 1.2, onComplete: () => { console.log("scrolled") } }) }) } movingImageFooter() { var l, a, r, f, i; const A = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-inner-img"), w = (a = this.DOM.el) == null ? void 0 : a.querySelector(".footer-middle-list-imgs"); new Ce({ el: w, offset: 25, direction: 1, scale: 1.3 }); const O = (r = this.DOM.el) == null ? void 0 : r.querySelectorAll(".footer-middle-list-imgs-item"), p = H.quickTo(A, "x", { duration: .9, ease: "power3.out" }), e = u => { O == null || O.forEach((o, t) => { t === u ? H.to(o, { opacity: 1, ease: "power3.out", duration: .6, willChange: "opacity" }) : H.to(o, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; e(1), A.style.willChange = "transform", (f = this.DOM.el) == null || f.addEventListener("mousemove", u => { if (!this.DOM.el) return; const o = u.pageX, t = Me(o, 0, window.innerWidth, -1, 1), s = Math.floor(Me(o, 0, window.innerWidth, 0, (O == null ? void 0 : O.length) || 3)), n = (this.DOM.el.clientWidth - A.clientWidth) / 2; p(t * n), e(s) }), (i = this.DOM.el) == null || i.addEventListener("mouseleave", () => { p(0), e(1) }) } } class gt { constructor() { R(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show() } show() { let A = 0; window.addEventListener("scroll", () => { var r; if (!this.DOM.el) return; const w = window.pageYOffset || document.documentElement.scrollTop || 0, O = ((r = this.DOM.footer) == null ? void 0 : r.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, p = w > this.DOM.el.clientHeight, l = A < w && w > this.DOM.el.clientHeight * 2 || O, a = A > w && !O; l ? this.DOM.el.classList.add("hidden") : a && (this.DOM.el.classList.remove("hidden"), this.DOM.el.classList.toggle("scrollDown", p)), A = w }) } } const mt = ({ el: k, isGsap: A = !0, isDebug: w, inScreen: O, onEnterBack: p, outScreen: e, threshold: l = 0, onToggle: a, onToggleOb: r, start: f, end: i }) => { let u = !1, o = null, t; return !Ye() || A ? ne(() => { o = le.create({ trigger: k, start: f || `top+=${l * 100}% bottom`, end: i || "bottom top", markers: w, onToggle: c => { u = c.isActive, a && a(c), u ? O && O() : e && e() }, onEnterBack: p, invalidateOnRefresh: !0 }) }) : ne(() => { t = new IntersectionObserver(c => { u = c[0].isIntersecting, r && r(u), u ? O && O() : e && e() }, { threshold: l }), t.observe(k) }), { isInViewPointer: () => u, removeOb: () => { t && (t.unobserve(k), t.disconnect()), u = !1, o == null || o.kill(), o = null } } }; class xt { constructor() { R(this, "DOM"); R(this, "isReady"); R(this, "inited"); R(this, "windowIsBlur"); R(this, "isSimpleLoader"); R(this, "minProgress"); R(this, "processing"); R(this, "registerCount"); R(this, "lowNet"); R(this, "strokeDashoffset"); R(this, "obServerAPI"); R(this, "idAnimationLoop"); R(this, "runAnimation"); R(this, "delayPageEnter"); R(this, "delaLoadingOut"); this.registerLoader = this.registerLoader.bind(this), this.unRegisterLoader = this.unRegisterLoader.bind(this), this.init() } init() { this.DOM = { main: document.querySelector(".page-loading") }, document.body.classList.add("js-ready", "is-loading"), U.emit(je), this.inited = !!this.DOM.main, this.isReady = !1, this.windowIsBlur = !1, this.isSimpleLoader = !1, this.minProgress = 98, this.delayPageEnter = 1.2, this.delaLoadingOut = .3, this.processing = { delta: 0, percentStuck: 0, runWidth: 0 }, this.registerCount = 0, this.lowNet = 0, this.strokeDashoffset = 829, this.hideLoading = this.hideLoading.bind(this), He(() => (U.on(Le, this.registerLoader), U.on(Be, this.unRegisterLoader), window.addEventListener("DOMContentLoaded", this.hideLoading), () => { U.off(Le, this.registerLoader), U.off(Be, this.unRegisterLoader), window.removeEventListener("DOMContentLoaded", this.hideLoading) })) } simpleLoaded() { var A; (A = this.DOM.main) == null || A.classList.add("is-simple"), this.isSimpleLoader = !0, this.pageLoaded() } simple() { this.obServerAPI = mt({ el: document.body }), this.isSimpleLoader = !0, this.isReady = !0, U.emit(_e), document.body.classList.add("is-ready") } hideLoading() { U.emit(et) } hide() { We(() => { this.DOM.main && (this.DOM.main.style.visibility = "hidden") }) } pageLoaded() { this.idAnimationLoop && cancelAnimationFrame(this.idAnimationLoop), document.body.classList.remove("is-loading"), document.body.classList.remove("is-simple"), U.emit(ve), U.emit(tt), console.log("this.isSimpleLoader", this.isSimpleLoader), this.isSimpleLoader && (console.log("run_______"), this.DOM.main && H.to(this.DOM.main, { opacity: 0, duration: this.delayPageEnter, ease: "power3.inOut", onComplete: () => { setTimeout(() => this.hide(), 100), U.emit(re), U.emit(it) } })) } registerLoader() { this.registerCount++ } unRegisterLoader() { this.registerCount-- } } const ke = new xt; class yt { constructor(A) { R(this, "DOM"); this.DOM = { el: A }, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el), this.handleStackCard() } clear() { this.initParticles() } handleStackCard() { console.log("hehe"); const A = this.DOM.el.querySelector(".about-vision-sticky-inner"), O = this.DOM.el.querySelector(".about-vision-sticky-left").querySelectorAll(".about-sticky-left-card"), p = this.DOM.el.querySelector(".about-vision-sticky-right-inner"), e = this.DOM.el.querySelectorAll(".about-sticky-right-img"); (() => { let a = null, r = null; H.timeline({ scrollTrigger: { trigger: ".about-vision-sticky", start: "top top", end: "bottom bottom", scrub: 1, onUpdate: t => { const { progress: s } = t, n = Math.round(be(s, 0, 1, 0, O.length - 1)); if (r !== null && s < r) i(a), u(a); else if (r !== null && s > r) { f(n); const c = Math.min(e.length - 1, n + 1); u(c) } a = n, r = s } } }); const f = t => { const s = Re((p.clientHeight - N(3.2) * 2) / O.length); O.forEach((n, c) => { t === c && H.to(n, { height: `${s}rem`, duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, i = t => { O.forEach((s, n) => { t === n && H.to(s, { height: "auto", duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, u = t => { e.forEach((s, n) => { n === t ? (H.killTweensOf(s), H.to(s, { opacity: 1, ease: "power3", duration: .8 })) : H.to(s, { opacity: 0, ease: "power3", duration: .8 }) }) }; u(0); const o = Re((window.innerHeight - p.clientHeight) / 2); A.style.top = `${o}rem` })() } } class St { constructor(A) { R(this, "DOM"); this.DOM = { wrapper: A.querySelector(".home-feature-cards"), listCards: A.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((A, w, O) => { if (!nt) return; const p = O[0].clientHeight, e = (window.innerHeight - p) / 2, l = O.length * N(8), a = Me(w, 0, O.length - 1, .8125, 1); A.style.top = `${e + l}px`, A.style.transform = `translateY(-${(O.length - w) * N(8)}px)`, H.timeline({ scrollTrigger: { trigger: A, start: () => "top center", end: `+=${(O.length - w) * p} `, scrub: 1 } }).to(A, { scale: a, transformOrigin: "top center", ease: "none" }, 0) }) } } var te = {}, Mt = { get exports() { return te }, set exports(k) { te = k } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (k, A) { (function (O, p) { k.exports = p() })(xe, function () { return function (w) { var O = {}; function p(e) { if (O[e]) return O[e].exports; var l = O[e] = { i: e, l: !1, exports: {} }; return w[e].call(l.exports, l, l.exports, p), l.l = !0, l.exports } return p.m = w, p.c = O, p.d = function (e, l, a) { p.o(e, l) || Object.defineProperty(e, l, { enumerable: !0, get: a }) }, p.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, p.t = function (e, l) { if (l & 1 && (e = p(e)), l & 8 || l & 4 && typeof e == "object" && e && e.__esModule) return e; var a = Object.create(null); if (p.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: e }), l & 2 && typeof e != "string") for (var r in e) p.d(a, r, function (f) { return e[f] }.bind(null, r)); return a }, p.n = function (e) { var l = e && e.__esModule ? function () { return e.default } : function () { return e }; return p.d(l, "a", l), l }, p.o = function (e, l) { return Object.prototype.hasOwnProperty.call(e, l) }, p.p = "", p(p.s = 20) }([function (w, O) { var p = {}; w.exports = p, function () { p._baseDelta = 1e3 / 60, p._nextId = 0, p._seed = 0, p._nowStartTime = +new Date, p._warnedOnce = {}, p._decomp = null, p.extend = function (l, a) { var r, f; typeof a == "boolean" ? (r = 2, f = a) : (r = 1, f = !0); for (var i = r; i < arguments.length; i++) { var u = arguments[i]; if (u) for (var o in u) f && u[o] && u[o].constructor === Object && (!l[o] || l[o].constructor === Object) ? (l[o] = l[o] || {}, p.extend(l[o], f, u[o])) : l[o] = u[o] } return l }, p.clone = function (l, a) { return p.extend({}, a, l) }, p.keys = function (l) { if (Object.keys) return Object.keys(l); var a = []; for (var r in l) a.push(r); return a }, p.values = function (l) { var a = []; if (Object.keys) { for (var r = Object.keys(l), f = 0; f < r.length; f++)a.push(l[r[f]]); return a } for (var i in l) a.push(l[i]); return a }, p.get = function (l, a, r, f) { a = a.split(".").slice(r, f); for (var i = 0; i < a.length; i += 1)l = l[a[i]]; return l }, p.set = function (l, a, r, f, i) { var u = a.split(".").slice(f, i); return p.get(l, a, 0, -1)[u[u.length - 1]] = r, r }, p.shuffle = function (l) { for (var a = l.length - 1; a > 0; a--) { var r = Math.floor(p.random() * (a + 1)), f = l[a]; l[a] = l[r], l[r] = f } return l }, p.choose = function (l) { return l[Math.floor(p.random() * l.length)] }, p.isElement = function (l) { return typeof HTMLElement < "u" ? l instanceof HTMLElement : !!(l && l.nodeType && l.nodeName) }, p.isArray = function (l) { return Object.prototype.toString.call(l) === "[object Array]" }, p.isFunction = function (l) { return typeof l == "function" }, p.isPlainObject = function (l) { return typeof l == "object" && l.constructor === Object }, p.isString = function (l) { return toString.call(l) === "[object String]" }, p.clamp = function (l, a, r) { return l < a ? a : l > r ? r : l }, p.sign = function (l) { return l < 0 ? -1 : 1 }, p.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - p._nowStartTime }, p.random = function (l, a) { return l = typeof l < "u" ? l : 0, a = typeof a < "u" ? a : 1, l + e() * (a - l) }; var e = function () { return p._seed = (p._seed * 9301 + 49297) % 233280, p._seed / 233280 }; p.colorToNumber = function (l) { return l = l.replace("#", ""), l.length == 3 && (l = l.charAt(0) + l.charAt(0) + l.charAt(1) + l.charAt(1) + l.charAt(2) + l.charAt(2)), parseInt(l, 16) }, p.logLevel = 1, p.log = function () { console && p.logLevel > 0 && p.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.info = function () { console && p.logLevel > 0 && p.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.warn = function () { console && p.logLevel > 0 && p.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.warnOnce = function () { var l = Array.prototype.slice.call(arguments).join(" "); p._warnedOnce[l] || (p.warn(l), p._warnedOnce[l] = !0) }, p.deprecated = function (l, a, r) { l[a] = p.chain(function () { p.warnOnce("🔅 deprecated 🔅", r) }, l[a]) }, p.nextId = function () { return p._nextId++ }, p.indexOf = function (l, a) { if (l.indexOf) return l.indexOf(a); for (var r = 0; r < l.length; r++)if (l[r] === a) return r; return -1 }, p.map = function (l, a) { if (l.map) return l.map(a); for (var r = [], f = 0; f < l.length; f += 1)r.push(a(l[f])); return r }, p.topologicalSort = function (l) { var a = [], r = [], f = []; for (var i in l) !r[i] && !f[i] && p._topologicalSort(i, r, f, l, a); return a }, p._topologicalSort = function (l, a, r, f, i) { var u = f[l] || []; r[l] = !0; for (var o = 0; o < u.length; o += 1) { var t = u[o]; r[t] || a[t] || p._topologicalSort(t, a, r, f, i) } r[l] = !1, a[l] = !0, i.push(l) }, p.chain = function () { for (var l = [], a = 0; a < arguments.length; a += 1) { var r = arguments[a]; r._chained ? l.push.apply(l, r._chained) : l.push(r) } var f = function () { for (var i, u = new Array(arguments.length), o = 0, t = arguments.length; o < t; o++)u[o] = arguments[o]; for (o = 0; o < l.length; o += 1) { var s = l[o].apply(i, u); typeof s < "u" && (i = s) } return i }; return f._chained = l, f }, p.chainPathBefore = function (l, a, r) { return p.set(l, a, p.chain(r, p.get(l, a))) }, p.chainPathAfter = function (l, a, r) { return p.set(l, a, p.chain(p.get(l, a), r)) }, p.setDecomp = function (l) { p._decomp = l }, p.getDecomp = function () { var l = p._decomp; try { !l && typeof window < "u" && (l = window.decomp), !l && typeof xe < "u" && (l = xe.decomp) } catch { l = null } return l } }() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e) { var l = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && p.update(l, e), l }, p.update = function (e, l, a) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var r = 0; r < l.length; r++) { var f = l[r]; f.x > e.max.x && (e.max.x = f.x), f.x < e.min.x && (e.min.x = f.x), f.y > e.max.y && (e.max.y = f.y), f.y < e.min.y && (e.min.y = f.y) } a && (a.x > 0 ? e.max.x += a.x : e.min.x += a.x, a.y > 0 ? e.max.y += a.y : e.min.y += a.y) }, p.contains = function (e, l) { return l.x >= e.min.x && l.x <= e.max.x && l.y >= e.min.y && l.y <= e.max.y }, p.overlaps = function (e, l) { return e.min.x <= l.max.x && e.max.x >= l.min.x && e.max.y >= l.min.y && e.min.y <= l.max.y }, p.translate = function (e, l) { e.min.x += l.x, e.max.x += l.x, e.min.y += l.y, e.max.y += l.y }, p.shift = function (e, l) { var a = e.max.x - e.min.x, r = e.max.y - e.min.y; e.min.x = l.x, e.max.x = l.x + a, e.min.y = l.y, e.max.y = l.y + r } }() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e, l) { return { x: e || 0, y: l || 0 } }, p.clone = function (e) { return { x: e.x, y: e.y } }, p.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, p.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, p.rotate = function (e, l, a) { var r = Math.cos(l), f = Math.sin(l); a || (a = {}); var i = e.x * r - e.y * f; return a.y = e.x * f + e.y * r, a.x = i, a }, p.rotateAbout = function (e, l, a, r) { var f = Math.cos(l), i = Math.sin(l); r || (r = {}); var u = a.x + ((e.x - a.x) * f - (e.y - a.y) * i); return r.y = a.y + ((e.x - a.x) * i + (e.y - a.y) * f), r.x = u, r }, p.normalise = function (e) { var l = p.magnitude(e); return l === 0 ? { x: 0, y: 0 } : { x: e.x / l, y: e.y / l } }, p.dot = function (e, l) { return e.x * l.x + e.y * l.y }, p.cross = function (e, l) { return e.x * l.y - e.y * l.x }, p.cross3 = function (e, l, a) { return (l.x - e.x) * (a.y - e.y) - (l.y - e.y) * (a.x - e.x) }, p.add = function (e, l, a) { return a || (a = {}), a.x = e.x + l.x, a.y = e.y + l.y, a }, p.sub = function (e, l, a) { return a || (a = {}), a.x = e.x - l.x, a.y = e.y - l.y, a }, p.mult = function (e, l) { return { x: e.x * l, y: e.y * l } }, p.div = function (e, l) { return { x: e.x / l, y: e.y / l } }, p.perp = function (e, l) { return l = l === !0 ? -1 : 1, { x: l * -e.y, y: l * e.x } }, p.neg = function (e) { return { x: -e.x, y: -e.y } }, p.angle = function (e, l) { return Math.atan2(l.y - e.y, l.x - e.x) }, p._temp = [p.create(), p.create(), p.create(), p.create(), p.create(), p.create()] }() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), a = p(0); (function () { e.create = function (r, f) { for (var i = [], u = 0; u < r.length; u++) { var o = r[u], t = { x: o.x, y: o.y, index: u, body: f, isInternal: !1 }; i.push(t) } return i }, e.fromPath = function (r, f) { var i = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, u = []; return r.replace(i, function (o, t, s) { u.push({ x: parseFloat(t), y: parseFloat(s) }) }), e.create(u, f) }, e.centre = function (r) { for (var f = e.area(r, !0), i = { x: 0, y: 0 }, u, o, t, s = 0; s < r.length; s++)t = (s + 1) % r.length, u = l.cross(r[s], r[t]), o = l.mult(l.add(r[s], r[t]), u), i = l.add(i, o); return l.div(i, 6 * f) }, e.mean = function (r) { for (var f = { x: 0, y: 0 }, i = 0; i < r.length; i++)f.x += r[i].x, f.y += r[i].y; return l.div(f, r.length) }, e.area = function (r, f) { for (var i = 0, u = r.length - 1, o = 0; o < r.length; o++)i += (r[u].x - r[o].x) * (r[u].y + r[o].y), u = o; return f ? i / 2 : Math.abs(i) / 2 }, e.inertia = function (r, f) { for (var i = 0, u = 0, o = r, t, s, n = 0; n < o.length; n++)s = (n + 1) % o.length, t = Math.abs(l.cross(o[s], o[n])), i += t * (l.dot(o[s], o[s]) + l.dot(o[s], o[n]) + l.dot(o[n], o[n])), u += t; return f / 6 * (i / u) }, e.translate = function (r, f, i) { i = typeof i < "u" ? i : 1; var u = r.length, o = f.x * i, t = f.y * i, s; for (s = 0; s < u; s++)r[s].x += o, r[s].y += t; return r }, e.rotate = function (r, f, i) { if (f !== 0) { var u = Math.cos(f), o = Math.sin(f), t = i.x, s = i.y, n = r.length, c, d, m, S; for (S = 0; S < n; S++)c = r[S], d = c.x - t, m = c.y - s, c.x = t + (d * u - m * o), c.y = s + (d * o + m * u); return r } }, e.contains = function (r, f) { for (var i = f.x, u = f.y, o = r.length, t = r[o - 1], s, n = 0; n < o; n++) { if (s = r[n], (i - t.x) * (s.y - t.y) + (u - t.y) * (t.x - s.x) > 0) return !1; t = s } return !0 }, e.scale = function (r, f, i, u) { if (f === 1 && i === 1) return r; u = u || e.centre(r); for (var o, t, s = 0; s < r.length; s++)o = r[s], t = l.sub(o, u), r[s].x = u.x + t.x * f, r[s].y = u.y + t.y * i; return r }, e.chamfer = function (r, f, i, u, o) { typeof f == "number" ? f = [f] : f = f || [8], i = typeof i < "u" ? i : -1, u = u || 2, o = o || 14; for (var t = [], s = 0; s < r.length; s++) { var n = r[s - 1 >= 0 ? s - 1 : r.length - 1], c = r[s], d = r[(s + 1) % r.length], m = f[s < f.length ? s : f.length - 1]; if (m === 0) { t.push(c); continue } var S = l.normalise({ x: c.y - n.y, y: n.x - c.x }), D = l.normalise({ x: d.y - c.y, y: c.x - d.x }), h = Math.sqrt(2 * Math.pow(m, 2)), g = l.mult(a.clone(S), m), x = l.normalise(l.mult(l.add(S, D), .5)), v = l.sub(c, l.mult(x, h)), M = i; i === -1 && (M = Math.pow(m, .32) * 1.75), M = a.clamp(M, u, o), M % 2 === 1 && (M += 1); for (var y = Math.acos(l.dot(S, D)), C = y / M, P = 0; P < M; P++)t.push(l.add(l.rotate(g, C * P), v)) } return t }, e.clockwiseSort = function (r) { var f = e.mean(r); return r.sort(function (i, u) { return l.angle(f, i) - l.angle(f, u) }), r }, e.isConvex = function (r) { var f = 0, i = r.length, u, o, t, s; if (i < 3) return null; for (u = 0; u < i; u++)if (o = (u + 1) % i, t = (u + 2) % i, s = (r[o].x - r[u].x) * (r[t].y - r[o].y), s -= (r[o].y - r[u].y) * (r[t].x - r[o].x), s < 0 ? f |= 1 : s > 0 && (f |= 2), f === 3) return !1; return f !== 0 ? !0 : null }, e.hull = function (r) { var f = [], i = [], u, o; for (r = r.slice(0), r.sort(function (t, s) { var n = t.x - s.x; return n !== 0 ? n : t.y - s.y }), o = 0; o < r.length; o += 1) { for (u = r[o]; i.length >= 2 && l.cross3(i[i.length - 2], i[i.length - 1], u) <= 0;)i.pop(); i.push(u) } for (o = r.length - 1; o >= 0; o -= 1) { for (u = r[o]; f.length >= 2 && l.cross3(f[f.length - 2], f[f.length - 1], u) <= 0;)f.pop(); f.push(u) } return f.pop(), i.pop(), f.concat(i) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(2), r = p(7), f = p(0), i = p(1), u = p(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var s = { id: f.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: l.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, n = f.extend(s, t); return o(n, t), n }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var o = function (t, s) { s = s || {}, e.set(t, { bounds: t.bounds || i.create(t.vertices), positionPrev: t.positionPrev || a.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), l.rotate(t.vertices, t.angle, t.position), u.rotate(t.axes, t.angle), i.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: s.axes || t.axes, area: s.area || t.area, mass: s.mass || t.mass, inertia: s.inertia || t.inertia }); var n = t.isStatic ? "#14151f" : f.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), c = t.isStatic ? "#555" : "#ccc", d = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || n, t.render.strokeStyle = t.render.strokeStyle || c, t.render.lineWidth = t.render.lineWidth || d, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, s, n) { var c; typeof s == "string" && (c = s, s = {}, s[c] = n); for (c in s) if (Object.prototype.hasOwnProperty.call(s, c)) switch (n = s[c], c) { case "isStatic": e.setStatic(t, n); break; case "isSleeping": r.set(t, n); break; case "mass": e.setMass(t, n); break; case "density": e.setDensity(t, n); break; case "inertia": e.setInertia(t, n); break; case "vertices": e.setVertices(t, n); break; case "position": e.setPosition(t, n); break; case "angle": e.setAngle(t, n); break; case "velocity": e.setVelocity(t, n); break; case "angularVelocity": e.setAngularVelocity(t, n); break; case "speed": e.setSpeed(t, n); break; case "angularSpeed": e.setAngularSpeed(t, n); break; case "parts": e.setParts(t, n); break; case "centre": e.setCentre(t, n); break; default: t[c] = n } }, e.setStatic = function (t, s) { for (var n = 0; n < t.parts.length; n++) { var c = t.parts[n]; s ? (c.isStatic || (c._original = { restitution: c.restitution, friction: c.friction, mass: c.mass, inertia: c.inertia, density: c.density, inverseMass: c.inverseMass, inverseInertia: c.inverseInertia }), c.restitution = 0, c.friction = 1, c.mass = c.inertia = c.density = 1 / 0, c.inverseMass = c.inverseInertia = 0, c.positionPrev.x = c.position.x, c.positionPrev.y = c.position.y, c.anglePrev = c.angle, c.angularVelocity = 0, c.speed = 0, c.angularSpeed = 0, c.motion = 0) : c._original && (c.restitution = c._original.restitution, c.friction = c._original.friction, c.mass = c._original.mass, c.inertia = c._original.inertia, c.density = c._original.density, c.inverseMass = c._original.inverseMass, c.inverseInertia = c._original.inverseInertia, c._original = null), c.isStatic = s } }, e.setMass = function (t, s) { var n = t.inertia / (t.mass / 6); t.inertia = n * (s / 6), t.inverseInertia = 1 / t.inertia, t.mass = s, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, s) { e.setMass(t, s * t.area), t.density = s }, e.setInertia = function (t, s) { t.inertia = s, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, s) { s[0].body === t ? t.vertices = s : t.vertices = l.create(s, t), t.axes = u.fromVertices(t.vertices), t.area = l.area(t.vertices), e.setMass(t, t.density * t.area); var n = l.centre(t.vertices); l.translate(t.vertices, n, -1), e.setInertia(t, e._inertiaScale * l.inertia(t.vertices, t.mass)), l.translate(t.vertices, t.position), i.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, s, n) { var c; for (s = s.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, c = 0; c < s.length; c++) { var d = s[c]; d !== t && (d.parent = t, t.parts.push(d)) } if (t.parts.length !== 1) { if (n = typeof n < "u" ? n : !0, n) { var m = []; for (c = 0; c < s.length; c++)m = m.concat(s[c].vertices); l.clockwiseSort(m); var S = l.hull(m), D = l.centre(S); e.setVertices(t, S), l.translate(t.vertices, D) } var h = e._totalProperties(t); t.area = h.area, t.parent = t, t.position.x = h.centre.x, t.position.y = h.centre.y, t.positionPrev.x = h.centre.x, t.positionPrev.y = h.centre.y, e.setMass(t, h.mass), e.setInertia(t, h.inertia), e.setPosition(t, h.centre) } }, e.setCentre = function (t, s, n) { n ? (t.positionPrev.x += s.x, t.positionPrev.y += s.y, t.position.x += s.x, t.position.y += s.y) : (t.positionPrev.x = s.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = s.y - (t.position.y - t.positionPrev.y), t.position.x = s.x, t.position.y = s.y) }, e.setPosition = function (t, s, n) { var c = a.sub(s, t.position); n ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = c.x, t.velocity.y = c.y, t.speed = a.magnitude(c)) : (t.positionPrev.x += c.x, t.positionPrev.y += c.y); for (var d = 0; d < t.parts.length; d++) { var m = t.parts[d]; m.position.x += c.x, m.position.y += c.y, l.translate(m.vertices, c), i.update(m.bounds, m.vertices, t.velocity) } }, e.setAngle = function (t, s, n) { var c = s - t.angle; n ? (t.anglePrev = t.angle, t.angularVelocity = c, t.angularSpeed = Math.abs(c)) : t.anglePrev += c; for (var d = 0; d < t.parts.length; d++) { var m = t.parts[d]; m.angle += c, l.rotate(m.vertices, c, t.position), u.rotate(m.axes, c), i.update(m.bounds, m.vertices, t.velocity), d > 0 && a.rotateAbout(m.position, c, t.position, m.position) } }, e.setVelocity = function (t, s) { var n = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - s.x * n, t.positionPrev.y = t.position.y - s.y * n, t.velocity.x = (t.position.x - t.positionPrev.x) / n, t.velocity.y = (t.position.y - t.positionPrev.y) / n, t.speed = a.magnitude(t.velocity) }, e.getVelocity = function (t) { var s = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * s, y: (t.position.y - t.positionPrev.y) * s } }, e.getSpeed = function (t) { return a.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, s) { e.setVelocity(t, a.mult(a.normalise(e.getVelocity(t)), s)) }, e.setAngularVelocity = function (t, s) { var n = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - s * n, t.angularVelocity = (t.angle - t.anglePrev) / n, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, s) { e.setAngularVelocity(t, f.sign(e.getAngularVelocity(t)) * s) }, e.translate = function (t, s, n) { e.setPosition(t, a.add(t.position, s), n) }, e.rotate = function (t, s, n, c) { if (!n) e.setAngle(t, t.angle + s, c); else { var d = Math.cos(s), m = Math.sin(s), S = t.position.x - n.x, D = t.position.y - n.y; e.setPosition(t, { x: n.x + (S * d - D * m), y: n.y + (S * m + D * d) }, c), e.setAngle(t, t.angle + s, c) } }, e.scale = function (t, s, n, c) { var d = 0, m = 0; c = c || t.position; for (var S = 0; S < t.parts.length; S++) { var D = t.parts[S]; l.scale(D.vertices, s, n, c), D.axes = u.fromVertices(D.vertices), D.area = l.area(D.vertices), e.setMass(D, t.density * D.area), l.translate(D.vertices, { x: -D.position.x, y: -D.position.y }), e.setInertia(D, e._inertiaScale * l.inertia(D.vertices, D.mass)), l.translate(D.vertices, { x: D.position.x, y: D.position.y }), S > 0 && (d += D.area, m += D.inertia), D.position.x = c.x + (D.position.x - c.x) * s, D.position.y = c.y + (D.position.y - c.y) * n, i.update(D.bounds, D.vertices, t.velocity) } t.parts.length > 1 && (t.area = d, t.isStatic || (e.setMass(t, t.density * d), e.setInertia(t, m))), t.circleRadius && (s === n ? t.circleRadius *= s : t.circleRadius = null) }, e.update = function (t, s) { s = (typeof s < "u" ? s : 1e3 / 60) * t.timeScale; var n = s * s, c = e._timeCorrection ? s / (t.deltaTime || s) : 1, d = 1 - t.frictionAir * (s / f._baseDelta), m = (t.position.x - t.positionPrev.x) * c, S = (t.position.y - t.positionPrev.y) * c; t.velocity.x = m * d + t.force.x / t.mass * n, t.velocity.y = S * d + t.force.y / t.mass * n, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = s, t.angularVelocity = (t.angle - t.anglePrev) * d * c + t.torque / t.inertia * n, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var D = 0; D < t.parts.length; D++) { var h = t.parts[D]; l.translate(h.vertices, t.velocity), D > 0 && (h.position.x += t.velocity.x, h.position.y += t.velocity.y), t.angularVelocity !== 0 && (l.rotate(h.vertices, t.angularVelocity, t.position), u.rotate(h.axes, t.angularVelocity), D > 0 && a.rotateAbout(h.position, t.angularVelocity, t.position, h.position)), i.update(h.bounds, h.vertices, t.velocity) } }, e.updateVelocities = function (t) { var s = e._baseDelta / t.deltaTime, n = t.velocity; n.x = (t.position.x - t.positionPrev.x) * s, n.y = (t.position.y - t.positionPrev.y) * s, t.speed = Math.sqrt(n.x * n.x + n.y * n.y), t.angularVelocity = (t.angle - t.anglePrev) * s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, s, n) { var c = { x: s.x - t.position.x, y: s.y - t.position.y }; t.force.x += n.x, t.force.y += n.y, t.torque += c.x * n.y - c.y * n.x }, e._totalProperties = function (t) { for (var s = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, n = t.parts.length === 1 ? 0 : 1; n < t.parts.length; n++) { var c = t.parts[n], d = c.mass !== 1 / 0 ? c.mass : 1; s.mass += d, s.area += c.area, s.inertia += c.inertia, s.centre = a.add(s.centre, a.mult(c.position, d)) } return s.centre = a.div(s.centre, s.mass), s } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e.on = function (a, r, f) { for (var i = r.split(" "), u, o = 0; o < i.length; o++)u = i[o], a.events = a.events || {}, a.events[u] = a.events[u] || [], a.events[u].push(f); return f }, e.off = function (a, r, f) { if (!r) { a.events = {}; return } typeof r == "function" && (f = r, r = l.keys(a.events).join(" ")); for (var i = r.split(" "), u = 0; u < i.length; u++) { var o = a.events[i[u]], t = []; if (f && o) for (var s = 0; s < o.length; s++)o[s] !== f && t.push(o[s]); a.events[i[u]] = t } }, e.trigger = function (a, r, f) { var i, u, o, t, s = a.events; if (s && l.keys(s).length > 0) { f || (f = {}), i = r.split(" "); for (var n = 0; n < i.length; n++)if (u = i[n], o = s[u], o) { t = l.clone(f, !1), t.name = u, t.source = a; for (var c = 0; c < o.length; c++)o[c].apply(a, [t]) } } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(5), a = p(0), r = p(1), f = p(4); (function () { e.create = function (i) { return a.extend({ id: a.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, i) }, e.setModified = function (i, u, o, t) { if (i.isModified = u, u && i.cache && (i.cache.allBodies = null, i.cache.allConstraints = null, i.cache.allComposites = null), o && i.parent && e.setModified(i.parent, u, o, t), t) for (var s = 0; s < i.composites.length; s++) { var n = i.composites[s]; e.setModified(n, u, o, t) } }, e.add = function (i, u) { var o = [].concat(u); l.trigger(i, "beforeAdd", { object: u }); for (var t = 0; t < o.length; t++) { var s = o[t]; switch (s.type) { case "body": if (s.parent !== s) { a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(i, s); break; case "constraint": e.addConstraint(i, s); break; case "composite": e.addComposite(i, s); break; case "mouseConstraint": e.addConstraint(i, s.constraint); break } } return l.trigger(i, "afterAdd", { object: u }), i }, e.remove = function (i, u, o) { var t = [].concat(u); l.trigger(i, "beforeRemove", { object: u }); for (var s = 0; s < t.length; s++) { var n = t[s]; switch (n.type) { case "body": e.removeBody(i, n, o); break; case "constraint": e.removeConstraint(i, n, o); break; case "composite": e.removeComposite(i, n, o); break; case "mouseConstraint": e.removeConstraint(i, n.constraint); break } } return l.trigger(i, "afterRemove", { object: u }), i }, e.addComposite = function (i, u) { return i.composites.push(u), u.parent = i, e.setModified(i, !0, !0, !1), i }, e.removeComposite = function (i, u, o) { var t = a.indexOf(i.composites, u); if (t !== -1) { var s = e.allBodies(u); e.removeCompositeAt(i, t); for (var n = 0; n < s.length; n++)s[n].sleepCounter = 0 } if (o) for (var n = 0; n < i.composites.length; n++)e.removeComposite(i.composites[n], u, !0); return i }, e.removeCompositeAt = function (i, u) { return i.composites.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.addBody = function (i, u) { return i.bodies.push(u), e.setModified(i, !0, !0, !1), i }, e.removeBody = function (i, u, o) { var t = a.indexOf(i.bodies, u); if (t !== -1 && (e.removeBodyAt(i, t), u.sleepCounter = 0), o) for (var s = 0; s < i.composites.length; s++)e.removeBody(i.composites[s], u, !0); return i }, e.removeBodyAt = function (i, u) { return i.bodies.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.addConstraint = function (i, u) { return i.constraints.push(u), e.setModified(i, !0, !0, !1), i }, e.removeConstraint = function (i, u, o) { var t = a.indexOf(i.constraints, u); if (t !== -1 && e.removeConstraintAt(i, t), o) for (var s = 0; s < i.composites.length; s++)e.removeConstraint(i.composites[s], u, !0); return i }, e.removeConstraintAt = function (i, u) { return i.constraints.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.clear = function (i, u, o) { if (o) for (var t = 0; t < i.composites.length; t++)e.clear(i.composites[t], u, !0); return u ? i.bodies = i.bodies.filter(function (s) { return s.isStatic }) : i.bodies.length = 0, i.constraints.length = 0, i.composites.length = 0, e.setModified(i, !0, !0, !1), i }, e.allBodies = function (i) { if (i.cache && i.cache.allBodies) return i.cache.allBodies; for (var u = [].concat(i.bodies), o = 0; o < i.composites.length; o++)u = u.concat(e.allBodies(i.composites[o])); return i.cache && (i.cache.allBodies = u), u }, e.allConstraints = function (i) { if (i.cache && i.cache.allConstraints) return i.cache.allConstraints; for (var u = [].concat(i.constraints), o = 0; o < i.composites.length; o++)u = u.concat(e.allConstraints(i.composites[o])); return i.cache && (i.cache.allConstraints = u), u }, e.allComposites = function (i) { if (i.cache && i.cache.allComposites) return i.cache.allComposites; for (var u = [].concat(i.composites), o = 0; o < i.composites.length; o++)u = u.concat(e.allComposites(i.composites[o])); return i.cache && (i.cache.allComposites = u), u }, e.get = function (i, u, o) { var t, s; switch (o) { case "body": t = e.allBodies(i); break; case "constraint": t = e.allConstraints(i); break; case "composite": t = e.allComposites(i).concat(i); break }return t ? (s = t.filter(function (n) { return n.id.toString() === u.toString() }), s.length === 0 ? null : s[0]) : null }, e.move = function (i, u, o) { return e.remove(i, u), e.add(o, u), i }, e.rebase = function (i) { for (var u = e.allBodies(i).concat(e.allConstraints(i)).concat(e.allComposites(i)), o = 0; o < u.length; o++)u[o].id = a.nextId(); return i }, e.translate = function (i, u, o) { for (var t = o ? e.allBodies(i) : i.bodies, s = 0; s < t.length; s++)f.translate(t[s], u); return i }, e.rotate = function (i, u, o, t) { for (var s = Math.cos(u), n = Math.sin(u), c = t ? e.allBodies(i) : i.bodies, d = 0; d < c.length; d++) { var m = c[d], S = m.position.x - o.x, D = m.position.y - o.y; f.setPosition(m, { x: o.x + (S * s - D * n), y: o.y + (S * n + D * s) }), f.rotate(m, u) } return i }, e.scale = function (i, u, o, t, s) { for (var n = s ? e.allBodies(i) : i.bodies, c = 0; c < n.length; c++) { var d = n[c], m = d.position.x - t.x, S = d.position.y - t.y; f.setPosition(d, { x: t.x + m * u, y: t.y + S * o }), f.scale(d, u, o) } return i }, e.bounds = function (i) { for (var u = e.allBodies(i), o = [], t = 0; t < u.length; t += 1) { var s = u[t]; o.push(s.bounds.min, s.bounds.max) } return r.create(o) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(4), a = p(5), r = p(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (f, i) { for (var u = i / r._baseDelta, o = e._motionSleepThreshold, t = 0; t < f.length; t++) { var s = f[t], n = l.getSpeed(s), c = l.getAngularSpeed(s), d = n * n + c * c; if (s.force.x !== 0 || s.force.y !== 0) { e.set(s, !1); continue } var m = Math.min(s.motion, d), S = Math.max(s.motion, d); s.motion = e._minBias * m + (1 - e._minBias) * S, s.sleepThreshold > 0 && s.motion < o ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold / u && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1) } }, e.afterCollisions = function (f) { for (var i = e._motionSleepThreshold, u = 0; u < f.length; u++) { var o = f[u]; if (o.isActive) { var t = o.collision, s = t.bodyA.parent, n = t.bodyB.parent; if (!(s.isSleeping && n.isSleeping || s.isStatic || n.isStatic) && (s.isSleeping || n.isSleeping)) { var c = s.isSleeping && !s.isStatic ? s : n, d = c === s ? n : s; !c.isStatic && d.motion > i && e.set(c, !1) } } } }, e.set = function (f, i) { var u = f.isSleeping; i ? (f.isSleeping = !0, f.sleepCounter = f.sleepThreshold, f.positionImpulse.x = 0, f.positionImpulse.y = 0, f.positionPrev.x = f.position.x, f.positionPrev.y = f.position.y, f.anglePrev = f.angle, f.speed = 0, f.angularSpeed = 0, f.motion = 0, u || a.trigger(f, "sleepStart")) : (f.isSleeping = !1, f.sleepCounter = 0, u && a.trigger(f, "sleepEnd")) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(9); (function () { var r = [], f = { overlap: 0, axis: null }, i = { overlap: 0, axis: null }; e.create = function (u, o) { return { pair: null, collided: !1, bodyA: u, bodyB: o, parentA: u.parent, parentB: o.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (u, o, t) { if (e._overlapAxes(f, u.vertices, o.vertices, u.axes), f.overlap <= 0 || (e._overlapAxes(i, o.vertices, u.vertices, o.axes), i.overlap <= 0)) return null; var s = t && t.table[a.id(u, o)], n; s ? n = s.collision : (n = e.create(u, o), n.collided = !0, n.bodyA = u.id < o.id ? u : o, n.bodyB = u.id < o.id ? o : u, n.parentA = n.bodyA.parent, n.parentB = n.bodyB.parent), u = n.bodyA, o = n.bodyB; var c; f.overlap < i.overlap ? c = f : c = i; var d = n.normal, m = n.tangent, S = n.penetration, D = n.supports, h = c.overlap, g = c.axis, x = g.x, v = g.y, M = o.position.x - u.position.x, y = o.position.y - u.position.y; x * M + v * y >= 0 && (x = -x, v = -v), d.x = x, d.y = v, m.x = -v, m.y = x, S.x = x * h, S.y = v * h, n.depth = h; var C = e._findSupports(u, o, d, 1), P = 0; if (l.contains(u.vertices, C[0]) && (D[P++] = C[0]), l.contains(u.vertices, C[1]) && (D[P++] = C[1]), P < 2) { var T = e._findSupports(o, u, d, -1); l.contains(o.vertices, T[0]) && (D[P++] = T[0]), P < 2 && l.contains(o.vertices, T[1]) && (D[P++] = T[1]) } return P === 0 && (D[P++] = C[0]), n.supportCount = P, n }, e._overlapAxes = function (u, o, t, s) { var n = o.length, c = t.length, d = o[0].x, m = o[0].y, S = t[0].x, D = t[0].y, h = s.length, g = Number.MAX_VALUE, x = 0, v, M, y, C, P, T; for (P = 0; P < h; P++) { var E = s[P], I = E.x, B = E.y, L = d * I + m * B, F = S * I + D * B, W = L, b = F; for (T = 1; T < n; T += 1)C = o[T].x * I + o[T].y * B, C > W ? W = C : C < L && (L = C); for (T = 1; T < c; T += 1)C = t[T].x * I + t[T].y * B, C > b ? b = C : C < F && (F = C); if (M = W - F, y = b - L, v = M < y ? M : y, v < g && (g = v, x = P, v <= 0)) break } u.axis = s[x], u.overlap = g }, e._findSupports = function (u, o, t, s) { var n = o.vertices, c = n.length, d = u.position.x, m = u.position.y, S = t.x * s, D = t.y * s, h = n[0], g = h, x = S * (d - g.x) + D * (m - g.y), v, M, y; for (y = 1; y < c; y += 1)g = n[y], M = S * (d - g.x) + D * (m - g.y), M < x && (x = M, h = g); return v = n[(c + h.index - 1) % c], x = S * (d - v.x) + D * (m - v.y), g = n[(h.index + 1) % c], S * (d - g.x) + D * (m - g.y) < x ? (r[0] = h, r[1] = g, r) : (r[0] = h, r[1] = v, r) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(16); (function () { e.create = function (a, r) { var f = a.bodyA, i = a.bodyB, u = { id: e.id(f, i), bodyA: f, bodyB: i, collision: a, contacts: [l.create(), l.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: f.isSensor || i.isSensor, timeCreated: r, timeUpdated: r, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(u, a, r), u }, e.update = function (a, r, f) { var i = r.supports, u = r.supportCount, o = a.contacts, t = r.parentA, s = r.parentB; a.isActive = !0, a.timeUpdated = f, a.collision = r, a.separation = r.depth, a.inverseMass = t.inverseMass + s.inverseMass, a.friction = t.friction < s.friction ? t.friction : s.friction, a.frictionStatic = t.frictionStatic > s.frictionStatic ? t.frictionStatic : s.frictionStatic, a.restitution = t.restitution > s.restitution ? t.restitution : s.restitution, a.slop = t.slop > s.slop ? t.slop : s.slop, a.contactCount = u, r.pair = a; var n = i[0], c = o[0], d = i[1], m = o[1]; (m.vertex === n || c.vertex === d) && (o[1] = c, o[0] = c = m, m = o[1]), c.vertex = n, m.vertex = d }, e.setActive = function (a, r, f) { r ? (a.isActive = !0, a.timeUpdated = f) : (a.isActive = !1, a.contactCount = 0) }, e.id = function (a, r) { return a.id < r.id ? a.id.toString(36) + ":" + r.id.toString(36) : r.id.toString(36) + ":" + a.id.toString(36) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(2), r = p(7), f = p(1), i = p(11), u = p(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (o) { var t = o; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var s = t.bodyA ? a.add(t.bodyA.position, t.pointA) : t.pointA, n = t.bodyB ? a.add(t.bodyB.position, t.pointB) : t.pointB, c = a.magnitude(a.sub(s, n)); t.length = typeof t.length < "u" ? t.length : c, t.id = t.id || u.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var d = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (d.type = "pin", d.anchors = !1) : t.stiffness < .9 && (d.type = "spring"), t.render = u.extend(d, t.render), t }, e.preSolveAll = function (o) { for (var t = 0; t < o.length; t += 1) { var s = o[t], n = s.constraintImpulse; s.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (s.position.x += n.x, s.position.y += n.y, s.angle += n.angle) } }, e.solveAll = function (o, t) { for (var s = u.clamp(t / u._baseDelta, 0, 1), n = 0; n < o.length; n += 1) { var c = o[n], d = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic; (d || m) && e.solve(o[n], s) } for (n = 0; n < o.length; n += 1)c = o[n], d = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic, !d && !m && e.solve(o[n], s) }, e.solve = function (o, t) { var s = o.bodyA, n = o.bodyB, c = o.pointA, d = o.pointB; if (!(!s && !n)) { s && !s.isStatic && (a.rotate(c, s.angle - o.angleA, c), o.angleA = s.angle), n && !n.isStatic && (a.rotate(d, n.angle - o.angleB, d), o.angleB = n.angle); var m = c, S = d; if (s && (m = a.add(s.position, c)), n && (S = a.add(n.position, d)), !(!m || !S)) { var D = a.sub(m, S), h = a.magnitude(D); h < e._minLength && (h = e._minLength); var g = (h - o.length) / h, x = o.stiffness >= 1 || o.length === 0, v = x ? o.stiffness * t : o.stiffness * t * t, M = o.damping * t, y = a.mult(D, g * v), C = (s ? s.inverseMass : 0) + (n ? n.inverseMass : 0), P = (s ? s.inverseInertia : 0) + (n ? n.inverseInertia : 0), T = C + P, E, I, B, L, F; if (M > 0) { var W = a.create(); B = a.div(D, h), F = a.sub(n && a.sub(n.position, n.positionPrev) || W, s && a.sub(s.position, s.positionPrev) || W), L = a.dot(B, F) } s && !s.isStatic && (I = s.inverseMass / C, s.constraintImpulse.x -= y.x * I, s.constraintImpulse.y -= y.y * I, s.position.x -= y.x * I, s.position.y -= y.y * I, M > 0 && (s.positionPrev.x -= M * B.x * L * I, s.positionPrev.y -= M * B.y * L * I), E = a.cross(c, y) / T * e._torqueDampen * s.inverseInertia * (1 - o.angularStiffness), s.constraintImpulse.angle -= E, s.angle -= E), n && !n.isStatic && (I = n.inverseMass / C, n.constraintImpulse.x += y.x * I, n.constraintImpulse.y += y.y * I, n.position.x += y.x * I, n.position.y += y.y * I, M > 0 && (n.positionPrev.x += M * B.x * L * I, n.positionPrev.y += M * B.y * L * I), E = a.cross(d, y) / T * e._torqueDampen * n.inverseInertia * (1 - o.angularStiffness), n.constraintImpulse.angle += E, n.angle += E) } } }, e.postSolveAll = function (o) { for (var t = 0; t < o.length; t++) { var s = o[t], n = s.constraintImpulse; if (!(s.isStatic || n.x === 0 && n.y === 0 && n.angle === 0)) { r.set(s, !1); for (var c = 0; c < s.parts.length; c++) { var d = s.parts[c]; l.translate(d.vertices, n), c > 0 && (d.position.x += n.x, d.position.y += n.y), n.angle !== 0 && (l.rotate(d.vertices, n.angle, s.position), i.rotate(d.axes, n.angle), c > 0 && a.rotateAbout(d.position, n.angle, s.position, d.position)), f.update(d.bounds, d.vertices, s.velocity) } n.angle *= e._warming, n.x *= e._warming, n.y *= e._warming } } }, e.pointAWorld = function (o) { return { x: (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), y: (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0) } }, e.pointBWorld = function (o) { return { x: (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), y: (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0) } }, e.currentLength = function (o) { var t = (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), s = (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0), n = (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), c = (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0), d = t - n, m = s - c; return Math.sqrt(d * d + m * m) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), a = p(0); (function () { e.fromVertices = function (r) { for (var f = {}, i = 0; i < r.length; i++) { var u = (i + 1) % r.length, o = l.normalise({ x: r[u].y - r[i].y, y: r[i].x - r[u].x }), t = o.y === 0 ? 1 / 0 : o.x / o.y; t = t.toFixed(3).toString(), f[t] = o } return a.values(f) }, e.rotate = function (r, f) { if (f !== 0) for (var i = Math.cos(f), u = Math.sin(f), o = 0; o < r.length; o++) { var t = r[o], s; s = t.x * i - t.y * u, t.y = t.x * u + t.y * i, t.x = s } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(0), r = p(4), f = p(1), i = p(2); (function () { e.rectangle = function (u, o, t, s, n) { n = n || {}; var c = { label: "Rectangle Body", position: { x: u, y: o }, vertices: l.fromPath("L 0 0 L " + t + " 0 L " + t + " " + s + " L 0 " + s) }; if (n.chamfer) { var d = n.chamfer; c.vertices = l.chamfer(c.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete n.chamfer } return r.create(a.extend({}, c, n)) }, e.trapezoid = function (u, o, t, s, n, c) { c = c || {}, n >= 1 && a.warn("Bodies.trapezoid: slope parameter must be < 1."), n *= .5; var d = (1 - n * 2) * t, m = t * n, S = m + d, D = S + m, h; n < .5 ? h = "L 0 0 L " + m + " " + -s + " L " + S + " " + -s + " L " + D + " 0" : h = "L 0 0 L " + S + " " + -s + " L " + D + " 0"; var g = { label: "Trapezoid Body", position: { x: u, y: o }, vertices: l.fromPath(h) }; if (c.chamfer) { var x = c.chamfer; g.vertices = l.chamfer(g.vertices, x.radius, x.quality, x.qualityMin, x.qualityMax), delete c.chamfer } return r.create(a.extend({}, g, c)) }, e.circle = function (u, o, t, s, n) { s = s || {}; var c = { label: "Circle Body", circleRadius: t }; n = n || 25; var d = Math.ceil(Math.max(10, Math.min(n, t))); return d % 2 === 1 && (d += 1), e.polygon(u, o, d, t, a.extend({}, c, s)) }, e.polygon = function (u, o, t, s, n) { if (n = n || {}, t < 3) return e.circle(u, o, s, n); for (var c = 2 * Math.PI / t, d = "", m = c * .5, S = 0; S < t; S += 1) { var D = m + S * c, h = Math.cos(D) * s, g = Math.sin(D) * s; d += "L " + h.toFixed(3) + " " + g.toFixed(3) + " " } var x = { label: "Polygon Body", position: { x: u, y: o }, vertices: l.fromPath(d) }; if (n.chamfer) { var v = n.chamfer; x.vertices = l.chamfer(x.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete n.chamfer } return r.create(a.extend({}, x, n)) }, e.fromVertices = function (u, o, t, s, n, c, d, m) { var S = a.getDecomp(), D, h, g, x, v, M, y, C, P, T, E; for (D = !!(S && S.quickDecomp), s = s || {}, g = [], n = typeof n < "u" ? n : !1, c = typeof c < "u" ? c : .01, d = typeof d < "u" ? d : 10, m = typeof m < "u" ? m : .01, a.isArray(t[0]) || (t = [t]), T = 0; T < t.length; T += 1)if (M = t[T], x = l.isConvex(M), v = !x, v && !D && a.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), x || !D) x ? M = l.clockwiseSort(M) : M = l.hull(M), g.push({ position: { x: u, y: o }, vertices: M }); else { var I = M.map(function (V) { return [V.x, V.y] }); S.makeCCW(I), c !== !1 && S.removeCollinearPoints(I, c), m !== !1 && S.removeDuplicatePoints && S.removeDuplicatePoints(I, m); var B = S.quickDecomp(I); for (y = 0; y < B.length; y++) { var L = B[y], F = L.map(function (V) { return { x: V[0], y: V[1] } }); d > 0 && l.area(F) < d || g.push({ position: l.centre(F), vertices: F }) } } for (y = 0; y < g.length; y++)g[y] = r.create(a.extend(g[y], s)); if (n) { var W = 5; for (y = 0; y < g.length; y++) { var b = g[y]; for (C = y + 1; C < g.length; C++) { var G = g[C]; if (f.overlaps(b.bounds, G.bounds)) { var $ = b.vertices, q = G.vertices; for (P = 0; P < b.vertices.length; P++)for (E = 0; E < G.vertices.length; E++) { var ee = i.magnitudeSquared(i.sub($[(P + 1) % $.length], q[E])), Z = i.magnitudeSquared(i.sub($[P], q[(E + 1) % q.length])); ee < W && Z < W && ($[P].isInternal = !0, q[E].isInternal = !0) } } } } } return g.length > 1 ? (h = r.create(a.extend({ parts: g.slice(0) }, s)), r.setPosition(h, { x: u, y: o }), h) : g[0] } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0), a = p(8); (function () { e.create = function (r) { var f = { bodies: [], collisions: [], pairs: null }; return l.extend(f, r) }, e.setBodies = function (r, f) { r.bodies = f.slice(0) }, e.clear = function (r) { r.bodies = [], r.collisions = [] }, e.collisions = function (r) { var f = r.pairs, i = r.bodies, u = i.length, o = e.canCollide, t = a.collides, s = r.collisions, n = 0, c, d; for (i.sort(e._compareBoundsX), c = 0; c < u; c++) { var m = i[c], S = m.bounds, D = m.bounds.max.x, h = m.bounds.max.y, g = m.bounds.min.y, x = m.isStatic || m.isSleeping, v = m.parts.length, M = v === 1; for (d = c + 1; d < u; d++) { var y = i[d], C = y.bounds; if (C.min.x > D) break; if (!(h < C.min.y || g > C.max.y) && !(x && (y.isStatic || y.isSleeping)) && o(m.collisionFilter, y.collisionFilter)) { var P = y.parts.length; if (M && P === 1) { var T = t(m, y, f); T && (s[n++] = T) } else for (var E = v > 1 ? 1 : 0, I = P > 1 ? 1 : 0, B = E; B < v; B++)for (var L = m.parts[B], S = L.bounds, F = I; F < P; F++) { var W = y.parts[F], C = W.bounds; if (!(S.min.x > C.max.x || S.max.x < C.min.x || S.max.y < C.min.y || S.min.y > C.max.y)) { var T = t(L, W, f); T && (s[n++] = T) } } } } } return s.length !== n && (s.length = n), s }, e.canCollide = function (r, f) { return r.group === f.group && r.group !== 0 ? r.group > 0 : (r.mask & f.category) !== 0 && (f.mask & r.category) !== 0 }, e._compareBoundsX = function (r, f) { return r.bounds.min.x - f.bounds.min.x } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e.create = function (a) { var r = {}; return a || l.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), r.element = a || document.body, r.absolute = { x: 0, y: 0 }, r.position = { x: 0, y: 0 }, r.mousedownPosition = { x: 0, y: 0 }, r.mouseupPosition = { x: 0, y: 0 }, r.offset = { x: 0, y: 0 }, r.scale = { x: 1, y: 1 }, r.wheelDelta = 0, r.button = -1, r.pixelRatio = parseInt(r.element.getAttribute("data-pixel-ratio"), 10) || 1, r.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, r.mousemove = function (f) { var i = e._getRelativeMousePosition(f, r.element, r.pixelRatio), u = f.changedTouches; u && (r.button = 0, f.preventDefault()), r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.sourceEvents.mousemove = f }, r.mousedown = function (f) { var i = e._getRelativeMousePosition(f, r.element, r.pixelRatio), u = f.changedTouches; u ? (r.button = 0, f.preventDefault()) : r.button = f.button, r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mousedownPosition.x = r.position.x, r.mousedownPosition.y = r.position.y, r.sourceEvents.mousedown = f }, r.mouseup = function (f) { var i = e._getRelativeMousePosition(f, r.element, r.pixelRatio), u = f.changedTouches; u && f.preventDefault(), r.button = -1, r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mouseupPosition.x = r.position.x, r.mouseupPosition.y = r.position.y, r.sourceEvents.mouseup = f }, r.mousewheel = function (f) { r.wheelDelta = Math.max(-1, Math.min(1, f.wheelDelta || -f.detail)), f.preventDefault(), r.sourceEvents.mousewheel = f }, e.setElement(r, r.element), r }, e.setElement = function (a, r) { a.element = r, r.addEventListener("mousemove", a.mousemove, { passive: !0 }), r.addEventListener("mousedown", a.mousedown, { passive: !0 }), r.addEventListener("mouseup", a.mouseup, { passive: !0 }), r.addEventListener("wheel", a.mousewheel, { passive: !1 }), r.addEventListener("touchmove", a.mousemove, { passive: !1 }), r.addEventListener("touchstart", a.mousedown, { passive: !1 }), r.addEventListener("touchend", a.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (a) { a.sourceEvents.mousemove = null, a.sourceEvents.mousedown = null, a.sourceEvents.mouseup = null, a.sourceEvents.mousewheel = null, a.wheelDelta = 0 }, e.setOffset = function (a, r) { a.offset.x = r.x, a.offset.y = r.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }, e.setScale = function (a, r) { a.scale.x = r.x, a.scale.y = r.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }, e._getRelativeMousePosition = function (a, r, f) { var i = r.getBoundingClientRect(), u = document.documentElement || document.body.parentNode || document.body, o = window.pageXOffset !== void 0 ? window.pageXOffset : u.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : u.scrollTop, s = a.changedTouches, n, c; return s ? (n = s[0].pageX - i.left - o, c = s[0].pageY - i.top - t) : (n = a.pageX - i.left - o, c = a.pageY - i.top - t), { x: n / (r.clientWidth / (r.width || r.clientWidth) * f), y: c / (r.clientHeight / (r.height || r.clientHeight) * f) } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e._registry = {}, e.register = function (a) { if (e.isPlugin(a) || l.warn("Plugin.register:", e.toString(a), "does not implement all required fields."), a.name in e._registry) { var r = e._registry[a.name], f = e.versionParse(a.version).number, i = e.versionParse(r.version).number; f > i ? (l.warn("Plugin.register:", e.toString(r), "was upgraded to", e.toString(a)), e._registry[a.name] = a) : f < i ? l.warn("Plugin.register:", e.toString(r), "can not be downgraded to", e.toString(a)) : a !== r && l.warn("Plugin.register:", e.toString(a), "is already registered to different plugin object") } else e._registry[a.name] = a; return a }, e.resolve = function (a) { return e._registry[e.dependencyParse(a).name] }, e.toString = function (a) { return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0") }, e.isPlugin = function (a) { return a && a.name && a.version && a.install }, e.isUsed = function (a, r) { return a.used.indexOf(r) > -1 }, e.isFor = function (a, r) { var f = a.for && e.dependencyParse(a.for); return !a.for || r.name === f.name && e.versionSatisfies(r.version, f.range) }, e.use = function (a, r) { if (a.uses = (a.uses || []).concat(r || []), a.uses.length === 0) { l.warn("Plugin.use:", e.toString(a), "does not specify any dependencies to install."); return } for (var f = e.dependencies(a), i = l.topologicalSort(f), u = [], o = 0; o < i.length; o += 1)if (i[o] !== a.name) { var t = e.resolve(i[o]); if (!t) { u.push("❌ " + i[o]); continue } e.isUsed(a, t.name) || (e.isFor(t, a) || (l.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(a) + "."), t._warned = !0), t.install ? t.install(a) : (l.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (u.push("🔶 " + e.toString(t)), delete t._warned) : u.push("✅ " + e.toString(t)), a.used.push(t.name)) } u.length > 0 && l.info(u.join("  ")) }, e.dependencies = function (a, r) { var f = e.dependencyParse(a), i = f.name; if (r = r || {}, !(i in r)) { a = e.resolve(a) || a, r[i] = l.map(a.uses || [], function (o) { e.isPlugin(o) && e.register(o); var t = e.dependencyParse(o), s = e.resolve(o); return s && !e.versionSatisfies(s.version, t.range) ? (l.warn("Plugin.dependencies:", e.toString(s), "does not satisfy", e.toString(t), "used by", e.toString(f) + "."), s._warned = !0, a._warned = !0) : s || (l.warn("Plugin.dependencies:", e.toString(o), "used by", e.toString(f), "could not be resolved."), a._warned = !0), t.name }); for (var u = 0; u < r[i].length; u += 1)e.dependencies(r[i][u], r); return r } }, e.dependencyParse = function (a) { if (l.isString(a)) { var r = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return r.test(a) || l.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."), { name: a.split("@")[0], range: a.split("@")[1] || "*" } } return { name: a.name, range: a.range || a.version } }, e.versionParse = function (a) { var r = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; r.test(a) || l.warn("Plugin.versionParse:", a, "is not a valid version or range."); var f = r.exec(a), i = Number(f[4]), u = Number(f[5]), o = Number(f[6]); return { isRange: !!(f[1] || f[2]), version: f[3], range: a, operator: f[1] || f[2] || "", major: i, minor: u, patch: o, parts: [i, u, o], prerelease: f[7], number: i * 1e8 + u * 1e4 + o } }, e.versionSatisfies = function (a, r) { r = r || "*"; var f = e.versionParse(r), i = e.versionParse(a); if (f.isRange) { if (f.operator === "*" || a === "*") return !0; if (f.operator === ">") return i.number > f.number; if (f.operator === ">=") return i.number >= f.number; if (f.operator === "~") return i.major === f.major && i.minor === f.minor && i.patch >= f.patch; if (f.operator === "^") return f.major > 0 ? i.major === f.major && i.number >= f.number : f.minor > 0 ? i.minor === f.minor && i.patch >= f.patch : i.patch === f.patch } return a === r || a === "*" } })() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(7), a = p(18), r = p(13), f = p(19), i = p(5), u = p(6), o = p(10), t = p(0), s = p(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (n) { n = n || {}; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, d = t.extend(c, n); return d.world = n.world || u.create({ label: "World" }), d.pairs = n.pairs || f.create(), d.detector = n.detector || r.create(), d.detector.pairs = d.pairs, d.grid = { buckets: [] }, d.world.gravity = d.gravity, d.broadphase = d.grid, d.metrics = {}, d }, e.update = function (n, c) { var d = t.now(), m = n.world, S = n.detector, D = n.pairs, h = n.timing, g = h.timestamp, x; c > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), c = typeof c < "u" ? c : t._baseDelta, c *= h.timeScale, h.timestamp += c, h.lastDelta = c; var v = { timestamp: h.timestamp, delta: c }; i.trigger(n, "beforeUpdate", v); var M = u.allBodies(m), y = u.allConstraints(m); for (m.isModified && (r.setBodies(S, M), u.setModified(m, !1, !1, !0)), n.enableSleeping && l.update(M, c), e._bodiesApplyGravity(M, n.gravity), c > 0 && e._bodiesUpdate(M, c), i.trigger(n, "beforeSolve", v), o.preSolveAll(M), x = 0; x < n.constraintIterations; x++)o.solveAll(y, c); o.postSolveAll(M); var C = r.collisions(S); f.update(D, C, g), n.enableSleeping && l.afterCollisions(D.list), D.collisionStart.length > 0 && i.trigger(n, "collisionStart", { pairs: D.collisionStart, timestamp: h.timestamp, delta: c }); var P = t.clamp(20 / n.positionIterations, 0, 1); for (a.preSolvePosition(D.list), x = 0; x < n.positionIterations; x++)a.solvePosition(D.list, c, P); for (a.postSolvePosition(M), o.preSolveAll(M), x = 0; x < n.constraintIterations; x++)o.solveAll(y, c); for (o.postSolveAll(M), a.preSolveVelocity(D.list), x = 0; x < n.velocityIterations; x++)a.solveVelocity(D.list, c); return e._bodiesUpdateVelocities(M), D.collisionActive.length > 0 && i.trigger(n, "collisionActive", { pairs: D.collisionActive, timestamp: h.timestamp, delta: c }), D.collisionEnd.length > 0 && i.trigger(n, "collisionEnd", { pairs: D.collisionEnd, timestamp: h.timestamp, delta: c }), e._bodiesClearForces(M), i.trigger(n, "afterUpdate", v), n.timing.lastElapsed = t.now() - d, n }, e.merge = function (n, c) { if (t.extend(n, c), c.world) { n.world = c.world, e.clear(n); for (var d = u.allBodies(n.world), m = 0; m < d.length; m++) { var S = d[m]; l.set(S, !1), S.id = t.nextId() } } }, e.clear = function (n) { f.clear(n.pairs), r.clear(n.detector) }, e._bodiesClearForces = function (n) { for (var c = n.length, d = 0; d < c; d++) { var m = n[d]; m.force.x = 0, m.force.y = 0, m.torque = 0 } }, e._bodiesApplyGravity = function (n, c) { var d = typeof c.scale < "u" ? c.scale : .001, m = n.length; if (!(c.x === 0 && c.y === 0 || d === 0)) for (var S = 0; S < m; S++) { var D = n[S]; D.isStatic || D.isSleeping || (D.force.y += D.mass * c.y * d, D.force.x += D.mass * c.x * d) } }, e._bodiesUpdate = function (n, c) { for (var d = n.length, m = 0; m < d; m++) { var S = n[m]; S.isStatic || S.isSleeping || s.update(S, c) } }, e._bodiesUpdateVelocities = function (n) { for (var c = n.length, d = 0; d < c; d++)s.updateVelocities(n[d]) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(0), r = p(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (f) { var i, u, o, t = f.length; for (i = 0; i < t; i++)u = f[i], u.isActive && (o = u.contactCount, u.collision.parentA.totalContacts += o, u.collision.parentB.totalContacts += o) }, e.solvePosition = function (f, i, u) { var o, t, s, n, c, d, m, S, D = e._positionDampen * (u || 1), h = a.clamp(i / a._baseDelta, 0, 1), g = f.length; for (o = 0; o < g; o++)t = f[o], !(!t.isActive || t.isSensor) && (s = t.collision, n = s.parentA, c = s.parentB, d = s.normal, t.separation = s.depth + d.x * (c.positionImpulse.x - n.positionImpulse.x) + d.y * (c.positionImpulse.y - n.positionImpulse.y)); for (o = 0; o < g; o++)t = f[o], !(!t.isActive || t.isSensor) && (s = t.collision, n = s.parentA, c = s.parentB, d = s.normal, S = t.separation - t.slop * h, (n.isStatic || c.isStatic) && (S *= 2), n.isStatic || n.isSleeping || (m = D / n.totalContacts, n.positionImpulse.x += d.x * S * m, n.positionImpulse.y += d.y * S * m), c.isStatic || c.isSleeping || (m = D / c.totalContacts, c.positionImpulse.x -= d.x * S * m, c.positionImpulse.y -= d.y * S * m)) }, e.postSolvePosition = function (f) { for (var i = e._positionWarming, u = f.length, o = l.translate, t = r.update, s = 0; s < u; s++) { var n = f[s], c = n.positionImpulse, d = c.x, m = c.y, S = n.velocity; if (n.totalContacts = 0, d !== 0 || m !== 0) { for (var D = 0; D < n.parts.length; D++) { var h = n.parts[D]; o(h.vertices, c), t(h.bounds, h.vertices, S), h.position.x += d, h.position.y += m } n.positionPrev.x += d, n.positionPrev.y += m, d * S.x + m * S.y < 0 ? (c.x = 0, c.y = 0) : (c.x *= i, c.y *= i) } } }, e.preSolveVelocity = function (f) { var i = f.length, u, o; for (u = 0; u < i; u++) { var t = f[u]; if (!(!t.isActive || t.isSensor)) { var s = t.contacts, n = t.contactCount, c = t.collision, d = c.parentA, m = c.parentB, S = c.normal, D = c.tangent; for (o = 0; o < n; o++) { var h = s[o], g = h.vertex, x = h.normalImpulse, v = h.tangentImpulse; if (x !== 0 || v !== 0) { var M = S.x * x + D.x * v, y = S.y * x + D.y * v; d.isStatic || d.isSleeping || (d.positionPrev.x += M * d.inverseMass, d.positionPrev.y += y * d.inverseMass, d.anglePrev += d.inverseInertia * ((g.x - d.position.x) * y - (g.y - d.position.y) * M)), m.isStatic || m.isSleeping || (m.positionPrev.x -= M * m.inverseMass, m.positionPrev.y -= y * m.inverseMass, m.anglePrev -= m.inverseInertia * ((g.x - m.position.x) * y - (g.y - m.position.y) * M)) } } } } }, e.solveVelocity = function (f, i) { var u = i / a._baseDelta, o = u * u, t = o * u, s = -e._restingThresh * u, n = e._restingThreshTangent, c = e._frictionNormalMultiplier * u, d = e._frictionMaxStatic, m = f.length, S, D, h, g; for (h = 0; h < m; h++) { var x = f[h]; if (!(!x.isActive || x.isSensor)) { var v = x.collision, M = v.parentA, y = v.parentB, C = v.normal.x, P = v.normal.y, T = v.tangent.x, E = v.tangent.y, I = x.inverseMass, B = x.friction * x.frictionStatic * c, L = x.contacts, F = x.contactCount, W = 1 / F, b = M.position.x - M.positionPrev.x, G = M.position.y - M.positionPrev.y, $ = M.angle - M.anglePrev, q = y.position.x - y.positionPrev.x, ee = y.position.y - y.positionPrev.y, Z = y.angle - y.anglePrev; for (g = 0; g < F; g++) { var V = L[g], K = V.vertex, z = K.x - M.position.x, ae = K.y - M.position.y, X = K.x - y.position.x, Y = K.y - y.position.y, J = b - ae * $, Ue = G + z * $, Ne = q - Y * Z, Ge = ee + X * Z, Pe = J - Ne, De = Ue - Ge, de = C * Pe + P * De, _ = T * Pe + E * De, Oe = x.separation + de, ge = Math.min(Oe, 1); ge = Oe < 0 ? 0 : ge; var Ae = ge * B; _ < -Ae || _ > Ae ? (D = _ > 0 ? _ : -_, S = x.friction * (_ > 0 ? 1 : -1) * t, S < -D ? S = -D : S > D && (S = D)) : (S = _, D = d); var Te = z * P - ae * C, Ie = X * P - Y * C, Ee = W / (I + M.inverseInertia * Te * Te + y.inverseInertia * Ie * Ie), fe = (1 + x.restitution) * de * Ee; if (S *= Ee, de < s) V.normalImpulse = 0; else { var $e = V.normalImpulse; V.normalImpulse += fe, V.normalImpulse > 0 && (V.normalImpulse = 0), fe = V.normalImpulse - $e } if (_ < -n || _ > n) V.tangentImpulse = 0; else { var ze = V.tangentImpulse; V.tangentImpulse += S, V.tangentImpulse < -D && (V.tangentImpulse = -D), V.tangentImpulse > D && (V.tangentImpulse = D), S = V.tangentImpulse - ze } var ue = C * fe + T * S, he = P * fe + E * S; M.isStatic || M.isSleeping || (M.positionPrev.x += ue * M.inverseMass, M.positionPrev.y += he * M.inverseMass, M.anglePrev += (z * he - ae * ue) * M.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= ue * y.inverseMass, y.positionPrev.y -= he * y.inverseMass, y.anglePrev -= (X * he - Y * ue) * y.inverseInertia) } } } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(9), a = p(0); (function () { e.create = function (r) { return a.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, r) }, e.update = function (r, f, i) { var u = l.update, o = l.create, t = l.setActive, s = r.table, n = r.list, c = n.length, d = c, m = r.collisionStart, S = r.collisionEnd, D = r.collisionActive, h = f.length, g = 0, x = 0, v = 0, M, y, C; for (C = 0; C < h; C++)M = f[C], y = M.pair, y ? (y.isActive && (D[v++] = y), u(y, M, i)) : (y = o(M, i), s[y.id] = y, m[g++] = y, n[d++] = y); for (d = 0, c = n.length, C = 0; C < c; C++)y = n[C], y.timeUpdated >= i ? n[d++] = y : (t(y, !1, i), y.collision.bodyA.sleepCounter > 0 && y.collision.bodyB.sleepCounter > 0 ? n[d++] = y : (S[x++] = y, delete s[y.id])); n.length !== d && (n.length = d), m.length !== g && (m.length = g), S.length !== x && (S.length = x), D.length !== v && (D.length = v) }, e.clear = function (r) { return r.table = {}, r.list.length = 0, r.collisionStart.length = 0, r.collisionActive.length = 0, r.collisionEnd.length = 0, r } })() }, function (w, O, p) { var e = w.exports = p(21); e.Axes = p(11), e.Bodies = p(12), e.Body = p(4), e.Bounds = p(1), e.Collision = p(8), e.Common = p(0), e.Composite = p(6), e.Composites = p(22), e.Constraint = p(10), e.Contact = p(16), e.Detector = p(13), e.Engine = p(17), e.Events = p(5), e.Grid = p(23), e.Mouse = p(14), e.MouseConstraint = p(24), e.Pair = p(9), e.Pairs = p(19), e.Plugin = p(15), e.Query = p(25), e.Render = p(26), e.Resolver = p(18), e.Runner = p(27), e.SAT = p(28), e.Sleeping = p(7), e.Svg = p(29), e.Vector = p(2), e.Vertices = p(3), e.World = p(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function (w, O, p) { var e = {}; w.exports = e; var l = p(15), a = p(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { l.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (r, f) { return r = r.replace(/^Matter./, ""), a.chainPathBefore(e, r, f) }, e.after = function (r, f) { return r = r.replace(/^Matter./, ""), a.chainPathAfter(e, r, f) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(6), a = p(10), r = p(0), f = p(4), i = p(12), u = r.deprecated; (function () { e.stack = function (o, t, s, n, c, d, m) { for (var S = l.create({ label: "Stack" }), D = o, h = t, g, x = 0, v = 0; v < n; v++) { for (var M = 0, y = 0; y < s; y++) { var C = m(D, h, y, v, g, x); if (C) { var P = C.bounds.max.y - C.bounds.min.y, T = C.bounds.max.x - C.bounds.min.x; P > M && (M = P), f.translate(C, { x: T * .5, y: P * .5 }), D = C.bounds.max.x + c, l.addBody(S, C), g = C, x += 1 } else D += c } h += M + d, D = o } return S }, e.chain = function (o, t, s, n, c, d) { for (var m = o.bodies, S = 1; S < m.length; S++) { var D = m[S - 1], h = m[S], g = D.bounds.max.y - D.bounds.min.y, x = D.bounds.max.x - D.bounds.min.x, v = h.bounds.max.y - h.bounds.min.y, M = h.bounds.max.x - h.bounds.min.x, y = { bodyA: D, pointA: { x: x * t, y: g * s }, bodyB: h, pointB: { x: M * n, y: v * c } }, C = r.extend(y, d); l.addConstraint(o, a.create(C)) } return o.label += " Chain", o }, e.mesh = function (o, t, s, n, c) { var d = o.bodies, m, S, D, h, g; for (m = 0; m < s; m++) { for (S = 1; S < t; S++)D = d[S - 1 + m * t], h = d[S + m * t], l.addConstraint(o, a.create(r.extend({ bodyA: D, bodyB: h }, c))); if (m > 0) for (S = 0; S < t; S++)D = d[S + (m - 1) * t], h = d[S + m * t], l.addConstraint(o, a.create(r.extend({ bodyA: D, bodyB: h }, c))), n && S > 0 && (g = d[S - 1 + (m - 1) * t], l.addConstraint(o, a.create(r.extend({ bodyA: g, bodyB: h }, c)))), n && S < t - 1 && (g = d[S + 1 + (m - 1) * t], l.addConstraint(o, a.create(r.extend({ bodyA: g, bodyB: h }, c)))) } return o.label += " Mesh", o }, e.pyramid = function (o, t, s, n, c, d, m) { return e.stack(o, t, s, n, c, d, function (S, D, h, g, x, v) { var M = Math.min(n, Math.ceil(s / 2)), y = x ? x.bounds.max.x - x.bounds.min.x : 0; if (!(g > M)) { g = M - g; var C = g, P = s - 1 - g; if (!(h < C || h > P)) { v === 1 && f.translate(x, { x: (h + (s % 2 === 1 ? 1 : -1)) * y, y: 0 }); var T = x ? h * y : 0; return m(o + T + h * c, D, h, g, x, v) } } }) }, e.newtonsCradle = function (o, t, s, n, c) { for (var d = l.create({ label: "Newtons Cradle" }), m = 0; m < s; m++) { var S = 1.9, D = i.circle(o + m * (n * S), t + c, n, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), h = a.create({ pointA: { x: o + m * (n * S), y: t }, bodyB: D }); l.addBody(d, D), l.addConstraint(d, h) } return d }, u(e, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), e.car = function (o, t, s, n, c) { var d = f.nextGroup(!0), m = 20, S = -s * .5 + m, D = s * .5 - m, h = 0, g = l.create({ label: "Car" }), x = i.rectangle(o, t, s, n, { collisionFilter: { group: d }, chamfer: { radius: n * .5 }, density: 2e-4 }), v = i.circle(o + S, t + h, c, { collisionFilter: { group: d }, friction: .8 }), M = i.circle(o + D, t + h, c, { collisionFilter: { group: d }, friction: .8 }), y = a.create({ bodyB: x, pointB: { x: S, y: h }, bodyA: v, stiffness: 1, length: 0 }), C = a.create({ bodyB: x, pointB: { x: D, y: h }, bodyA: M, stiffness: 1, length: 0 }); return l.addBody(g, x), l.addBody(g, v), l.addBody(g, M), l.addConstraint(g, y), l.addConstraint(g, C), g }, u(e, "car", "Composites.car ➤ moved to car example"), e.softBody = function (o, t, s, n, c, d, m, S, D, h) { D = r.extend({ inertia: 1 / 0 }, D), h = r.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, h); var g = e.stack(o, t, s, n, c, d, function (x, v) { return i.circle(x, v, S, D) }); return e.mesh(g, s, n, m, h), g.label = "Soft Body", g }, u(e, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(9), a = p(0), r = a.deprecated; (function () { e.create = function (f) { var i = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return a.extend(i, f) }, e.update = function (f, i, u, o) { var t, s, n, c = u.world, d = f.buckets, m, S, D = !1; for (t = 0; t < i.length; t++) { var h = i[t]; if (!(h.isSleeping && !o) && !(c.bounds && (h.bounds.max.x < c.bounds.min.x || h.bounds.min.x > c.bounds.max.x || h.bounds.max.y < c.bounds.min.y || h.bounds.min.y > c.bounds.max.y))) { var g = e._getRegion(f, h); if (!h.region || g.id !== h.region.id || o) { (!h.region || o) && (h.region = g); var x = e._regionUnion(g, h.region); for (s = x.startCol; s <= x.endCol; s++)for (n = x.startRow; n <= x.endRow; n++) { S = e._getBucketId(s, n), m = d[S]; var v = s >= g.startCol && s <= g.endCol && n >= g.startRow && n <= g.endRow, M = s >= h.region.startCol && s <= h.region.endCol && n >= h.region.startRow && n <= h.region.endRow; !v && M && M && m && e._bucketRemoveBody(f, m, h), (h.region === g || v && !M || o) && (m || (m = e._createBucket(d, S)), e._bucketAddBody(f, m, h)) } h.region = g, D = !0 } } } D && (f.pairsList = e._createActivePairsList(f)) }, r(e, "update", "Grid.update ➤ replaced by Matter.Detector"), e.clear = function (f) { f.buckets = {}, f.pairs = {}, f.pairsList = [] }, r(e, "clear", "Grid.clear ➤ replaced by Matter.Detector"), e._regionUnion = function (f, i) { var u = Math.min(f.startCol, i.startCol), o = Math.max(f.endCol, i.endCol), t = Math.min(f.startRow, i.startRow), s = Math.max(f.endRow, i.endRow); return e._createRegion(u, o, t, s) }, e._getRegion = function (f, i) { var u = i.bounds, o = Math.floor(u.min.x / f.bucketWidth), t = Math.floor(u.max.x / f.bucketWidth), s = Math.floor(u.min.y / f.bucketHeight), n = Math.floor(u.max.y / f.bucketHeight); return e._createRegion(o, t, s, n) }, e._createRegion = function (f, i, u, o) { return { id: f + "," + i + "," + u + "," + o, startCol: f, endCol: i, startRow: u, endRow: o } }, e._getBucketId = function (f, i) { return "C" + f + "R" + i }, e._createBucket = function (f, i) { var u = f[i] = []; return u }, e._bucketAddBody = function (f, i, u) { var o = f.pairs, t = l.id, s = i.length, n; for (n = 0; n < s; n++) { var c = i[n]; if (!(u.id === c.id || u.isStatic && c.isStatic)) { var d = t(u, c), m = o[d]; m ? m[2] += 1 : o[d] = [u, c, 1] } } i.push(u) }, e._bucketRemoveBody = function (f, i, u) { var o = f.pairs, t = l.id, s; i.splice(a.indexOf(i, u), 1); var n = i.length; for (s = 0; s < n; s++) { var c = o[t(u, i[s])]; c && (c[2] -= 1) } }, e._createActivePairsList = function (f) { var i, u = f.pairs, o = a.keys(u), t = o.length, s = [], n; for (n = 0; n < t; n++)i = u[o[n]], i[2] > 0 ? s.push(i) : delete u[o[n]]; return s } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), a = p(7), r = p(14), f = p(5), i = p(13), u = p(10), o = p(6), t = p(0), s = p(1); (function () { e.create = function (n, c) { var d = (n ? n.mouse : null) || (c ? c.mouse : null); d || (n && n.render && n.render.canvas ? d = r.create(n.render.canvas) : c && c.element ? d = r.create(c.element) : (d = r.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var m = u.create({ label: "Mouse Constraint", pointA: d.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), S = { type: "mouseConstraint", mouse: d, element: null, body: null, constraint: m, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, D = t.extend(S, c); return f.on(n, "beforeUpdate", function () { var h = o.allBodies(n.world); e.update(D, h), e._triggerEvents(D) }), D }, e.update = function (n, c) { var d = n.mouse, m = n.constraint, S = n.body; if (d.button === 0) { if (m.bodyB) a.set(m.bodyB, !1), m.pointA = d.position; else for (var D = 0; D < c.length; D++)if (S = c[D], s.contains(S.bounds, d.position) && i.canCollide(S.collisionFilter, n.collisionFilter)) for (var h = S.parts.length > 1 ? 1 : 0; h < S.parts.length; h++) { var g = S.parts[h]; if (l.contains(g.vertices, d.position)) { m.pointA = d.position, m.bodyB = n.body = S, m.pointB = { x: d.position.x - S.position.x, y: d.position.y - S.position.y }, m.angleB = S.angle, a.set(S, !1), f.trigger(n, "startdrag", { mouse: d, body: S }); break } } } else m.bodyB = n.body = null, m.pointB = null, S && f.trigger(n, "enddrag", { mouse: d, body: S }) }, e._triggerEvents = function (n) { var c = n.mouse, d = c.sourceEvents; d.mousemove && f.trigger(n, "mousemove", { mouse: c }), d.mousedown && f.trigger(n, "mousedown", { mouse: c }), d.mouseup && f.trigger(n, "mouseup", { mouse: c }), r.clearSourceEvents(c) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), a = p(8), r = p(1), f = p(12), i = p(3); (function () { e.collides = function (u, o) { for (var t = [], s = o.length, n = u.bounds, c = a.collides, d = r.overlaps, m = 0; m < s; m++) { var S = o[m], D = S.parts.length, h = D === 1 ? 0 : 1; if (d(S.bounds, n)) for (var g = h; g < D; g++) { var x = S.parts[g]; if (d(x.bounds, n)) { var v = c(x, u); if (v) { t.push(v); break } } } } return t }, e.ray = function (u, o, t, s) { s = s || 1e-100; for (var n = l.angle(o, t), c = l.magnitude(l.sub(o, t)), d = (t.x + o.x) * .5, m = (t.y + o.y) * .5, S = f.rectangle(d, m, c, s, { angle: n }), D = e.collides(S, u), h = 0; h < D.length; h += 1) { var g = D[h]; g.body = g.bodyB = g.bodyA } return D }, e.region = function (u, o, t) { for (var s = [], n = 0; n < u.length; n++) { var c = u[n], d = r.overlaps(c.bounds, o); (d && !t || !d && t) && s.push(c) } return s }, e.point = function (u, o) { for (var t = [], s = 0; s < u.length; s++) { var n = u[s]; if (r.contains(n.bounds, o)) for (var c = n.parts.length === 1 ? 0 : 1; c < n.parts.length; c++) { var d = n.parts[c]; if (r.contains(d.bounds, o) && i.contains(d.vertices, o)) { t.push(n); break } } } return t } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(4), a = p(0), r = p(6), f = p(1), i = p(5), u = p(2), o = p(14); (function () { var t, s; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (h) { window.setTimeout(function () { h(a.now()) }, 1e3 / 60) }, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (h) { var g = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!h.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, x = a.extend(g, h); return x.canvas && (x.canvas.width = x.options.width || x.canvas.width, x.canvas.height = x.options.height || x.canvas.height), x.mouse = h.mouse, x.engine = h.engine, x.canvas = x.canvas || d(x.options.width, x.options.height), x.context = x.canvas.getContext("2d"), x.textures = {}, x.bounds = x.bounds || { min: { x: 0, y: 0 }, max: { x: x.canvas.width, y: x.canvas.height } }, x.controller = e, x.options.showBroadphase = !1, x.options.pixelRatio !== 1 && e.setPixelRatio(x, x.options.pixelRatio), a.isElement(x.element) && x.element.appendChild(x.canvas), x }, e.run = function (h) { (function g(x) { h.frameRequestId = t(g), n(h, x), e.world(h, x), h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0), (h.options.showStats || h.options.showDebug) && e.stats(h, h.context, x), (h.options.showPerformance || h.options.showDebug) && e.performance(h, h.context, x), h.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (h) { s(h.frameRequestId) }, e.setPixelRatio = function (h, g) { var x = h.options, v = h.canvas; g === "auto" && (g = m(v)), x.pixelRatio = g, v.setAttribute("data-pixel-ratio", g), v.width = x.width * g, v.height = x.height * g, v.style.width = x.width + "px", v.style.height = x.height + "px" }, e.setSize = function (h, g, x) { h.options.width = g, h.options.height = x, h.bounds.max.x = h.bounds.min.x + g, h.bounds.max.y = h.bounds.min.y + x, h.options.pixelRatio !== 1 ? e.setPixelRatio(h, h.options.pixelRatio) : (h.canvas.width = g, h.canvas.height = x) }, e.lookAt = function (h, g, x, v) { v = typeof v < "u" ? v : !0, g = a.isArray(g) ? g : [g], x = x || { x: 0, y: 0 }; for (var M = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, y = 0; y < g.length; y += 1) { var C = g[y], P = C.bounds ? C.bounds.min : C.min || C.position || C, T = C.bounds ? C.bounds.max : C.max || C.position || C; P && T && (P.x < M.min.x && (M.min.x = P.x), T.x > M.max.x && (M.max.x = T.x), P.y < M.min.y && (M.min.y = P.y), T.y > M.max.y && (M.max.y = T.y)) } var E = M.max.x - M.min.x + 2 * x.x, I = M.max.y - M.min.y + 2 * x.y, B = h.canvas.height, L = h.canvas.width, F = L / B, W = E / I, b = 1, G = 1; W > F ? G = W / F : b = F / W, h.options.hasBounds = !0, h.bounds.min.x = M.min.x, h.bounds.max.x = M.min.x + E * b, h.bounds.min.y = M.min.y, h.bounds.max.y = M.min.y + I * G, v && (h.bounds.min.x += E * .5 - E * b * .5, h.bounds.max.x += E * .5 - E * b * .5, h.bounds.min.y += I * .5 - I * G * .5, h.bounds.max.y += I * .5 - I * G * .5), h.bounds.min.x -= x.x, h.bounds.max.x -= x.x, h.bounds.min.y -= x.y, h.bounds.max.y -= x.y, h.mouse && (o.setScale(h.mouse, { x: (h.bounds.max.x - h.bounds.min.x) / h.canvas.width, y: (h.bounds.max.y - h.bounds.min.y) / h.canvas.height }), o.setOffset(h.mouse, h.bounds.min)) }, e.startViewTransform = function (h) { var g = h.bounds.max.x - h.bounds.min.x, x = h.bounds.max.y - h.bounds.min.y, v = g / h.options.width, M = x / h.options.height; h.context.setTransform(h.options.pixelRatio / v, 0, 0, h.options.pixelRatio / M, 0, 0), h.context.translate(-h.bounds.min.x, -h.bounds.min.y) }, e.endViewTransform = function (h) { h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0) }, e.world = function (h, g) { var x = a.now(), v = h.engine, M = v.world, y = h.canvas, C = h.context, P = h.options, T = h.timing, E = r.allBodies(M), I = r.allConstraints(M), B = P.wireframes ? P.wireframeBackground : P.background, L = [], F = [], W, b = { timestamp: v.timing.timestamp }; if (i.trigger(h, "beforeRender", b), h.currentBackground !== B && D(h, B), C.globalCompositeOperation = "source-in", C.fillStyle = "transparent", C.fillRect(0, 0, y.width, y.height), C.globalCompositeOperation = "source-over", P.hasBounds) { for (W = 0; W < E.length; W++) { var G = E[W]; f.overlaps(G.bounds, h.bounds) && L.push(G) } for (W = 0; W < I.length; W++) { var $ = I[W], q = $.bodyA, ee = $.bodyB, Z = $.pointA, V = $.pointB; q && (Z = u.add(q.position, $.pointA)), ee && (V = u.add(ee.position, $.pointB)), !(!Z || !V) && (f.contains(h.bounds, Z) || f.contains(h.bounds, V)) && F.push($) } e.startViewTransform(h), h.mouse && (o.setScale(h.mouse, { x: (h.bounds.max.x - h.bounds.min.x) / h.options.width, y: (h.bounds.max.y - h.bounds.min.y) / h.options.height }), o.setOffset(h.mouse, h.bounds.min)) } else F = I, L = E, h.options.pixelRatio !== 1 && h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0); !P.wireframes || v.enableSleeping && P.showSleeping ? e.bodies(h, L, C) : (P.showConvexHulls && e.bodyConvexHulls(h, L, C), e.bodyWireframes(h, L, C)), P.showBounds && e.bodyBounds(h, L, C), (P.showAxes || P.showAngleIndicator) && e.bodyAxes(h, L, C), P.showPositions && e.bodyPositions(h, L, C), P.showVelocity && e.bodyVelocity(h, L, C), P.showIds && e.bodyIds(h, L, C), P.showSeparations && e.separations(h, v.pairs.list, C), P.showCollisions && e.collisions(h, v.pairs.list, C), P.showVertexNumbers && e.vertexNumbers(h, L, C), P.showMousePosition && e.mousePosition(h, h.mouse, C), e.constraints(F, C), P.hasBounds && e.endViewTransform(h), i.trigger(h, "afterRender", b), T.lastElapsed = a.now() - x }, e.stats = function (h, g, x) { for (var v = h.engine, M = v.world, y = r.allBodies(M), C = 0, P = 55, T = 44, E = 0, I = 0, B = 0; B < y.length; B += 1)C += y[B].parts.length; var L = { Part: C, Body: y.length, Cons: r.allConstraints(M).length, Comp: r.allComposites(M).length, Pair: v.pairs.list.length }; g.fillStyle = "#0e0f19", g.fillRect(E, I, P * 5.5, T), g.font = "12px Arial", g.textBaseline = "top", g.textAlign = "right"; for (var F in L) { var W = L[F]; g.fillStyle = "#aaa", g.fillText(F, E + P, I + 8), g.fillStyle = "#eee", g.fillText(W, E + P, I + 26), E += P } }, e.performance = function (h, g) { var x = h.engine, v = h.timing, M = v.deltaHistory, y = v.elapsedHistory, C = v.timestampElapsedHistory, P = v.engineDeltaHistory, T = v.engineUpdatesHistory, E = v.engineElapsedHistory, I = x.timing.lastUpdatesPerFrame, B = x.timing.lastDelta, L = c(M), F = c(y), W = c(P), b = c(T), G = c(E), $ = c(C), q = $ / L || 0, ee = Math.round(L / B), Z = 1e3 / L || 0, V = 4, K = 12, z = 60, ae = 34, X = 10, Y = 69; g.fillStyle = "#0e0f19", g.fillRect(0, 50, K * 5 + z * 6 + 22, ae), e.status(g, X, Y, z, V, M.length, Math.round(Z) + " fps", Z / e._goodFps, function (J) { return M[J] / L - 1 }), e.status(g, X + K + z, Y, z, V, P.length, B.toFixed(2) + " dt", e._goodDelta / B, function (J) { return P[J] / W - 1 }), e.status(g, X + (K + z) * 2, Y, z, V, T.length, I + " upf", Math.pow(a.clamp(b / ee || 1, 0, 1), 4), function (J) { return T[J] / b - 1 }), e.status(g, X + (K + z) * 3, Y, z, V, E.length, G.toFixed(2) + " ut", 1 - I * G / e._goodFps, function (J) { return E[J] / G - 1 }), e.status(g, X + (K + z) * 4, Y, z, V, y.length, F.toFixed(2) + " rt", 1 - F / e._goodFps, function (J) { return y[J] / F - 1 }), e.status(g, X + (K + z) * 5, Y, z, V, C.length, q.toFixed(2) + " x", q * q * q, function (J) { return (C[J] / M[J] / q || 0) - 1 }) }, e.status = function (h, g, x, v, M, y, C, P, T) { h.strokeStyle = "#888", h.fillStyle = "#444", h.lineWidth = 1, h.fillRect(g, x + 7, v, 1), h.beginPath(), h.moveTo(g, x + 7 - M * a.clamp(.4 * T(0), -2, 2)); for (var E = 0; E < v; E += 1)h.lineTo(g + E, x + 7 - (E < y ? M * a.clamp(.4 * T(E), -2, 2) : 0)); h.stroke(), h.fillStyle = "hsl(" + a.clamp(25 + 95 * P, 0, 120) + ",100%,60%)", h.fillRect(g, x - 7, 4, 4), h.font = "12px Arial", h.textBaseline = "middle", h.textAlign = "right", h.fillStyle = "#eee", h.fillText(C, g + v, x - 5) }, e.constraints = function (h, g) { for (var x = g, v = 0; v < h.length; v++) { var M = h[v]; if (!(!M.render.visible || !M.pointA || !M.pointB)) { var y = M.bodyA, C = M.bodyB, P, T; if (y ? P = u.add(y.position, M.pointA) : P = M.pointA, M.render.type === "pin") x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.closePath(); else { if (C ? T = u.add(C.position, M.pointB) : T = M.pointB, x.beginPath(), x.moveTo(P.x, P.y), M.render.type === "spring") for (var E = u.sub(T, P), I = u.perp(u.normalise(E)), B = Math.ceil(a.clamp(M.length / 5, 12, 20)), L, F = 1; F < B; F += 1)L = F % 2 === 0 ? 1 : -1, x.lineTo(P.x + E.x * (F / B) + I.x * L * 4, P.y + E.y * (F / B) + I.y * L * 4); x.lineTo(T.x, T.y) } M.render.lineWidth && (x.lineWidth = M.render.lineWidth, x.strokeStyle = M.render.strokeStyle, x.stroke()), M.render.anchors && (x.fillStyle = M.render.strokeStyle, x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.arc(T.x, T.y, 3, 0, 2 * Math.PI), x.closePath(), x.fill()) } } }, e.bodies = function (h, g, x) { var v = x; h.engine; var M = h.options, y = M.showInternalEdges || !M.wireframes, C, P, T, E; for (T = 0; T < g.length; T++)if (C = g[T], !!C.render.visible) { for (E = C.parts.length > 1 ? 1 : 0; E < C.parts.length; E++)if (P = C.parts[E], !!P.render.visible) { if (M.showSleeping && C.isSleeping ? v.globalAlpha = .5 * P.render.opacity : P.render.opacity !== 1 && (v.globalAlpha = P.render.opacity), P.render.sprite && P.render.sprite.texture && !M.wireframes) { var I = P.render.sprite, B = S(h, I.texture); v.translate(P.position.x, P.position.y), v.rotate(P.angle), v.drawImage(B, B.width * -I.xOffset * I.xScale, B.height * -I.yOffset * I.yScale, B.width * I.xScale, B.height * I.yScale), v.rotate(-P.angle), v.translate(-P.position.x, -P.position.y) } else { if (P.circleRadius) v.beginPath(), v.arc(P.position.x, P.position.y, P.circleRadius, 0, 2 * Math.PI); else { v.beginPath(), v.moveTo(P.vertices[0].x, P.vertices[0].y); for (var L = 1; L < P.vertices.length; L++)!P.vertices[L - 1].isInternal || y ? v.lineTo(P.vertices[L].x, P.vertices[L].y) : v.moveTo(P.vertices[L].x, P.vertices[L].y), P.vertices[L].isInternal && !y && v.moveTo(P.vertices[(L + 1) % P.vertices.length].x, P.vertices[(L + 1) % P.vertices.length].y); v.lineTo(P.vertices[0].x, P.vertices[0].y), v.closePath() } M.wireframes ? (v.lineWidth = 1, v.strokeStyle = h.options.wireframeStrokeStyle, v.stroke()) : (v.fillStyle = P.render.fillStyle, P.render.lineWidth && (v.lineWidth = P.render.lineWidth, v.strokeStyle = P.render.strokeStyle, v.stroke()), v.fill()) } v.globalAlpha = 1 } } }, e.bodyWireframes = function (h, g, x) { var v = x, M = h.options.showInternalEdges, y, C, P, T, E; for (v.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (E = y.parts.length > 1 ? 1 : 0; E < y.parts.length; E++) { for (C = y.parts[E], v.moveTo(C.vertices[0].x, C.vertices[0].y), T = 1; T < C.vertices.length; T++)!C.vertices[T - 1].isInternal || M ? v.lineTo(C.vertices[T].x, C.vertices[T].y) : v.moveTo(C.vertices[T].x, C.vertices[T].y), C.vertices[T].isInternal && !M && v.moveTo(C.vertices[(T + 1) % C.vertices.length].x, C.vertices[(T + 1) % C.vertices.length].y); v.lineTo(C.vertices[0].x, C.vertices[0].y) } v.lineWidth = 1, v.strokeStyle = h.options.wireframeStrokeStyle, v.stroke() }, e.bodyConvexHulls = function (h, g, x) { var v = x, M, y, C; for (v.beginPath(), y = 0; y < g.length; y++)if (M = g[y], !(!M.render.visible || M.parts.length === 1)) { for (v.moveTo(M.vertices[0].x, M.vertices[0].y), C = 1; C < M.vertices.length; C++)v.lineTo(M.vertices[C].x, M.vertices[C].y); v.lineTo(M.vertices[0].x, M.vertices[0].y) } v.lineWidth = 1, v.strokeStyle = "rgba(255,255,255,0.2)", v.stroke() }, e.vertexNumbers = function (h, g, x) { var v = x, M, y, C; for (M = 0; M < g.length; M++) { var P = g[M].parts; for (C = P.length > 1 ? 1 : 0; C < P.length; C++) { var T = P[C]; for (y = 0; y < T.vertices.length; y++)v.fillStyle = "rgba(255,255,255,0.2)", v.fillText(M + "_" + y, T.position.x + (T.vertices[y].x - T.position.x) * .8, T.position.y + (T.vertices[y].y - T.position.y) * .8) } } }, e.mousePosition = function (h, g, x) { var v = x; v.fillStyle = "rgba(255,255,255,0.8)", v.fillText(g.position.x + "  " + g.position.y, g.position.x + 5, g.position.y - 5) }, e.bodyBounds = function (h, g, x) { var v = x; h.engine; var M = h.options; v.beginPath(); for (var y = 0; y < g.length; y++) { var C = g[y]; if (C.render.visible) for (var P = g[y].parts, T = P.length > 1 ? 1 : 0; T < P.length; T++) { var E = P[T]; v.rect(E.bounds.min.x, E.bounds.min.y, E.bounds.max.x - E.bounds.min.x, E.bounds.max.y - E.bounds.min.y) } } M.wireframes ? v.strokeStyle = "rgba(255,255,255,0.08)" : v.strokeStyle = "rgba(0,0,0,0.1)", v.lineWidth = 1, v.stroke() }, e.bodyAxes = function (h, g, x) { var v = x; h.engine; var M = h.options, y, C, P, T; for (v.beginPath(), C = 0; C < g.length; C++) { var E = g[C], I = E.parts; if (E.render.visible) if (M.showAxes) for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (y = I[P], T = 0; T < y.axes.length; T++) { var B = y.axes[T]; v.moveTo(y.position.x, y.position.y), v.lineTo(y.position.x + B.x * 20, y.position.y + B.y * 20) } else for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (y = I[P], T = 0; T < y.axes.length; T++)v.moveTo(y.position.x, y.position.y), v.lineTo((y.vertices[0].x + y.vertices[y.vertices.length - 1].x) / 2, (y.vertices[0].y + y.vertices[y.vertices.length - 1].y) / 2) } M.wireframes ? (v.strokeStyle = "indianred", v.lineWidth = 1) : (v.strokeStyle = "rgba(255, 255, 255, 0.4)", v.globalCompositeOperation = "overlay", v.lineWidth = 2), v.stroke(), v.globalCompositeOperation = "source-over" }, e.bodyPositions = function (h, g, x) { var v = x; h.engine; var M = h.options, y, C, P, T; for (v.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (T = 0; T < y.parts.length; T++)C = y.parts[T], v.arc(C.position.x, C.position.y, 3, 0, 2 * Math.PI, !1), v.closePath(); for (M.wireframes ? v.fillStyle = "indianred" : v.fillStyle = "rgba(0,0,0,0.5)", v.fill(), v.beginPath(), P = 0; P < g.length; P++)y = g[P], y.render.visible && (v.arc(y.positionPrev.x, y.positionPrev.y, 2, 0, 2 * Math.PI, !1), v.closePath()); v.fillStyle = "rgba(255,165,0,0.8)", v.fill() }, e.bodyVelocity = function (h, g, x) { var v = x; v.beginPath(); for (var M = 0; M < g.length; M++) { var y = g[M]; if (y.render.visible) { var C = l.getVelocity(y); v.moveTo(y.position.x, y.position.y), v.lineTo(y.position.x + C.x, y.position.y + C.y) } } v.lineWidth = 3, v.strokeStyle = "cornflowerblue", v.stroke() }, e.bodyIds = function (h, g, x) { var v = x, M, y; for (M = 0; M < g.length; M++)if (g[M].render.visible) { var C = g[M].parts; for (y = C.length > 1 ? 1 : 0; y < C.length; y++) { var P = C[y]; v.font = "12px Arial", v.fillStyle = "rgba(255,255,255,0.5)", v.fillText(P.id, P.position.x + 10, P.position.y - 10) } } }, e.collisions = function (h, g, x) { var v = x, M = h.options, y, C, P, T; for (v.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive) for (C = y.collision, T = 0; T < y.contactCount; T++) { var E = y.contacts[T], I = E.vertex; v.rect(I.x - 1.5, I.y - 1.5, 3.5, 3.5) } for (M.wireframes ? v.fillStyle = "rgba(255,255,255,0.7)" : v.fillStyle = "orange", v.fill(), v.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive && (C = y.collision, y.contactCount > 0)) { var B = y.contacts[0].vertex.x, L = y.contacts[0].vertex.y; y.contactCount === 2 && (B = (y.contacts[0].vertex.x + y.contacts[1].vertex.x) / 2, L = (y.contacts[0].vertex.y + y.contacts[1].vertex.y) / 2), C.bodyB === C.supports[0].body || C.bodyA.isStatic === !0 ? v.moveTo(B - C.normal.x * 8, L - C.normal.y * 8) : v.moveTo(B + C.normal.x * 8, L + C.normal.y * 8), v.lineTo(B, L) } M.wireframes ? v.strokeStyle = "rgba(255,165,0,0.7)" : v.strokeStyle = "orange", v.lineWidth = 1, v.stroke() }, e.separations = function (h, g, x) { var v = x, M = h.options, y, C, P, T, E; for (v.beginPath(), E = 0; E < g.length; E++)if (y = g[E], !!y.isActive) { C = y.collision, P = C.bodyA, T = C.bodyB; var I = 1; !T.isStatic && !P.isStatic && (I = .5), T.isStatic && (I = 0), v.moveTo(T.position.x, T.position.y), v.lineTo(T.position.x - C.penetration.x * I, T.position.y - C.penetration.y * I), I = 1, !T.isStatic && !P.isStatic && (I = .5), P.isStatic && (I = 0), v.moveTo(P.position.x, P.position.y), v.lineTo(P.position.x + C.penetration.x * I, P.position.y + C.penetration.y * I) } M.wireframes ? v.strokeStyle = "rgba(255,165,0,0.5)" : v.strokeStyle = "orange", v.stroke() }, e.inspector = function (h, g) { h.engine; var x = h.selected, v = h.render, M = v.options, y; if (M.hasBounds) { var C = v.bounds.max.x - v.bounds.min.x, P = v.bounds.max.y - v.bounds.min.y, T = C / v.options.width, E = P / v.options.height; g.scale(1 / T, 1 / E), g.translate(-v.bounds.min.x, -v.bounds.min.y) } for (var I = 0; I < x.length; I++) { var B = x[I].data; switch (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.9)", g.setLineDash([1, 2]), B.type) { case "body": y = B.bounds, g.beginPath(), g.rect(Math.floor(y.min.x - 3), Math.floor(y.min.y - 3), Math.floor(y.max.x - y.min.x + 6), Math.floor(y.max.y - y.min.y + 6)), g.closePath(), g.stroke(); break; case "constraint": var L = B.pointA; B.bodyA && (L = B.pointB), g.beginPath(), g.arc(L.x, L.y, 10, 0, 2 * Math.PI), g.closePath(), g.stroke(); break }g.setLineDash([]), g.translate(-.5, -.5) } h.selectStart !== null && (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.6)", g.fillStyle = "rgba(255,165,0,0.1)", y = h.selectBounds, g.beginPath(), g.rect(Math.floor(y.min.x), Math.floor(y.min.y), Math.floor(y.max.x - y.min.x), Math.floor(y.max.y - y.min.y)), g.closePath(), g.stroke(), g.fill(), g.translate(-.5, -.5)), M.hasBounds && g.setTransform(1, 0, 0, 1, 0, 0) }; var n = function (h, g) { var x = h.engine, v = h.timing, M = v.historySize, y = x.timing.timestamp; v.delta = g - v.lastTime || e._goodDelta, v.lastTime = g, v.timestampElapsed = y - v.lastTimestamp || 0, v.lastTimestamp = y, v.deltaHistory.unshift(v.delta), v.deltaHistory.length = Math.min(v.deltaHistory.length, M), v.engineDeltaHistory.unshift(x.timing.lastDelta), v.engineDeltaHistory.length = Math.min(v.engineDeltaHistory.length, M), v.timestampElapsedHistory.unshift(v.timestampElapsed), v.timestampElapsedHistory.length = Math.min(v.timestampElapsedHistory.length, M), v.engineUpdatesHistory.unshift(x.timing.lastUpdatesPerFrame), v.engineUpdatesHistory.length = Math.min(v.engineUpdatesHistory.length, M), v.engineElapsedHistory.unshift(x.timing.lastElapsed), v.engineElapsedHistory.length = Math.min(v.engineElapsedHistory.length, M), v.elapsedHistory.unshift(v.lastElapsed), v.elapsedHistory.length = Math.min(v.elapsedHistory.length, M) }, c = function (h) { for (var g = 0, x = 0; x < h.length; x += 1)g += h[x]; return g / h.length || 0 }, d = function (h, g) { var x = document.createElement("canvas"); return x.width = h, x.height = g, x.oncontextmenu = function () { return !1 }, x.onselectstart = function () { return !1 }, x }, m = function (h) { var g = h.getContext("2d"), x = window.devicePixelRatio || 1, v = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1; return x / v }, S = function (h, g) { var x = h.textures[g]; return x || (x = h.textures[g] = new Image, x.src = g, x) }, D = function (h, g) { var x = g; /(jpg|gif|png)$/.test(g) && (x = "url(" + g + ")"), h.canvas.style.background = x, h.canvas.style.backgroundSize = "contain", h.currentBackground = g } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(5), a = p(17), r = p(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (i) { var u = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, o = r.extend(u, i); return o.fps = 0, o }, e.run = function (i, u) { return i.timeBuffer = e._frameDeltaFallback, function o(t) { i.frameRequestId = e._onNextFrame(i, o), t && i.enabled && e.tick(i, u, t) }(), i }, e.tick = function (i, u, o) { var t = r.now(), s = i.delta, n = 0, c = o - i.timeLastTick; if ((!c || !i.timeLastTick || c > Math.max(e._maxFrameDelta, i.maxFrameTime)) && (c = i.frameDelta || e._frameDeltaFallback), i.frameDeltaSmoothing) { i.frameDeltaHistory.push(c), i.frameDeltaHistory = i.frameDeltaHistory.slice(-i.frameDeltaHistorySize); var d = i.frameDeltaHistory.slice(0).sort(), m = i.frameDeltaHistory.slice(d.length * e._smoothingLowerBound, d.length * e._smoothingUpperBound), S = f(m); c = S || c } i.frameDeltaSnapping && (c = 1e3 / Math.round(1e3 / c)), i.frameDelta = c, i.timeLastTick = o, i.timeBuffer += i.frameDelta, i.timeBuffer = r.clamp(i.timeBuffer, 0, i.frameDelta + s * e._timeBufferMargin), i.lastUpdatesDeferred = 0; var D = i.maxUpdates || Math.ceil(i.maxFrameTime / s), h = { timestamp: u.timing.timestamp }; l.trigger(i, "beforeTick", h), l.trigger(i, "tick", h); for (var g = r.now(); s > 0 && i.timeBuffer >= s * e._timeBufferMargin;) { l.trigger(i, "beforeUpdate", h), a.update(u, s), l.trigger(i, "afterUpdate", h), i.timeBuffer -= s, n += 1; var x = r.now() - t, v = r.now() - g, M = x + e._elapsedNextEstimate * v / n; if (n >= D || M > i.maxFrameTime) { i.lastUpdatesDeferred = Math.round(Math.max(0, i.timeBuffer / s - e._timeBufferMargin)); break } } u.timing.lastUpdatesPerFrame = n, l.trigger(i, "afterTick", h), i.frameDeltaHistory.length >= 100 && (i.lastUpdatesDeferred && Math.round(i.frameDelta / s) > D ? r.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : i.lastUpdatesDeferred && r.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof i.isFixed < "u" && r.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (i.deltaMin || i.deltaMax) && r.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), i.fps !== 0 && r.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (i) { e._cancelNextFrame(i) }, e._onNextFrame = function (i, u) { if (typeof window < "u" && window.requestAnimationFrame) i.frameRequestId = window.requestAnimationFrame(u); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return i.frameRequestId }, e._cancelNextFrame = function (i) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(i.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var f = function (i) { for (var u = 0, o = i.length, t = 0; t < o; t += 1)u += i[t]; return u / o || 0 } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(8), a = p(0), r = a.deprecated; (function () { e.collides = function (f, i) { return l.collides(f, i) }, r(e, "collides", "SAT.collides ➤ replaced by Collision.collides") })() }, function (w, O, p) { var e = {}; w.exports = e, p(1); var l = p(0); (function () { e.pathToVertices = function (a, r) { typeof window < "u" && !("SVGPathSeg" in window) && l.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var f, i, u, o, t, s, n, c, d, m, S = [], D, h, g = 0, x = 0, v = 0; r = r || 15; var M = function (C, P, T) { var E = T % 2 === 1 && T > 1; if (!d || C != d.x || P != d.y) { d && E ? (D = d.x, h = d.y) : (D = 0, h = 0); var I = { x: D + C, y: h + P }; (E || !d) && (d = I), S.push(I), x = D + C, v = h + P } }, y = function (C) { var P = C.pathSegTypeAsLetter.toUpperCase(); if (P !== "Z") { switch (P) { case "M": case "L": case "T": case "C": case "S": case "Q": x = C.x, v = C.y; break; case "H": x = C.x; break; case "V": v = C.y; break }M(x, v, C.pathSegType) } }; for (e._svgPathToAbsolute(a), u = a.getTotalLength(), s = [], f = 0; f < a.pathSegList.numberOfItems; f += 1)s.push(a.pathSegList.getItem(f)); for (n = s.concat(); g < u;) { if (m = a.getPathSegAtLength(g), t = s[m], t != c) { for (; n.length && n[0] != t;)y(n.shift()); c = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": o = a.getPointAtLength(g), M(o.x, o.y, 0); break }g += r } for (f = 0, i = n.length; f < i; ++f)y(n[f]); return S }, e._svgPathToAbsolute = function (a) { for (var r, f, i, u, o, t, s = a.pathSegList, n = 0, c = 0, d = s.numberOfItems, m = 0; m < d; ++m) { var S = s.getItem(m), D = S.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(D)) "x" in S && (n = S.x), "y" in S && (c = S.y); else switch ("x1" in S && (i = n + S.x1), "x2" in S && (o = n + S.x2), "y1" in S && (u = c + S.y1), "y2" in S && (t = c + S.y2), "x" in S && (n += S.x), "y" in S && (c += S.y), D) { case "m": s.replaceItem(a.createSVGPathSegMovetoAbs(n, c), m); break; case "l": s.replaceItem(a.createSVGPathSegLinetoAbs(n, c), m); break; case "h": s.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(n), m); break; case "v": s.replaceItem(a.createSVGPathSegLinetoVerticalAbs(c), m); break; case "c": s.replaceItem(a.createSVGPathSegCurvetoCubicAbs(n, c, i, u, o, t), m); break; case "s": s.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(n, c, o, t), m); break; case "q": s.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(n, c, i, u), m); break; case "t": s.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(n, c), m); break; case "a": s.replaceItem(a.createSVGPathSegArcAbs(n, c, S.r1, S.r2, S.angle, S.largeArcFlag, S.sweepFlag), m); break; case "z": case "Z": n = r, c = f; break }(D == "M" || D == "m") && (r = n, f = c) } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(6); p(0), function () { e.create = l.create, e.add = l.add, e.remove = l.remove, e.clear = l.clear, e.addComposite = l.addComposite, e.addBody = l.addBody, e.addConstraint = l.addConstraint }() }]) }) })(Mt); const j = st(te); class wt { constructor(A) { R(this, "widthCanvas", document.body.clientWidth); R(this, "heightCanvas"); R(this, "DOM"); R(this, "dataImgs", []); R(this, "MatterJS"); R(this, "sizeCustom"); this.DOM = { el: A }, this.MatterJS = { Engine: void 0, Render: void 0 }, this.sizeCustom = { mobile: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 171 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(17) }, tablet: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 190 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(19) }, desktop: { radius: N(13.3), scaleRatio: N(13.3) / 133, scaleCircleMain: 293 / 133, xLeftWall: 0, xRightWall: window.innerWidth, yMainCircle: N(51.2) + N(29.3) } }, this.heightCanvas = this.DOM.el.clientHeight, A == null || A.querySelectorAll(".home-bubble-item").forEach(w => { var p; const O = (p = w.querySelector("img")) == null ? void 0 : p.getAttribute("src"); O && this.dataImgs.push(O), w.style.pointerEvents = "none", w.style.opacity = "0" }) } render() { var p, e, l, a; this.init(); const A = j.Runner.create(), w = (e = (p = this.MatterJS).Engine) == null ? void 0 : e.call(p), O = (a = (l = this.MatterJS).Render) == null ? void 0 : a.call(l); le.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !w || !O || (j.Render.run(O), j.Runner.run(A, w)) } }) } init() { const A = this.sizeCustom[se].radius, w = this.sizeCustom[se].scaleRatio, O = this.sizeCustom[se].scaleCircleMain, p = this.sizeCustom[se].xLeftWall, e = this.sizeCustom[se].xRightWall, l = this.sizeCustom[se].yMainCircle, a = j.Engine.create(), r = j.Render.create({ element: this.DOM.el, engine: a, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), f = Math.floor(window.innerWidth / (A * 2)), u = (window.innerWidth - f * A * 2) / (f - 1); let o = 0; for (let S = 0; S < Math.round(this.dataImgs.length / f) && this.dataImgs[o]; S++) { for (let D = 0; D < f && this.dataImgs[o]; D++) { const h = D * A * 2 + u * D, g = -S * A * 2 - A * 2 - u * S, x = te.Bodies.circle(h, g, A, { friction: .001, frictionAir: .01, restitution: .8, timeScale: 1.05, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[o], xScale: w, yScale: w } } }); if (o++, j.Composite.add(a.world, x), o >= this.dataImgs.length) break } if (o >= this.dataImgs.length) break } const t = te.Bodies.circle(this.DOM.el.clientWidth / 2, l, A * O, { render: { fillStyle: "transparent" }, isStatic: !0 }), s = te.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight, this.DOM.el.clientWidth * 10, 1, { isStatic: !0, render: { fillStyle: "transparent" } }), n = te.Bodies.rectangle(p, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }), c = te.Bodies.rectangle(e, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }); j.Composite.add(a.world, [s, n, c, t]); const d = j.Mouse.create(r.canvas), m = j.MouseConstraint.create(a, { mouse: d, constraint: { stiffness: .2, render: { visible: !1 } } }); j.Composite.add(a.world, m), m.mouse.element.removeEventListener("touchstart", m.mouse.mousedown), m.mouse.element.removeEventListener("touchmove", m.mouse.mousemove), m.mouse.element.removeEventListener("touchend", m.mouse.mouseup), m.mouse.element.addEventListener("touchstart", m.mouse.mousedown, { passive: !0 }), m.mouse.element.addEventListener("touchmove", S => { m.body && m.mouse.mousemove(S) }), m.mouse.element.addEventListener("touchend", S => { m.body && m.mouse.mouseup(S) }), this.MatterJS.Render = () => r, this.MatterJS.Engine = () => a } } class Ct { constructor(A) { R(this, "DOM"); this.DOM = { el: A }, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelectorAll(".lading-splide-wrap"), w = this.DOM.el.querySelector(".home-bubble"), O = this.DOM.el.querySelector(".home-book-img-inner"); A.length && A.forEach(p => { new Se({ wrap: p, listSplide: p.querySelectorAll(".home-hero-brands") }) }), new St(this.DOM.el), w && new wt(w).render(), O && new Ce({ el: O, offset: 30, direction: -1 }), this.heroVideoAction(), this.handleParallaxTitle(), this.initMotion() } clear() { this.initParticles() } initMotion() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el) } heroVideoAction() { const A = this.DOM.el.querySelector(".home-hero-img-btn"), w = this.DOM.el.querySelector(".home-hero-poup-video"), O = this.DOM.el.querySelector(".home-hero--poup-ic"), p = this.DOM.el.querySelector(".home-hero-poup-video-content"); A.addEventListener("click", () => { w.classList.add("is-show") }), O.addEventListener("click", () => e()), rt({ element: p, action: () => e() }); const e = () => { w.classList.remove("is-show") } } handleParallaxTitle() { const A = this.DOM.el.querySelector(".home-feature-top-inner"), w = this.DOM.el.querySelector(".home-bubble"); if (!A || !w) return; const O = H.fromTo(A, { y: A.clientHeight / 2 }, { y: `-${window.innerHeight / 2 - A.clientHeight / 2}px`, ease: "none", duration: 3 }); le.create({ trigger: w, start: () => "bottom bottom", end: "bottom top", animation: O, scrub: !0 }) } } class Pt { constructor(A) { R(this, "DOM"); R(this, "pricing"); R(this, "pricingBase"); R(this, "pricingAgent"); R(this, "planCurrent"); R(this, "planOptions", { month: { planUser: 35, basePrice: 75, valSaleUp: 0, type: "month" }, year: { planUser: 35, basePrice: 75, valSaleUp: 10, type: "year" } }); this.DOM = { el: A }, this.planCurrent = this.planOptions.month, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelector(".home-book-img-inner"); A && new Ce({ el: A, offset: 30, direction: -1 }), this.DOM.el.querySelectorAll(".home-book-brands"); const w = this.DOM.el.querySelectorAll(".pricing-testimonials-brands"); w.length && w.forEach(O => { new Se({ wrap: O, listSplide: this.DOM.el.querySelectorAll(".pricing-testimonials-brands") }) }), new Se({ wrap: this.DOM.el.querySelector(".book-brands-wrap"), listSplide: this.DOM.el.querySelectorAll(".home-hero-brands") }), this.initMotions(), this.handleInitPricing() } initMotions() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.fadeWrap(this.DOM.el) } handleSelectTypePlan() { const A = this.DOM.el.querySelector(".pricing-hero-bg-wrap"), w = this.DOM.el.querySelector(".pricing-hero-bg"), O = this.DOM.el.querySelectorAll(".js-text-timer"); A && this.DOM.el.querySelectorAll(".pricing-hero-tab-item").forEach(p => { p.addEventListener("click", () => { var t, s, n, c, d; const e = p.getAttribute("data-plan-pricing"); if (!this.pricing || e === ((t = this.planCurrent) == null ? void 0 : t.type)) return; const l = A.getBoundingClientRect().x, a = p.getBoundingClientRect().x, r = p.getBoundingClientRect().width, f = this.planOptions[e]; this.planCurrent = f, O.forEach((m, S, D) => { const h = m.querySelectorAll(".txt .txt-18"); e === "month" ? H.to(h, { y: 0, ease: "power3", duration: 1.2, delay: S * .3 + 1 }) : H.fromTo(h, { y: "0%" }, { y: "-100%", ease: "power3", duration: 1.2, delay: (D.length - S) * .3 + 1 }) }); const i = e === "year", u = (i ? 12 * (100 - f.valSaleUp) / 100 : 1) * f.planUser, o = (i ? 12 * (100 - f.valSaleUp) / 100 : 1) * f.basePrice; !this.pricingAgent || !this.pricingBase || ((s = this.pricingAgent.textSplit) == null || s.revert(), (n = this.pricingBase.textSplit) == null || n.revert(), this.pricingBase.DOM.el.innerHTML = `${o}`, this.pricingAgent.DOM.el.innerHTML = `${u}`, this.pricingAgent.init(), this.pricingBase.init(), (c = this.pricingAgent) == null || c.animIn(), (d = this.pricingBase) == null || d.animIn(.1), H.to(w, { x: -(l - a), duration: .5, width: r, ease: "power3.out" }), this.pricing.handleCalcPricing({ ...f, isReinit: !0 })) }) }) } handleInitPricing() { var f; const A = (f = this.DOM.el.querySelector(".txt-168.txt-bold")) == null ? void 0 : f.querySelector(".js-text-counter"), w = this.DOM.el.querySelector(".text-pricing-agent"), O = this.DOM.el.querySelector(".text-pricing-base"), p = document.querySelector(".fs-rangeslider_input__custom"), e = !0, l = new pe(A, p, e), a = new pe(O, void 0, e), r = new pe(w, void 0, e); this.pricingAgent = r, this.pricingBase = a, this.pricing = l, this.handleSelectTypePlan(), this.handleActionPlanPricing() } handleActionPlanPricing() { setTimeout(() => { var A, w, O, p; this.pricing && this.pricing.handleSlide({ type: ((A = this.planCurrent) == null ? void 0 : A.type) || "month", planUser: ((w = this.planCurrent) == null ? void 0 : w.planUser) || 35, valSaleUp: ((O = this.planCurrent) == null ? void 0 : O.valSaleUp) || 0, basePrice: ((p = this.planCurrent) == null ? void 0 : p.basePrice) || 75 }) }, 1e3) } clear() { this.initParticles() } } H.registerPlugin(le); class Dt { constructor() { this.init(), this.bindEvents() } init() { const w = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", w), w) return; const O = document.querySelector("div[data-page]"); if (!O) return; const p = O.getAttribute("data-page") || "home", e = { home: () => { new Ct(O) }, about: () => { new yt(O) }, pricing: () => { new Pt(O) } }; e[p] && e[p](), Ve.init(), Q.init(), new gt, new dt } bindEvents() { U.on(at, this.init.bind(this)), ke.simple(), ke.simpleLoaded() } } new Dt;
