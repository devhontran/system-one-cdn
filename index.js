var st = Object.defineProperty; var rt = (T, A, w) => A in T ? st(T, A, { enumerable: !0, configurable: !0, writable: !0, value: w }) : T[A] = w; var V = (T, A, w) => (rt(T, typeof A != "symbol" ? A + "" : A, w), w); import { g as Q, l as Ve, M as Se, c as re, b as me, d as at, S as We, e as ot, f as lt, w as ft, G as ct, a as ut } from "./global.js"; const ht = "_parallax_1rmcj_1", pt = "_wrapper_1rmcj_5", dt = "_inner_1rmcj_11", xe = { parallax: ht, wrapper: pt, inner: dt }; class $e { constructor({ el: A, offset: w, scale: O, direction: p, ...e }) { V(this, "DOM"); V(this, "offset"); V(this, "scale"); V(this, "direction"); V(this, "options"); this.DOM = { el: A }, this.offset = w || 0, this.scale = O || 1.1, this.direction = p || -1, this.options = e, this.init(), this.play() } init() { const A = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const w = document.createElement("div"); w.style.scale = `${this.scale}`, w.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, w.classList.add(xe.inner), A.classList.add(xe.parallax), this.DOM.el.classList.add(xe.wrapper), w.appendChild(A), this.DOM.el.appendChild(w), this.DOM.elInner = this.DOM.el } play() { if (!this.DOM.elInner) return; const A = 100 + this.offset * 2, w = this.offset * A / 100 * this.direction, O = { trigger: this.DOM.el, start: "top bottom", end: "bottom top", scrub: 1 }; Q.timeline({ scrollTrigger: O }).to(this.DOM.elInner, { y: `${w}%` }) } } class vt { constructor() { V(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.hander(), this.movingImageFooter() } hander() { var w; const A = (w = this.DOM.el) == null ? void 0 : w.querySelector(".footer-bottom-inner-back"); A == null || A.addEventListener("click", () => { Ve.lenis.scrollTo("top", { lock: !0, duration: 1.2 }) }) } movingImageFooter() { var l, o, r; const A = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-img"), w = (o = this.DOM.el) == null ? void 0 : o.querySelector(".footer-middle-inner-img"), O = (r = this.DOM.el) == null ? void 0 : r.querySelector(".footer-middle-list-imgs"), p = Q.quickTo(w, "x", { duration: .9, ease: "power3.out" }), e = h => { var c; const n = (c = this.DOM.el) == null ? void 0 : c.querySelectorAll(".footer-middle-list-imgs-item"); n == null || n.forEach((a, t) => { t === h ? Q.to(a, { opacity: 1, ease: "power3.out", duration: .6 }) : Q.to(a, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; new $e({ el: O, offset: 25, direction: 1, scale: 1.3 }), e(1), w.style.willChange = "transform", A == null || A.addEventListener("mousemove", h => { const n = h.pageX, c = Se(n, 0, window.innerWidth, -1, 1), a = Math.floor(Se(n, 0, window.innerWidth, 0, 3)), t = (A.clientWidth - w.clientWidth) / 2; p(c * t), e(a), console.log("idMap", a) }), A == null || A.addEventListener("mouseleave", () => { p(0), e(1) }) } } class gt { constructor() { V(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show() } show() { let A = 0; window.addEventListener("scroll", () => { var r; if (!this.DOM.el) return; const w = window.pageYOffset || document.documentElement.scrollTop || 0, O = ((r = this.DOM.footer) == null ? void 0 : r.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, p = w > this.DOM.el.clientHeight, l = A < w || O, o = A > w && !O; l ? this.DOM.el.classList.add("hidden") : o && (this.DOM.el.classList.remove("hidden"), this.DOM.el.classList.toggle("scrollDown", p)), A = w }) } } class mt { constructor() { const A = document.querySelectorAll(".card-1"); console.log("zca", A) } } class xt { constructor() { V(this, "DOM"); this.DOM = { wrapper: document.querySelector(".home-feature-cards"), listCards: document.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((A, w, O) => { const p = O[0].clientHeight, e = (window.innerHeight - p) / 2, l = O.length * re(8), o = Se(w, 0, O.length - 1, .8125, 1); A.style.top = `${e + l}px`, A.style.transform = `translateY(-${(O.length - w) * re(8)}px)`, Q.timeline({ scrollTrigger: { trigger: A, start: () => "top center", end: `+=${(O.length - w) * p} `, scrub: 1 } }).to(A, { scale: o, transformOrigin: "top center", ease: "none" }, 0) }) } } var ee = {}, yt = { get exports() { return ee }, set exports(T) { ee = T } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (T, A) { (function (O, p) { T.exports = p() })(me, function () { return function (w) { var O = {}; function p(e) { if (O[e]) return O[e].exports; var l = O[e] = { i: e, l: !1, exports: {} }; return w[e].call(l.exports, l, l.exports, p), l.l = !0, l.exports } return p.m = w, p.c = O, p.d = function (e, l, o) { p.o(e, l) || Object.defineProperty(e, l, { enumerable: !0, get: o }) }, p.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, p.t = function (e, l) { if (l & 1 && (e = p(e)), l & 8 || l & 4 && typeof e == "object" && e && e.__esModule) return e; var o = Object.create(null); if (p.r(o), Object.defineProperty(o, "default", { enumerable: !0, value: e }), l & 2 && typeof e != "string") for (var r in e) p.d(o, r, function (h) { return e[h] }.bind(null, r)); return o }, p.n = function (e) { var l = e && e.__esModule ? function () { return e.default } : function () { return e }; return p.d(l, "a", l), l }, p.o = function (e, l) { return Object.prototype.hasOwnProperty.call(e, l) }, p.p = "", p(p.s = 20) }([function (w, O) { var p = {}; w.exports = p, function () { p._baseDelta = 1e3 / 60, p._nextId = 0, p._seed = 0, p._nowStartTime = +new Date, p._warnedOnce = {}, p._decomp = null, p.extend = function (l, o) { var r, h; typeof o == "boolean" ? (r = 2, h = o) : (r = 1, h = !0); for (var n = r; n < arguments.length; n++) { var c = arguments[n]; if (c) for (var a in c) h && c[a] && c[a].constructor === Object && (!l[a] || l[a].constructor === Object) ? (l[a] = l[a] || {}, p.extend(l[a], h, c[a])) : l[a] = c[a] } return l }, p.clone = function (l, o) { return p.extend({}, o, l) }, p.keys = function (l) { if (Object.keys) return Object.keys(l); var o = []; for (var r in l) o.push(r); return o }, p.values = function (l) { var o = []; if (Object.keys) { for (var r = Object.keys(l), h = 0; h < r.length; h++)o.push(l[r[h]]); return o } for (var n in l) o.push(l[n]); return o }, p.get = function (l, o, r, h) { o = o.split(".").slice(r, h); for (var n = 0; n < o.length; n += 1)l = l[o[n]]; return l }, p.set = function (l, o, r, h, n) { var c = o.split(".").slice(h, n); return p.get(l, o, 0, -1)[c[c.length - 1]] = r, r }, p.shuffle = function (l) { for (var o = l.length - 1; o > 0; o--) { var r = Math.floor(p.random() * (o + 1)), h = l[o]; l[o] = l[r], l[r] = h } return l }, p.choose = function (l) { return l[Math.floor(p.random() * l.length)] }, p.isElement = function (l) { return typeof HTMLElement < "u" ? l instanceof HTMLElement : !!(l && l.nodeType && l.nodeName) }, p.isArray = function (l) { return Object.prototype.toString.call(l) === "[object Array]" }, p.isFunction = function (l) { return typeof l == "function" }, p.isPlainObject = function (l) { return typeof l == "object" && l.constructor === Object }, p.isString = function (l) { return toString.call(l) === "[object String]" }, p.clamp = function (l, o, r) { return l < o ? o : l > r ? r : l }, p.sign = function (l) { return l < 0 ? -1 : 1 }, p.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - p._nowStartTime }, p.random = function (l, o) { return l = typeof l < "u" ? l : 0, o = typeof o < "u" ? o : 1, l + e() * (o - l) }; var e = function () { return p._seed = (p._seed * 9301 + 49297) % 233280, p._seed / 233280 }; p.colorToNumber = function (l) { return l = l.replace("#", ""), l.length == 3 && (l = l.charAt(0) + l.charAt(0) + l.charAt(1) + l.charAt(1) + l.charAt(2) + l.charAt(2)), parseInt(l, 16) }, p.logLevel = 1, p.log = function () { console && p.logLevel > 0 && p.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.info = function () { console && p.logLevel > 0 && p.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.warn = function () { console && p.logLevel > 0 && p.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, p.warnOnce = function () { var l = Array.prototype.slice.call(arguments).join(" "); p._warnedOnce[l] || (p.warn(l), p._warnedOnce[l] = !0) }, p.deprecated = function (l, o, r) { l[o] = p.chain(function () { p.warnOnce("🔅 deprecated 🔅", r) }, l[o]) }, p.nextId = function () { return p._nextId++ }, p.indexOf = function (l, o) { if (l.indexOf) return l.indexOf(o); for (var r = 0; r < l.length; r++)if (l[r] === o) return r; return -1 }, p.map = function (l, o) { if (l.map) return l.map(o); for (var r = [], h = 0; h < l.length; h += 1)r.push(o(l[h])); return r }, p.topologicalSort = function (l) { var o = [], r = [], h = []; for (var n in l) !r[n] && !h[n] && p._topologicalSort(n, r, h, l, o); return o }, p._topologicalSort = function (l, o, r, h, n) { var c = h[l] || []; r[l] = !0; for (var a = 0; a < c.length; a += 1) { var t = c[a]; r[t] || o[t] || p._topologicalSort(t, o, r, h, n) } r[l] = !1, o[l] = !0, n.push(l) }, p.chain = function () { for (var l = [], o = 0; o < arguments.length; o += 1) { var r = arguments[o]; r._chained ? l.push.apply(l, r._chained) : l.push(r) } var h = function () { for (var n, c = new Array(arguments.length), a = 0, t = arguments.length; a < t; a++)c[a] = arguments[a]; for (a = 0; a < l.length; a += 1) { var s = l[a].apply(n, c); typeof s < "u" && (n = s) } return n }; return h._chained = l, h }, p.chainPathBefore = function (l, o, r) { return p.set(l, o, p.chain(r, p.get(l, o))) }, p.chainPathAfter = function (l, o, r) { return p.set(l, o, p.chain(p.get(l, o), r)) }, p.setDecomp = function (l) { p._decomp = l }, p.getDecomp = function () { var l = p._decomp; try { !l && typeof window < "u" && (l = window.decomp), !l && typeof me < "u" && (l = me.decomp) } catch { l = null } return l } }() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e) { var l = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && p.update(l, e), l }, p.update = function (e, l, o) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var r = 0; r < l.length; r++) { var h = l[r]; h.x > e.max.x && (e.max.x = h.x), h.x < e.min.x && (e.min.x = h.x), h.y > e.max.y && (e.max.y = h.y), h.y < e.min.y && (e.min.y = h.y) } o && (o.x > 0 ? e.max.x += o.x : e.min.x += o.x, o.y > 0 ? e.max.y += o.y : e.min.y += o.y) }, p.contains = function (e, l) { return l.x >= e.min.x && l.x <= e.max.x && l.y >= e.min.y && l.y <= e.max.y }, p.overlaps = function (e, l) { return e.min.x <= l.max.x && e.max.x >= l.min.x && e.max.y >= l.min.y && e.min.y <= l.max.y }, p.translate = function (e, l) { e.min.x += l.x, e.max.x += l.x, e.min.y += l.y, e.max.y += l.y }, p.shift = function (e, l) { var o = e.max.x - e.min.x, r = e.max.y - e.min.y; e.min.x = l.x, e.max.x = l.x + o, e.min.y = l.y, e.max.y = l.y + r } }() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e, l) { return { x: e || 0, y: l || 0 } }, p.clone = function (e) { return { x: e.x, y: e.y } }, p.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, p.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, p.rotate = function (e, l, o) { var r = Math.cos(l), h = Math.sin(l); o || (o = {}); var n = e.x * r - e.y * h; return o.y = e.x * h + e.y * r, o.x = n, o }, p.rotateAbout = function (e, l, o, r) { var h = Math.cos(l), n = Math.sin(l); r || (r = {}); var c = o.x + ((e.x - o.x) * h - (e.y - o.y) * n); return r.y = o.y + ((e.x - o.x) * n + (e.y - o.y) * h), r.x = c, r }, p.normalise = function (e) { var l = p.magnitude(e); return l === 0 ? { x: 0, y: 0 } : { x: e.x / l, y: e.y / l } }, p.dot = function (e, l) { return e.x * l.x + e.y * l.y }, p.cross = function (e, l) { return e.x * l.y - e.y * l.x }, p.cross3 = function (e, l, o) { return (l.x - e.x) * (o.y - e.y) - (l.y - e.y) * (o.x - e.x) }, p.add = function (e, l, o) { return o || (o = {}), o.x = e.x + l.x, o.y = e.y + l.y, o }, p.sub = function (e, l, o) { return o || (o = {}), o.x = e.x - l.x, o.y = e.y - l.y, o }, p.mult = function (e, l) { return { x: e.x * l, y: e.y * l } }, p.div = function (e, l) { return { x: e.x / l, y: e.y / l } }, p.perp = function (e, l) { return l = l === !0 ? -1 : 1, { x: l * -e.y, y: l * e.x } }, p.neg = function (e) { return { x: -e.x, y: -e.y } }, p.angle = function (e, l) { return Math.atan2(l.y - e.y, l.x - e.x) }, p._temp = [p.create(), p.create(), p.create(), p.create(), p.create(), p.create()] }() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), o = p(0); (function () { e.create = function (r, h) { for (var n = [], c = 0; c < r.length; c++) { var a = r[c], t = { x: a.x, y: a.y, index: c, body: h, isInternal: !1 }; n.push(t) } return n }, e.fromPath = function (r, h) { var n = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, c = []; return r.replace(n, function (a, t, s) { c.push({ x: parseFloat(t), y: parseFloat(s) }) }), e.create(c, h) }, e.centre = function (r) { for (var h = e.area(r, !0), n = { x: 0, y: 0 }, c, a, t, s = 0; s < r.length; s++)t = (s + 1) % r.length, c = l.cross(r[s], r[t]), a = l.mult(l.add(r[s], r[t]), c), n = l.add(n, a); return l.div(n, 6 * h) }, e.mean = function (r) { for (var h = { x: 0, y: 0 }, n = 0; n < r.length; n++)h.x += r[n].x, h.y += r[n].y; return l.div(h, r.length) }, e.area = function (r, h) { for (var n = 0, c = r.length - 1, a = 0; a < r.length; a++)n += (r[c].x - r[a].x) * (r[c].y + r[a].y), c = a; return h ? n / 2 : Math.abs(n) / 2 }, e.inertia = function (r, h) { for (var n = 0, c = 0, a = r, t, s, i = 0; i < a.length; i++)s = (i + 1) % a.length, t = Math.abs(l.cross(a[s], a[i])), n += t * (l.dot(a[s], a[s]) + l.dot(a[s], a[i]) + l.dot(a[i], a[i])), c += t; return h / 6 * (n / c) }, e.translate = function (r, h, n) { n = typeof n < "u" ? n : 1; var c = r.length, a = h.x * n, t = h.y * n, s; for (s = 0; s < c; s++)r[s].x += a, r[s].y += t; return r }, e.rotate = function (r, h, n) { if (h !== 0) { var c = Math.cos(h), a = Math.sin(h), t = n.x, s = n.y, i = r.length, f, g, y, M; for (M = 0; M < i; M++)f = r[M], g = f.x - t, y = f.y - s, f.x = t + (g * c - y * a), f.y = s + (g * a + y * c); return r } }, e.contains = function (r, h) { for (var n = h.x, c = h.y, a = r.length, t = r[a - 1], s, i = 0; i < a; i++) { if (s = r[i], (n - t.x) * (s.y - t.y) + (c - t.y) * (t.x - s.x) > 0) return !1; t = s } return !0 }, e.scale = function (r, h, n, c) { if (h === 1 && n === 1) return r; c = c || e.centre(r); for (var a, t, s = 0; s < r.length; s++)a = r[s], t = l.sub(a, c), r[s].x = c.x + t.x * h, r[s].y = c.y + t.y * n; return r }, e.chamfer = function (r, h, n, c, a) { typeof h == "number" ? h = [h] : h = h || [8], n = typeof n < "u" ? n : -1, c = c || 2, a = a || 14; for (var t = [], s = 0; s < r.length; s++) { var i = r[s - 1 >= 0 ? s - 1 : r.length - 1], f = r[s], g = r[(s + 1) % r.length], y = h[s < h.length ? s : h.length - 1]; if (y === 0) { t.push(f); continue } var M = l.normalise({ x: f.y - i.y, y: i.x - f.x }), D = l.normalise({ x: g.y - f.y, y: f.x - g.x }), u = Math.sqrt(2 * Math.pow(y, 2)), v = l.mult(o.clone(M), y), m = l.normalise(l.mult(l.add(M, D), .5)), d = l.sub(f, l.mult(m, u)), S = n; n === -1 && (S = Math.pow(y, .32) * 1.75), S = o.clamp(S, c, a), S % 2 === 1 && (S += 1); for (var x = Math.acos(l.dot(M, D)), C = x / S, P = 0; P < S; P++)t.push(l.add(l.rotate(v, C * P), d)) } return t }, e.clockwiseSort = function (r) { var h = e.mean(r); return r.sort(function (n, c) { return l.angle(h, n) - l.angle(h, c) }), r }, e.isConvex = function (r) { var h = 0, n = r.length, c, a, t, s; if (n < 3) return null; for (c = 0; c < n; c++)if (a = (c + 1) % n, t = (c + 2) % n, s = (r[a].x - r[c].x) * (r[t].y - r[a].y), s -= (r[a].y - r[c].y) * (r[t].x - r[a].x), s < 0 ? h |= 1 : s > 0 && (h |= 2), h === 3) return !1; return h !== 0 ? !0 : null }, e.hull = function (r) { var h = [], n = [], c, a; for (r = r.slice(0), r.sort(function (t, s) { var i = t.x - s.x; return i !== 0 ? i : t.y - s.y }), a = 0; a < r.length; a += 1) { for (c = r[a]; n.length >= 2 && l.cross3(n[n.length - 2], n[n.length - 1], c) <= 0;)n.pop(); n.push(c) } for (a = r.length - 1; a >= 0; a -= 1) { for (c = r[a]; h.length >= 2 && l.cross3(h[h.length - 2], h[h.length - 1], c) <= 0;)h.pop(); h.push(c) } return h.pop(), n.pop(), h.concat(n) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(2), r = p(7), h = p(0), n = p(1), c = p(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var s = { id: h.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: l.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, i = h.extend(s, t); return a(i, t), i }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var a = function (t, s) { s = s || {}, e.set(t, { bounds: t.bounds || n.create(t.vertices), positionPrev: t.positionPrev || o.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), l.rotate(t.vertices, t.angle, t.position), c.rotate(t.axes, t.angle), n.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: s.axes || t.axes, area: s.area || t.area, mass: s.mass || t.mass, inertia: s.inertia || t.inertia }); var i = t.isStatic ? "#14151f" : h.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), f = t.isStatic ? "#555" : "#ccc", g = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || i, t.render.strokeStyle = t.render.strokeStyle || f, t.render.lineWidth = t.render.lineWidth || g, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, s, i) { var f; typeof s == "string" && (f = s, s = {}, s[f] = i); for (f in s) if (Object.prototype.hasOwnProperty.call(s, f)) switch (i = s[f], f) { case "isStatic": e.setStatic(t, i); break; case "isSleeping": r.set(t, i); break; case "mass": e.setMass(t, i); break; case "density": e.setDensity(t, i); break; case "inertia": e.setInertia(t, i); break; case "vertices": e.setVertices(t, i); break; case "position": e.setPosition(t, i); break; case "angle": e.setAngle(t, i); break; case "velocity": e.setVelocity(t, i); break; case "angularVelocity": e.setAngularVelocity(t, i); break; case "speed": e.setSpeed(t, i); break; case "angularSpeed": e.setAngularSpeed(t, i); break; case "parts": e.setParts(t, i); break; case "centre": e.setCentre(t, i); break; default: t[f] = i } }, e.setStatic = function (t, s) { for (var i = 0; i < t.parts.length; i++) { var f = t.parts[i]; s ? (f.isStatic || (f._original = { restitution: f.restitution, friction: f.friction, mass: f.mass, inertia: f.inertia, density: f.density, inverseMass: f.inverseMass, inverseInertia: f.inverseInertia }), f.restitution = 0, f.friction = 1, f.mass = f.inertia = f.density = 1 / 0, f.inverseMass = f.inverseInertia = 0, f.positionPrev.x = f.position.x, f.positionPrev.y = f.position.y, f.anglePrev = f.angle, f.angularVelocity = 0, f.speed = 0, f.angularSpeed = 0, f.motion = 0) : f._original && (f.restitution = f._original.restitution, f.friction = f._original.friction, f.mass = f._original.mass, f.inertia = f._original.inertia, f.density = f._original.density, f.inverseMass = f._original.inverseMass, f.inverseInertia = f._original.inverseInertia, f._original = null), f.isStatic = s } }, e.setMass = function (t, s) { var i = t.inertia / (t.mass / 6); t.inertia = i * (s / 6), t.inverseInertia = 1 / t.inertia, t.mass = s, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, s) { e.setMass(t, s * t.area), t.density = s }, e.setInertia = function (t, s) { t.inertia = s, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, s) { s[0].body === t ? t.vertices = s : t.vertices = l.create(s, t), t.axes = c.fromVertices(t.vertices), t.area = l.area(t.vertices), e.setMass(t, t.density * t.area); var i = l.centre(t.vertices); l.translate(t.vertices, i, -1), e.setInertia(t, e._inertiaScale * l.inertia(t.vertices, t.mass)), l.translate(t.vertices, t.position), n.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, s, i) { var f; for (s = s.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, f = 0; f < s.length; f++) { var g = s[f]; g !== t && (g.parent = t, t.parts.push(g)) } if (t.parts.length !== 1) { if (i = typeof i < "u" ? i : !0, i) { var y = []; for (f = 0; f < s.length; f++)y = y.concat(s[f].vertices); l.clockwiseSort(y); var M = l.hull(y), D = l.centre(M); e.setVertices(t, M), l.translate(t.vertices, D) } var u = e._totalProperties(t); t.area = u.area, t.parent = t, t.position.x = u.centre.x, t.position.y = u.centre.y, t.positionPrev.x = u.centre.x, t.positionPrev.y = u.centre.y, e.setMass(t, u.mass), e.setInertia(t, u.inertia), e.setPosition(t, u.centre) } }, e.setCentre = function (t, s, i) { i ? (t.positionPrev.x += s.x, t.positionPrev.y += s.y, t.position.x += s.x, t.position.y += s.y) : (t.positionPrev.x = s.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = s.y - (t.position.y - t.positionPrev.y), t.position.x = s.x, t.position.y = s.y) }, e.setPosition = function (t, s, i) { var f = o.sub(s, t.position); i ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = f.x, t.velocity.y = f.y, t.speed = o.magnitude(f)) : (t.positionPrev.x += f.x, t.positionPrev.y += f.y); for (var g = 0; g < t.parts.length; g++) { var y = t.parts[g]; y.position.x += f.x, y.position.y += f.y, l.translate(y.vertices, f), n.update(y.bounds, y.vertices, t.velocity) } }, e.setAngle = function (t, s, i) { var f = s - t.angle; i ? (t.anglePrev = t.angle, t.angularVelocity = f, t.angularSpeed = Math.abs(f)) : t.anglePrev += f; for (var g = 0; g < t.parts.length; g++) { var y = t.parts[g]; y.angle += f, l.rotate(y.vertices, f, t.position), c.rotate(y.axes, f), n.update(y.bounds, y.vertices, t.velocity), g > 0 && o.rotateAbout(y.position, f, t.position, y.position) } }, e.setVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - s.x * i, t.positionPrev.y = t.position.y - s.y * i, t.velocity.x = (t.position.x - t.positionPrev.x) / i, t.velocity.y = (t.position.y - t.positionPrev.y) / i, t.speed = o.magnitude(t.velocity) }, e.getVelocity = function (t) { var s = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * s, y: (t.position.y - t.positionPrev.y) * s } }, e.getSpeed = function (t) { return o.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, s) { e.setVelocity(t, o.mult(o.normalise(e.getVelocity(t)), s)) }, e.setAngularVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - s * i, t.angularVelocity = (t.angle - t.anglePrev) / i, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, s) { e.setAngularVelocity(t, h.sign(e.getAngularVelocity(t)) * s) }, e.translate = function (t, s, i) { e.setPosition(t, o.add(t.position, s), i) }, e.rotate = function (t, s, i, f) { if (!i) e.setAngle(t, t.angle + s, f); else { var g = Math.cos(s), y = Math.sin(s), M = t.position.x - i.x, D = t.position.y - i.y; e.setPosition(t, { x: i.x + (M * g - D * y), y: i.y + (M * y + D * g) }, f), e.setAngle(t, t.angle + s, f) } }, e.scale = function (t, s, i, f) { var g = 0, y = 0; f = f || t.position; for (var M = 0; M < t.parts.length; M++) { var D = t.parts[M]; l.scale(D.vertices, s, i, f), D.axes = c.fromVertices(D.vertices), D.area = l.area(D.vertices), e.setMass(D, t.density * D.area), l.translate(D.vertices, { x: -D.position.x, y: -D.position.y }), e.setInertia(D, e._inertiaScale * l.inertia(D.vertices, D.mass)), l.translate(D.vertices, { x: D.position.x, y: D.position.y }), M > 0 && (g += D.area, y += D.inertia), D.position.x = f.x + (D.position.x - f.x) * s, D.position.y = f.y + (D.position.y - f.y) * i, n.update(D.bounds, D.vertices, t.velocity) } t.parts.length > 1 && (t.area = g, t.isStatic || (e.setMass(t, t.density * g), e.setInertia(t, y))), t.circleRadius && (s === i ? t.circleRadius *= s : t.circleRadius = null) }, e.update = function (t, s) { s = (typeof s < "u" ? s : 1e3 / 60) * t.timeScale; var i = s * s, f = e._timeCorrection ? s / (t.deltaTime || s) : 1, g = 1 - t.frictionAir * (s / h._baseDelta), y = (t.position.x - t.positionPrev.x) * f, M = (t.position.y - t.positionPrev.y) * f; t.velocity.x = y * g + t.force.x / t.mass * i, t.velocity.y = M * g + t.force.y / t.mass * i, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = s, t.angularVelocity = (t.angle - t.anglePrev) * g * f + t.torque / t.inertia * i, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var D = 0; D < t.parts.length; D++) { var u = t.parts[D]; l.translate(u.vertices, t.velocity), D > 0 && (u.position.x += t.velocity.x, u.position.y += t.velocity.y), t.angularVelocity !== 0 && (l.rotate(u.vertices, t.angularVelocity, t.position), c.rotate(u.axes, t.angularVelocity), D > 0 && o.rotateAbout(u.position, t.angularVelocity, t.position, u.position)), n.update(u.bounds, u.vertices, t.velocity) } }, e.updateVelocities = function (t) { var s = e._baseDelta / t.deltaTime, i = t.velocity; i.x = (t.position.x - t.positionPrev.x) * s, i.y = (t.position.y - t.positionPrev.y) * s, t.speed = Math.sqrt(i.x * i.x + i.y * i.y), t.angularVelocity = (t.angle - t.anglePrev) * s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, s, i) { var f = { x: s.x - t.position.x, y: s.y - t.position.y }; t.force.x += i.x, t.force.y += i.y, t.torque += f.x * i.y - f.y * i.x }, e._totalProperties = function (t) { for (var s = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { var f = t.parts[i], g = f.mass !== 1 / 0 ? f.mass : 1; s.mass += g, s.area += f.area, s.inertia += f.inertia, s.centre = o.add(s.centre, o.mult(f.position, g)) } return s.centre = o.div(s.centre, s.mass), s } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e.on = function (o, r, h) { for (var n = r.split(" "), c, a = 0; a < n.length; a++)c = n[a], o.events = o.events || {}, o.events[c] = o.events[c] || [], o.events[c].push(h); return h }, e.off = function (o, r, h) { if (!r) { o.events = {}; return } typeof r == "function" && (h = r, r = l.keys(o.events).join(" ")); for (var n = r.split(" "), c = 0; c < n.length; c++) { var a = o.events[n[c]], t = []; if (h && a) for (var s = 0; s < a.length; s++)a[s] !== h && t.push(a[s]); o.events[n[c]] = t } }, e.trigger = function (o, r, h) { var n, c, a, t, s = o.events; if (s && l.keys(s).length > 0) { h || (h = {}), n = r.split(" "); for (var i = 0; i < n.length; i++)if (c = n[i], a = s[c], a) { t = l.clone(h, !1), t.name = c, t.source = o; for (var f = 0; f < a.length; f++)a[f].apply(o, [t]) } } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(5), o = p(0), r = p(1), h = p(4); (function () { e.create = function (n) { return o.extend({ id: o.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, n) }, e.setModified = function (n, c, a, t) { if (n.isModified = c, c && n.cache && (n.cache.allBodies = null, n.cache.allConstraints = null, n.cache.allComposites = null), a && n.parent && e.setModified(n.parent, c, a, t), t) for (var s = 0; s < n.composites.length; s++) { var i = n.composites[s]; e.setModified(i, c, a, t) } }, e.add = function (n, c) { var a = [].concat(c); l.trigger(n, "beforeAdd", { object: c }); for (var t = 0; t < a.length; t++) { var s = a[t]; switch (s.type) { case "body": if (s.parent !== s) { o.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(n, s); break; case "constraint": e.addConstraint(n, s); break; case "composite": e.addComposite(n, s); break; case "mouseConstraint": e.addConstraint(n, s.constraint); break } } return l.trigger(n, "afterAdd", { object: c }), n }, e.remove = function (n, c, a) { var t = [].concat(c); l.trigger(n, "beforeRemove", { object: c }); for (var s = 0; s < t.length; s++) { var i = t[s]; switch (i.type) { case "body": e.removeBody(n, i, a); break; case "constraint": e.removeConstraint(n, i, a); break; case "composite": e.removeComposite(n, i, a); break; case "mouseConstraint": e.removeConstraint(n, i.constraint); break } } return l.trigger(n, "afterRemove", { object: c }), n }, e.addComposite = function (n, c) { return n.composites.push(c), c.parent = n, e.setModified(n, !0, !0, !1), n }, e.removeComposite = function (n, c, a) { var t = o.indexOf(n.composites, c); if (t !== -1) { var s = e.allBodies(c); e.removeCompositeAt(n, t); for (var i = 0; i < s.length; i++)s[i].sleepCounter = 0 } if (a) for (var i = 0; i < n.composites.length; i++)e.removeComposite(n.composites[i], c, !0); return n }, e.removeCompositeAt = function (n, c) { return n.composites.splice(c, 1), e.setModified(n, !0, !0, !1), n }, e.addBody = function (n, c) { return n.bodies.push(c), e.setModified(n, !0, !0, !1), n }, e.removeBody = function (n, c, a) { var t = o.indexOf(n.bodies, c); if (t !== -1 && (e.removeBodyAt(n, t), c.sleepCounter = 0), a) for (var s = 0; s < n.composites.length; s++)e.removeBody(n.composites[s], c, !0); return n }, e.removeBodyAt = function (n, c) { return n.bodies.splice(c, 1), e.setModified(n, !0, !0, !1), n }, e.addConstraint = function (n, c) { return n.constraints.push(c), e.setModified(n, !0, !0, !1), n }, e.removeConstraint = function (n, c, a) { var t = o.indexOf(n.constraints, c); if (t !== -1 && e.removeConstraintAt(n, t), a) for (var s = 0; s < n.composites.length; s++)e.removeConstraint(n.composites[s], c, !0); return n }, e.removeConstraintAt = function (n, c) { return n.constraints.splice(c, 1), e.setModified(n, !0, !0, !1), n }, e.clear = function (n, c, a) { if (a) for (var t = 0; t < n.composites.length; t++)e.clear(n.composites[t], c, !0); return c ? n.bodies = n.bodies.filter(function (s) { return s.isStatic }) : n.bodies.length = 0, n.constraints.length = 0, n.composites.length = 0, e.setModified(n, !0, !0, !1), n }, e.allBodies = function (n) { if (n.cache && n.cache.allBodies) return n.cache.allBodies; for (var c = [].concat(n.bodies), a = 0; a < n.composites.length; a++)c = c.concat(e.allBodies(n.composites[a])); return n.cache && (n.cache.allBodies = c), c }, e.allConstraints = function (n) { if (n.cache && n.cache.allConstraints) return n.cache.allConstraints; for (var c = [].concat(n.constraints), a = 0; a < n.composites.length; a++)c = c.concat(e.allConstraints(n.composites[a])); return n.cache && (n.cache.allConstraints = c), c }, e.allComposites = function (n) { if (n.cache && n.cache.allComposites) return n.cache.allComposites; for (var c = [].concat(n.composites), a = 0; a < n.composites.length; a++)c = c.concat(e.allComposites(n.composites[a])); return n.cache && (n.cache.allComposites = c), c }, e.get = function (n, c, a) { var t, s; switch (a) { case "body": t = e.allBodies(n); break; case "constraint": t = e.allConstraints(n); break; case "composite": t = e.allComposites(n).concat(n); break }return t ? (s = t.filter(function (i) { return i.id.toString() === c.toString() }), s.length === 0 ? null : s[0]) : null }, e.move = function (n, c, a) { return e.remove(n, c), e.add(a, c), n }, e.rebase = function (n) { for (var c = e.allBodies(n).concat(e.allConstraints(n)).concat(e.allComposites(n)), a = 0; a < c.length; a++)c[a].id = o.nextId(); return n }, e.translate = function (n, c, a) { for (var t = a ? e.allBodies(n) : n.bodies, s = 0; s < t.length; s++)h.translate(t[s], c); return n }, e.rotate = function (n, c, a, t) { for (var s = Math.cos(c), i = Math.sin(c), f = t ? e.allBodies(n) : n.bodies, g = 0; g < f.length; g++) { var y = f[g], M = y.position.x - a.x, D = y.position.y - a.y; h.setPosition(y, { x: a.x + (M * s - D * i), y: a.y + (M * i + D * s) }), h.rotate(y, c) } return n }, e.scale = function (n, c, a, t, s) { for (var i = s ? e.allBodies(n) : n.bodies, f = 0; f < i.length; f++) { var g = i[f], y = g.position.x - t.x, M = g.position.y - t.y; h.setPosition(g, { x: t.x + y * c, y: t.y + M * a }), h.scale(g, c, a) } return n }, e.bounds = function (n) { for (var c = e.allBodies(n), a = [], t = 0; t < c.length; t += 1) { var s = c[t]; a.push(s.bounds.min, s.bounds.max) } return r.create(a) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(4), o = p(5), r = p(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (h, n) { for (var c = n / r._baseDelta, a = e._motionSleepThreshold, t = 0; t < h.length; t++) { var s = h[t], i = l.getSpeed(s), f = l.getAngularSpeed(s), g = i * i + f * f; if (s.force.x !== 0 || s.force.y !== 0) { e.set(s, !1); continue } var y = Math.min(s.motion, g), M = Math.max(s.motion, g); s.motion = e._minBias * y + (1 - e._minBias) * M, s.sleepThreshold > 0 && s.motion < a ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold / c && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1) } }, e.afterCollisions = function (h) { for (var n = e._motionSleepThreshold, c = 0; c < h.length; c++) { var a = h[c]; if (a.isActive) { var t = a.collision, s = t.bodyA.parent, i = t.bodyB.parent; if (!(s.isSleeping && i.isSleeping || s.isStatic || i.isStatic) && (s.isSleeping || i.isSleeping)) { var f = s.isSleeping && !s.isStatic ? s : i, g = f === s ? i : s; !f.isStatic && g.motion > n && e.set(f, !1) } } } }, e.set = function (h, n) { var c = h.isSleeping; n ? (h.isSleeping = !0, h.sleepCounter = h.sleepThreshold, h.positionImpulse.x = 0, h.positionImpulse.y = 0, h.positionPrev.x = h.position.x, h.positionPrev.y = h.position.y, h.anglePrev = h.angle, h.speed = 0, h.angularSpeed = 0, h.motion = 0, c || o.trigger(h, "sleepStart")) : (h.isSleeping = !1, h.sleepCounter = 0, c && o.trigger(h, "sleepEnd")) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(9); (function () { var r = [], h = { overlap: 0, axis: null }, n = { overlap: 0, axis: null }; e.create = function (c, a) { return { pair: null, collided: !1, bodyA: c, bodyB: a, parentA: c.parent, parentB: a.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (c, a, t) { if (e._overlapAxes(h, c.vertices, a.vertices, c.axes), h.overlap <= 0 || (e._overlapAxes(n, a.vertices, c.vertices, a.axes), n.overlap <= 0)) return null; var s = t && t.table[o.id(c, a)], i; s ? i = s.collision : (i = e.create(c, a), i.collided = !0, i.bodyA = c.id < a.id ? c : a, i.bodyB = c.id < a.id ? a : c, i.parentA = i.bodyA.parent, i.parentB = i.bodyB.parent), c = i.bodyA, a = i.bodyB; var f; h.overlap < n.overlap ? f = h : f = n; var g = i.normal, y = i.tangent, M = i.penetration, D = i.supports, u = f.overlap, v = f.axis, m = v.x, d = v.y, S = a.position.x - c.position.x, x = a.position.y - c.position.y; m * S + d * x >= 0 && (m = -m, d = -d), g.x = m, g.y = d, y.x = -d, y.y = m, M.x = m * u, M.y = d * u, i.depth = u; var C = e._findSupports(c, a, g, 1), P = 0; if (l.contains(c.vertices, C[0]) && (D[P++] = C[0]), l.contains(c.vertices, C[1]) && (D[P++] = C[1]), P < 2) { var E = e._findSupports(a, c, g, -1); l.contains(a.vertices, E[0]) && (D[P++] = E[0]), P < 2 && l.contains(a.vertices, E[1]) && (D[P++] = E[1]) } return P === 0 && (D[P++] = C[0]), i.supportCount = P, i }, e._overlapAxes = function (c, a, t, s) { var i = a.length, f = t.length, g = a[0].x, y = a[0].y, M = t[0].x, D = t[0].y, u = s.length, v = Number.MAX_VALUE, m = 0, d, S, x, C, P, E; for (P = 0; P < u; P++) { var B = s[P], I = B.x, R = B.y, L = g * I + y * R, F = M * I + D * R, k = L, W = F; for (E = 1; E < i; E += 1)C = a[E].x * I + a[E].y * R, C > k ? k = C : C < L && (L = C); for (E = 1; E < f; E += 1)C = t[E].x * I + t[E].y * R, C > W ? W = C : C < F && (F = C); if (S = k - F, x = W - L, d = S < x ? S : x, d < v && (v = d, m = P, d <= 0)) break } c.axis = s[m], c.overlap = v }, e._findSupports = function (c, a, t, s) { var i = a.vertices, f = i.length, g = c.position.x, y = c.position.y, M = t.x * s, D = t.y * s, u = i[0], v = u, m = M * (g - v.x) + D * (y - v.y), d, S, x; for (x = 1; x < f; x += 1)v = i[x], S = M * (g - v.x) + D * (y - v.y), S < m && (m = S, u = v); return d = i[(f + u.index - 1) % f], m = M * (g - d.x) + D * (y - d.y), v = i[(u.index + 1) % f], M * (g - v.x) + D * (y - v.y) < m ? (r[0] = u, r[1] = v, r) : (r[0] = u, r[1] = d, r) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(16); (function () { e.create = function (o, r) { var h = o.bodyA, n = o.bodyB, c = { id: e.id(h, n), bodyA: h, bodyB: n, collision: o, contacts: [l.create(), l.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: h.isSensor || n.isSensor, timeCreated: r, timeUpdated: r, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(c, o, r), c }, e.update = function (o, r, h) { var n = r.supports, c = r.supportCount, a = o.contacts, t = r.parentA, s = r.parentB; o.isActive = !0, o.timeUpdated = h, o.collision = r, o.separation = r.depth, o.inverseMass = t.inverseMass + s.inverseMass, o.friction = t.friction < s.friction ? t.friction : s.friction, o.frictionStatic = t.frictionStatic > s.frictionStatic ? t.frictionStatic : s.frictionStatic, o.restitution = t.restitution > s.restitution ? t.restitution : s.restitution, o.slop = t.slop > s.slop ? t.slop : s.slop, o.contactCount = c, r.pair = o; var i = n[0], f = a[0], g = n[1], y = a[1]; (y.vertex === i || f.vertex === g) && (a[1] = f, a[0] = f = y, y = a[1]), f.vertex = i, y.vertex = g }, e.setActive = function (o, r, h) { r ? (o.isActive = !0, o.timeUpdated = h) : (o.isActive = !1, o.contactCount = 0) }, e.id = function (o, r) { return o.id < r.id ? o.id.toString(36) + ":" + r.id.toString(36) : r.id.toString(36) + ":" + o.id.toString(36) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(2), r = p(7), h = p(1), n = p(11), c = p(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (a) { var t = a; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var s = t.bodyA ? o.add(t.bodyA.position, t.pointA) : t.pointA, i = t.bodyB ? o.add(t.bodyB.position, t.pointB) : t.pointB, f = o.magnitude(o.sub(s, i)); t.length = typeof t.length < "u" ? t.length : f, t.id = t.id || c.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var g = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (g.type = "pin", g.anchors = !1) : t.stiffness < .9 && (g.type = "spring"), t.render = c.extend(g, t.render), t }, e.preSolveAll = function (a) { for (var t = 0; t < a.length; t += 1) { var s = a[t], i = s.constraintImpulse; s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0 || (s.position.x += i.x, s.position.y += i.y, s.angle += i.angle) } }, e.solveAll = function (a, t) { for (var s = c.clamp(t / c._baseDelta, 0, 1), i = 0; i < a.length; i += 1) { var f = a[i], g = !f.bodyA || f.bodyA && f.bodyA.isStatic, y = !f.bodyB || f.bodyB && f.bodyB.isStatic; (g || y) && e.solve(a[i], s) } for (i = 0; i < a.length; i += 1)f = a[i], g = !f.bodyA || f.bodyA && f.bodyA.isStatic, y = !f.bodyB || f.bodyB && f.bodyB.isStatic, !g && !y && e.solve(a[i], s) }, e.solve = function (a, t) { var s = a.bodyA, i = a.bodyB, f = a.pointA, g = a.pointB; if (!(!s && !i)) { s && !s.isStatic && (o.rotate(f, s.angle - a.angleA, f), a.angleA = s.angle), i && !i.isStatic && (o.rotate(g, i.angle - a.angleB, g), a.angleB = i.angle); var y = f, M = g; if (s && (y = o.add(s.position, f)), i && (M = o.add(i.position, g)), !(!y || !M)) { var D = o.sub(y, M), u = o.magnitude(D); u < e._minLength && (u = e._minLength); var v = (u - a.length) / u, m = a.stiffness >= 1 || a.length === 0, d = m ? a.stiffness * t : a.stiffness * t * t, S = a.damping * t, x = o.mult(D, v * d), C = (s ? s.inverseMass : 0) + (i ? i.inverseMass : 0), P = (s ? s.inverseInertia : 0) + (i ? i.inverseInertia : 0), E = C + P, B, I, R, L, F; if (S > 0) { var k = o.create(); R = o.div(D, u), F = o.sub(i && o.sub(i.position, i.positionPrev) || k, s && o.sub(s.position, s.positionPrev) || k), L = o.dot(R, F) } s && !s.isStatic && (I = s.inverseMass / C, s.constraintImpulse.x -= x.x * I, s.constraintImpulse.y -= x.y * I, s.position.x -= x.x * I, s.position.y -= x.y * I, S > 0 && (s.positionPrev.x -= S * R.x * L * I, s.positionPrev.y -= S * R.y * L * I), B = o.cross(f, x) / E * e._torqueDampen * s.inverseInertia * (1 - a.angularStiffness), s.constraintImpulse.angle -= B, s.angle -= B), i && !i.isStatic && (I = i.inverseMass / C, i.constraintImpulse.x += x.x * I, i.constraintImpulse.y += x.y * I, i.position.x += x.x * I, i.position.y += x.y * I, S > 0 && (i.positionPrev.x += S * R.x * L * I, i.positionPrev.y += S * R.y * L * I), B = o.cross(g, x) / E * e._torqueDampen * i.inverseInertia * (1 - a.angularStiffness), i.constraintImpulse.angle += B, i.angle += B) } } }, e.postSolveAll = function (a) { for (var t = 0; t < a.length; t++) { var s = a[t], i = s.constraintImpulse; if (!(s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0)) { r.set(s, !1); for (var f = 0; f < s.parts.length; f++) { var g = s.parts[f]; l.translate(g.vertices, i), f > 0 && (g.position.x += i.x, g.position.y += i.y), i.angle !== 0 && (l.rotate(g.vertices, i.angle, s.position), n.rotate(g.axes, i.angle), f > 0 && o.rotateAbout(g.position, i.angle, s.position, g.position)), h.update(g.bounds, g.vertices, s.velocity) } i.angle *= e._warming, i.x *= e._warming, i.y *= e._warming } } }, e.pointAWorld = function (a) { return { x: (a.bodyA ? a.bodyA.position.x : 0) + (a.pointA ? a.pointA.x : 0), y: (a.bodyA ? a.bodyA.position.y : 0) + (a.pointA ? a.pointA.y : 0) } }, e.pointBWorld = function (a) { return { x: (a.bodyB ? a.bodyB.position.x : 0) + (a.pointB ? a.pointB.x : 0), y: (a.bodyB ? a.bodyB.position.y : 0) + (a.pointB ? a.pointB.y : 0) } }, e.currentLength = function (a) { var t = (a.bodyA ? a.bodyA.position.x : 0) + (a.pointA ? a.pointA.x : 0), s = (a.bodyA ? a.bodyA.position.y : 0) + (a.pointA ? a.pointA.y : 0), i = (a.bodyB ? a.bodyB.position.x : 0) + (a.pointB ? a.pointB.x : 0), f = (a.bodyB ? a.bodyB.position.y : 0) + (a.pointB ? a.pointB.y : 0), g = t - i, y = s - f; return Math.sqrt(g * g + y * y) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), o = p(0); (function () { e.fromVertices = function (r) { for (var h = {}, n = 0; n < r.length; n++) { var c = (n + 1) % r.length, a = l.normalise({ x: r[c].y - r[n].y, y: r[n].x - r[c].x }), t = a.y === 0 ? 1 / 0 : a.x / a.y; t = t.toFixed(3).toString(), h[t] = a } return o.values(h) }, e.rotate = function (r, h) { if (h !== 0) for (var n = Math.cos(h), c = Math.sin(h), a = 0; a < r.length; a++) { var t = r[a], s; s = t.x * n - t.y * c, t.y = t.x * c + t.y * n, t.x = s } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(0), r = p(4), h = p(1), n = p(2); (function () { e.rectangle = function (c, a, t, s, i) { i = i || {}; var f = { label: "Rectangle Body", position: { x: c, y: a }, vertices: l.fromPath("L 0 0 L " + t + " 0 L " + t + " " + s + " L 0 " + s) }; if (i.chamfer) { var g = i.chamfer; f.vertices = l.chamfer(f.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete i.chamfer } return r.create(o.extend({}, f, i)) }, e.trapezoid = function (c, a, t, s, i, f) { f = f || {}, i >= 1 && o.warn("Bodies.trapezoid: slope parameter must be < 1."), i *= .5; var g = (1 - i * 2) * t, y = t * i, M = y + g, D = M + y, u; i < .5 ? u = "L 0 0 L " + y + " " + -s + " L " + M + " " + -s + " L " + D + " 0" : u = "L 0 0 L " + M + " " + -s + " L " + D + " 0"; var v = { label: "Trapezoid Body", position: { x: c, y: a }, vertices: l.fromPath(u) }; if (f.chamfer) { var m = f.chamfer; v.vertices = l.chamfer(v.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete f.chamfer } return r.create(o.extend({}, v, f)) }, e.circle = function (c, a, t, s, i) { s = s || {}; var f = { label: "Circle Body", circleRadius: t }; i = i || 25; var g = Math.ceil(Math.max(10, Math.min(i, t))); return g % 2 === 1 && (g += 1), e.polygon(c, a, g, t, o.extend({}, f, s)) }, e.polygon = function (c, a, t, s, i) { if (i = i || {}, t < 3) return e.circle(c, a, s, i); for (var f = 2 * Math.PI / t, g = "", y = f * .5, M = 0; M < t; M += 1) { var D = y + M * f, u = Math.cos(D) * s, v = Math.sin(D) * s; g += "L " + u.toFixed(3) + " " + v.toFixed(3) + " " } var m = { label: "Polygon Body", position: { x: c, y: a }, vertices: l.fromPath(g) }; if (i.chamfer) { var d = i.chamfer; m.vertices = l.chamfer(m.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete i.chamfer } return r.create(o.extend({}, m, i)) }, e.fromVertices = function (c, a, t, s, i, f, g, y) { var M = o.getDecomp(), D, u, v, m, d, S, x, C, P, E, B; for (D = !!(M && M.quickDecomp), s = s || {}, v = [], i = typeof i < "u" ? i : !1, f = typeof f < "u" ? f : .01, g = typeof g < "u" ? g : 10, y = typeof y < "u" ? y : .01, o.isArray(t[0]) || (t = [t]), E = 0; E < t.length; E += 1)if (S = t[E], m = l.isConvex(S), d = !m, d && !D && o.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), m || !D) m ? S = l.clockwiseSort(S) : S = l.hull(S), v.push({ position: { x: c, y: a }, vertices: S }); else { var I = S.map(function (H) { return [H.x, H.y] }); M.makeCCW(I), f !== !1 && M.removeCollinearPoints(I, f), y !== !1 && M.removeDuplicatePoints && M.removeDuplicatePoints(I, y); var R = M.quickDecomp(I); for (x = 0; x < R.length; x++) { var L = R[x], F = L.map(function (H) { return { x: H[0], y: H[1] } }); g > 0 && l.area(F) < g || v.push({ position: l.centre(F), vertices: F }) } } for (x = 0; x < v.length; x++)v[x] = r.create(o.extend(v[x], s)); if (i) { var k = 5; for (x = 0; x < v.length; x++) { var W = v[x]; for (C = x + 1; C < v.length; C++) { var $ = v[C]; if (h.overlaps(W.bounds, $.bounds)) { var U = W.vertices, G = $.vertices; for (P = 0; P < W.vertices.length; P++)for (B = 0; B < $.vertices.length; B++) { var _ = n.magnitudeSquared(n.sub(U[(P + 1) % U.length], G[B])), z = n.magnitudeSquared(n.sub(U[P], G[(B + 1) % G.length])); _ < k && z < k && (U[P].isInternal = !0, G[B].isInternal = !0) } } } } } return v.length > 1 ? (u = r.create(o.extend({ parts: v.slice(0) }, s)), r.setPosition(u, { x: c, y: a }), u) : v[0] } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0), o = p(8); (function () { e.create = function (r) { var h = { bodies: [], collisions: [], pairs: null }; return l.extend(h, r) }, e.setBodies = function (r, h) { r.bodies = h.slice(0) }, e.clear = function (r) { r.bodies = [], r.collisions = [] }, e.collisions = function (r) { var h = r.pairs, n = r.bodies, c = n.length, a = e.canCollide, t = o.collides, s = r.collisions, i = 0, f, g; for (n.sort(e._compareBoundsX), f = 0; f < c; f++) { var y = n[f], M = y.bounds, D = y.bounds.max.x, u = y.bounds.max.y, v = y.bounds.min.y, m = y.isStatic || y.isSleeping, d = y.parts.length, S = d === 1; for (g = f + 1; g < c; g++) { var x = n[g], C = x.bounds; if (C.min.x > D) break; if (!(u < C.min.y || v > C.max.y) && !(m && (x.isStatic || x.isSleeping)) && a(y.collisionFilter, x.collisionFilter)) { var P = x.parts.length; if (S && P === 1) { var E = t(y, x, h); E && (s[i++] = E) } else for (var B = d > 1 ? 1 : 0, I = P > 1 ? 1 : 0, R = B; R < d; R++)for (var L = y.parts[R], M = L.bounds, F = I; F < P; F++) { var k = x.parts[F], C = k.bounds; if (!(M.min.x > C.max.x || M.max.x < C.min.x || M.max.y < C.min.y || M.min.y > C.max.y)) { var E = t(L, k, h); E && (s[i++] = E) } } } } } return s.length !== i && (s.length = i), s }, e.canCollide = function (r, h) { return r.group === h.group && r.group !== 0 ? r.group > 0 : (r.mask & h.category) !== 0 && (h.mask & r.category) !== 0 }, e._compareBoundsX = function (r, h) { return r.bounds.min.x - h.bounds.min.x } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e.create = function (o) { var r = {}; return o || l.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), r.element = o || document.body, r.absolute = { x: 0, y: 0 }, r.position = { x: 0, y: 0 }, r.mousedownPosition = { x: 0, y: 0 }, r.mouseupPosition = { x: 0, y: 0 }, r.offset = { x: 0, y: 0 }, r.scale = { x: 1, y: 1 }, r.wheelDelta = 0, r.button = -1, r.pixelRatio = parseInt(r.element.getAttribute("data-pixel-ratio"), 10) || 1, r.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, r.mousemove = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), c = h.changedTouches; c && (r.button = 0, h.preventDefault()), r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.sourceEvents.mousemove = h }, r.mousedown = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), c = h.changedTouches; c ? (r.button = 0, h.preventDefault()) : r.button = h.button, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mousedownPosition.x = r.position.x, r.mousedownPosition.y = r.position.y, r.sourceEvents.mousedown = h }, r.mouseup = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), c = h.changedTouches; c && h.preventDefault(), r.button = -1, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mouseupPosition.x = r.position.x, r.mouseupPosition.y = r.position.y, r.sourceEvents.mouseup = h }, r.mousewheel = function (h) { r.wheelDelta = Math.max(-1, Math.min(1, h.wheelDelta || -h.detail)), h.preventDefault(), r.sourceEvents.mousewheel = h }, e.setElement(r, r.element), r }, e.setElement = function (o, r) { o.element = r, r.addEventListener("mousemove", o.mousemove, { passive: !0 }), r.addEventListener("mousedown", o.mousedown, { passive: !0 }), r.addEventListener("mouseup", o.mouseup, { passive: !0 }), r.addEventListener("wheel", o.mousewheel, { passive: !1 }), r.addEventListener("touchmove", o.mousemove, { passive: !1 }), r.addEventListener("touchstart", o.mousedown, { passive: !1 }), r.addEventListener("touchend", o.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (o) { o.sourceEvents.mousemove = null, o.sourceEvents.mousedown = null, o.sourceEvents.mouseup = null, o.sourceEvents.mousewheel = null, o.wheelDelta = 0 }, e.setOffset = function (o, r) { o.offset.x = r.x, o.offset.y = r.y, o.position.x = o.absolute.x * o.scale.x + o.offset.x, o.position.y = o.absolute.y * o.scale.y + o.offset.y }, e.setScale = function (o, r) { o.scale.x = r.x, o.scale.y = r.y, o.position.x = o.absolute.x * o.scale.x + o.offset.x, o.position.y = o.absolute.y * o.scale.y + o.offset.y }, e._getRelativeMousePosition = function (o, r, h) { var n = r.getBoundingClientRect(), c = document.documentElement || document.body.parentNode || document.body, a = window.pageXOffset !== void 0 ? window.pageXOffset : c.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : c.scrollTop, s = o.changedTouches, i, f; return s ? (i = s[0].pageX - n.left - a, f = s[0].pageY - n.top - t) : (i = o.pageX - n.left - a, f = o.pageY - n.top - t), { x: i / (r.clientWidth / (r.width || r.clientWidth) * h), y: f / (r.clientHeight / (r.height || r.clientHeight) * h) } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(0); (function () { e._registry = {}, e.register = function (o) { if (e.isPlugin(o) || l.warn("Plugin.register:", e.toString(o), "does not implement all required fields."), o.name in e._registry) { var r = e._registry[o.name], h = e.versionParse(o.version).number, n = e.versionParse(r.version).number; h > n ? (l.warn("Plugin.register:", e.toString(r), "was upgraded to", e.toString(o)), e._registry[o.name] = o) : h < n ? l.warn("Plugin.register:", e.toString(r), "can not be downgraded to", e.toString(o)) : o !== r && l.warn("Plugin.register:", e.toString(o), "is already registered to different plugin object") } else e._registry[o.name] = o; return o }, e.resolve = function (o) { return e._registry[e.dependencyParse(o).name] }, e.toString = function (o) { return typeof o == "string" ? o : (o.name || "anonymous") + "@" + (o.version || o.range || "0.0.0") }, e.isPlugin = function (o) { return o && o.name && o.version && o.install }, e.isUsed = function (o, r) { return o.used.indexOf(r) > -1 }, e.isFor = function (o, r) { var h = o.for && e.dependencyParse(o.for); return !o.for || r.name === h.name && e.versionSatisfies(r.version, h.range) }, e.use = function (o, r) { if (o.uses = (o.uses || []).concat(r || []), o.uses.length === 0) { l.warn("Plugin.use:", e.toString(o), "does not specify any dependencies to install."); return } for (var h = e.dependencies(o), n = l.topologicalSort(h), c = [], a = 0; a < n.length; a += 1)if (n[a] !== o.name) { var t = e.resolve(n[a]); if (!t) { c.push("❌ " + n[a]); continue } e.isUsed(o, t.name) || (e.isFor(t, o) || (l.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(o) + "."), t._warned = !0), t.install ? t.install(o) : (l.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (c.push("🔶 " + e.toString(t)), delete t._warned) : c.push("✅ " + e.toString(t)), o.used.push(t.name)) } c.length > 0 && l.info(c.join("  ")) }, e.dependencies = function (o, r) { var h = e.dependencyParse(o), n = h.name; if (r = r || {}, !(n in r)) { o = e.resolve(o) || o, r[n] = l.map(o.uses || [], function (a) { e.isPlugin(a) && e.register(a); var t = e.dependencyParse(a), s = e.resolve(a); return s && !e.versionSatisfies(s.version, t.range) ? (l.warn("Plugin.dependencies:", e.toString(s), "does not satisfy", e.toString(t), "used by", e.toString(h) + "."), s._warned = !0, o._warned = !0) : s || (l.warn("Plugin.dependencies:", e.toString(a), "used by", e.toString(h), "could not be resolved."), o._warned = !0), t.name }); for (var c = 0; c < r[n].length; c += 1)e.dependencies(r[n][c], r); return r } }, e.dependencyParse = function (o) { if (l.isString(o)) { var r = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return r.test(o) || l.warn("Plugin.dependencyParse:", o, "is not a valid dependency string."), { name: o.split("@")[0], range: o.split("@")[1] || "*" } } return { name: o.name, range: o.range || o.version } }, e.versionParse = function (o) { var r = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; r.test(o) || l.warn("Plugin.versionParse:", o, "is not a valid version or range."); var h = r.exec(o), n = Number(h[4]), c = Number(h[5]), a = Number(h[6]); return { isRange: !!(h[1] || h[2]), version: h[3], range: o, operator: h[1] || h[2] || "", major: n, minor: c, patch: a, parts: [n, c, a], prerelease: h[7], number: n * 1e8 + c * 1e4 + a } }, e.versionSatisfies = function (o, r) { r = r || "*"; var h = e.versionParse(r), n = e.versionParse(o); if (h.isRange) { if (h.operator === "*" || o === "*") return !0; if (h.operator === ">") return n.number > h.number; if (h.operator === ">=") return n.number >= h.number; if (h.operator === "~") return n.major === h.major && n.minor === h.minor && n.patch >= h.patch; if (h.operator === "^") return h.major > 0 ? n.major === h.major && n.number >= h.number : h.minor > 0 ? n.minor === h.minor && n.patch >= h.patch : n.patch === h.patch } return o === r || o === "*" } })() }, function (w, O) { var p = {}; w.exports = p, function () { p.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(7), o = p(18), r = p(13), h = p(19), n = p(5), c = p(6), a = p(10), t = p(0), s = p(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (i) { i = i || {}; var f = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, g = t.extend(f, i); return g.world = i.world || c.create({ label: "World" }), g.pairs = i.pairs || h.create(), g.detector = i.detector || r.create(), g.detector.pairs = g.pairs, g.grid = { buckets: [] }, g.world.gravity = g.gravity, g.broadphase = g.grid, g.metrics = {}, g }, e.update = function (i, f) { var g = t.now(), y = i.world, M = i.detector, D = i.pairs, u = i.timing, v = u.timestamp, m; f > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), f = typeof f < "u" ? f : t._baseDelta, f *= u.timeScale, u.timestamp += f, u.lastDelta = f; var d = { timestamp: u.timestamp, delta: f }; n.trigger(i, "beforeUpdate", d); var S = c.allBodies(y), x = c.allConstraints(y); for (y.isModified && (r.setBodies(M, S), c.setModified(y, !1, !1, !0)), i.enableSleeping && l.update(S, f), e._bodiesApplyGravity(S, i.gravity), f > 0 && e._bodiesUpdate(S, f), n.trigger(i, "beforeSolve", d), a.preSolveAll(S), m = 0; m < i.constraintIterations; m++)a.solveAll(x, f); a.postSolveAll(S); var C = r.collisions(M); h.update(D, C, v), i.enableSleeping && l.afterCollisions(D.list), D.collisionStart.length > 0 && n.trigger(i, "collisionStart", { pairs: D.collisionStart, timestamp: u.timestamp, delta: f }); var P = t.clamp(20 / i.positionIterations, 0, 1); for (o.preSolvePosition(D.list), m = 0; m < i.positionIterations; m++)o.solvePosition(D.list, f, P); for (o.postSolvePosition(S), a.preSolveAll(S), m = 0; m < i.constraintIterations; m++)a.solveAll(x, f); for (a.postSolveAll(S), o.preSolveVelocity(D.list), m = 0; m < i.velocityIterations; m++)o.solveVelocity(D.list, f); return e._bodiesUpdateVelocities(S), D.collisionActive.length > 0 && n.trigger(i, "collisionActive", { pairs: D.collisionActive, timestamp: u.timestamp, delta: f }), D.collisionEnd.length > 0 && n.trigger(i, "collisionEnd", { pairs: D.collisionEnd, timestamp: u.timestamp, delta: f }), e._bodiesClearForces(S), n.trigger(i, "afterUpdate", d), i.timing.lastElapsed = t.now() - g, i }, e.merge = function (i, f) { if (t.extend(i, f), f.world) { i.world = f.world, e.clear(i); for (var g = c.allBodies(i.world), y = 0; y < g.length; y++) { var M = g[y]; l.set(M, !1), M.id = t.nextId() } } }, e.clear = function (i) { h.clear(i.pairs), r.clear(i.detector) }, e._bodiesClearForces = function (i) { for (var f = i.length, g = 0; g < f; g++) { var y = i[g]; y.force.x = 0, y.force.y = 0, y.torque = 0 } }, e._bodiesApplyGravity = function (i, f) { var g = typeof f.scale < "u" ? f.scale : .001, y = i.length; if (!(f.x === 0 && f.y === 0 || g === 0)) for (var M = 0; M < y; M++) { var D = i[M]; D.isStatic || D.isSleeping || (D.force.y += D.mass * f.y * g, D.force.x += D.mass * f.x * g) } }, e._bodiesUpdate = function (i, f) { for (var g = i.length, y = 0; y < g; y++) { var M = i[y]; M.isStatic || M.isSleeping || s.update(M, f) } }, e._bodiesUpdateVelocities = function (i) { for (var f = i.length, g = 0; g < f; g++)s.updateVelocities(i[g]) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(0), r = p(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (h) { var n, c, a, t = h.length; for (n = 0; n < t; n++)c = h[n], c.isActive && (a = c.contactCount, c.collision.parentA.totalContacts += a, c.collision.parentB.totalContacts += a) }, e.solvePosition = function (h, n, c) { var a, t, s, i, f, g, y, M, D = e._positionDampen * (c || 1), u = o.clamp(n / o._baseDelta, 0, 1), v = h.length; for (a = 0; a < v; a++)t = h[a], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, f = s.parentB, g = s.normal, t.separation = s.depth + g.x * (f.positionImpulse.x - i.positionImpulse.x) + g.y * (f.positionImpulse.y - i.positionImpulse.y)); for (a = 0; a < v; a++)t = h[a], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, f = s.parentB, g = s.normal, M = t.separation - t.slop * u, (i.isStatic || f.isStatic) && (M *= 2), i.isStatic || i.isSleeping || (y = D / i.totalContacts, i.positionImpulse.x += g.x * M * y, i.positionImpulse.y += g.y * M * y), f.isStatic || f.isSleeping || (y = D / f.totalContacts, f.positionImpulse.x -= g.x * M * y, f.positionImpulse.y -= g.y * M * y)) }, e.postSolvePosition = function (h) { for (var n = e._positionWarming, c = h.length, a = l.translate, t = r.update, s = 0; s < c; s++) { var i = h[s], f = i.positionImpulse, g = f.x, y = f.y, M = i.velocity; if (i.totalContacts = 0, g !== 0 || y !== 0) { for (var D = 0; D < i.parts.length; D++) { var u = i.parts[D]; a(u.vertices, f), t(u.bounds, u.vertices, M), u.position.x += g, u.position.y += y } i.positionPrev.x += g, i.positionPrev.y += y, g * M.x + y * M.y < 0 ? (f.x = 0, f.y = 0) : (f.x *= n, f.y *= n) } } }, e.preSolveVelocity = function (h) { var n = h.length, c, a; for (c = 0; c < n; c++) { var t = h[c]; if (!(!t.isActive || t.isSensor)) { var s = t.contacts, i = t.contactCount, f = t.collision, g = f.parentA, y = f.parentB, M = f.normal, D = f.tangent; for (a = 0; a < i; a++) { var u = s[a], v = u.vertex, m = u.normalImpulse, d = u.tangentImpulse; if (m !== 0 || d !== 0) { var S = M.x * m + D.x * d, x = M.y * m + D.y * d; g.isStatic || g.isSleeping || (g.positionPrev.x += S * g.inverseMass, g.positionPrev.y += x * g.inverseMass, g.anglePrev += g.inverseInertia * ((v.x - g.position.x) * x - (v.y - g.position.y) * S)), y.isStatic || y.isSleeping || (y.positionPrev.x -= S * y.inverseMass, y.positionPrev.y -= x * y.inverseMass, y.anglePrev -= y.inverseInertia * ((v.x - y.position.x) * x - (v.y - y.position.y) * S)) } } } } }, e.solveVelocity = function (h, n) { var c = n / o._baseDelta, a = c * c, t = a * c, s = -e._restingThresh * c, i = e._restingThreshTangent, f = e._frictionNormalMultiplier * c, g = e._frictionMaxStatic, y = h.length, M, D, u, v; for (u = 0; u < y; u++) { var m = h[u]; if (!(!m.isActive || m.isSensor)) { var d = m.collision, S = d.parentA, x = d.parentB, C = d.normal.x, P = d.normal.y, E = d.tangent.x, B = d.tangent.y, I = m.inverseMass, R = m.friction * m.frictionStatic * f, L = m.contacts, F = m.contactCount, k = 1 / F, W = S.position.x - S.positionPrev.x, $ = S.position.y - S.positionPrev.y, U = S.angle - S.anglePrev, G = x.position.x - x.positionPrev.x, _ = x.position.y - x.positionPrev.y, z = x.angle - x.anglePrev; for (v = 0; v < F; v++) { var H = L[v], J = H.vertex, N = J.x - S.position.x, oe = J.y - S.position.y, X = J.x - x.position.x, Z = J.y - x.position.y, b = W - oe * U, _e = $ + N * U, et = G - Z * z, tt = _ + X * z, Ee = b - et, Ie = _e - tt, ve = C * Ee + P * Ie, j = E * Ee + B * Ie, Be = m.separation + ve, ge = Math.min(Be, 1); ge = Be < 0 ? 0 : ge; var Le = ge * R; j < -Le || j > Le ? (D = j > 0 ? j : -j, M = m.friction * (j > 0 ? 1 : -1) * t, M < -D ? M = -D : M > D && (M = D)) : (M = j, D = g); var Re = N * P - oe * C, Fe = X * P - Z * C, He = k / (I + S.inverseInertia * Re * Re + x.inverseInertia * Fe * Fe), fe = (1 + m.restitution) * ve * He; if (M *= He, ve < s) H.normalImpulse = 0; else { var nt = H.normalImpulse; H.normalImpulse += fe, H.normalImpulse > 0 && (H.normalImpulse = 0), fe = H.normalImpulse - nt } if (j < -i || j > i) H.tangentImpulse = 0; else { var it = H.tangentImpulse; H.tangentImpulse += M, H.tangentImpulse < -D && (H.tangentImpulse = -D), H.tangentImpulse > D && (H.tangentImpulse = D), M = H.tangentImpulse - it } var ce = C * fe + E * M, ue = P * fe + B * M; S.isStatic || S.isSleeping || (S.positionPrev.x += ce * S.inverseMass, S.positionPrev.y += ue * S.inverseMass, S.anglePrev += (N * ue - oe * ce) * S.inverseInertia), x.isStatic || x.isSleeping || (x.positionPrev.x -= ce * x.inverseMass, x.positionPrev.y -= ue * x.inverseMass, x.anglePrev -= (X * ue - Z * ce) * x.inverseInertia) } } } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(9), o = p(0); (function () { e.create = function (r) { return o.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, r) }, e.update = function (r, h, n) { var c = l.update, a = l.create, t = l.setActive, s = r.table, i = r.list, f = i.length, g = f, y = r.collisionStart, M = r.collisionEnd, D = r.collisionActive, u = h.length, v = 0, m = 0, d = 0, S, x, C; for (C = 0; C < u; C++)S = h[C], x = S.pair, x ? (x.isActive && (D[d++] = x), c(x, S, n)) : (x = a(S, n), s[x.id] = x, y[v++] = x, i[g++] = x); for (g = 0, f = i.length, C = 0; C < f; C++)x = i[C], x.timeUpdated >= n ? i[g++] = x : (t(x, !1, n), x.collision.bodyA.sleepCounter > 0 && x.collision.bodyB.sleepCounter > 0 ? i[g++] = x : (M[m++] = x, delete s[x.id])); i.length !== g && (i.length = g), y.length !== v && (y.length = v), M.length !== m && (M.length = m), D.length !== d && (D.length = d) }, e.clear = function (r) { return r.table = {}, r.list.length = 0, r.collisionStart.length = 0, r.collisionActive.length = 0, r.collisionEnd.length = 0, r } })() }, function (w, O, p) { var e = w.exports = p(21); e.Axes = p(11), e.Bodies = p(12), e.Body = p(4), e.Bounds = p(1), e.Collision = p(8), e.Common = p(0), e.Composite = p(6), e.Composites = p(22), e.Constraint = p(10), e.Contact = p(16), e.Detector = p(13), e.Engine = p(17), e.Events = p(5), e.Grid = p(23), e.Mouse = p(14), e.MouseConstraint = p(24), e.Pair = p(9), e.Pairs = p(19), e.Plugin = p(15), e.Query = p(25), e.Render = p(26), e.Resolver = p(18), e.Runner = p(27), e.SAT = p(28), e.Sleeping = p(7), e.Svg = p(29), e.Vector = p(2), e.Vertices = p(3), e.World = p(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function (w, O, p) { var e = {}; w.exports = e; var l = p(15), o = p(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { l.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (r, h) { return r = r.replace(/^Matter./, ""), o.chainPathBefore(e, r, h) }, e.after = function (r, h) { return r = r.replace(/^Matter./, ""), o.chainPathAfter(e, r, h) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(6), o = p(10), r = p(0), h = p(4), n = p(12), c = r.deprecated; (function () { e.stack = function (a, t, s, i, f, g, y) { for (var M = l.create({ label: "Stack" }), D = a, u = t, v, m = 0, d = 0; d < i; d++) { for (var S = 0, x = 0; x < s; x++) { var C = y(D, u, x, d, v, m); if (C) { var P = C.bounds.max.y - C.bounds.min.y, E = C.bounds.max.x - C.bounds.min.x; P > S && (S = P), h.translate(C, { x: E * .5, y: P * .5 }), D = C.bounds.max.x + f, l.addBody(M, C), v = C, m += 1 } else D += f } u += S + g, D = a } return M }, e.chain = function (a, t, s, i, f, g) { for (var y = a.bodies, M = 1; M < y.length; M++) { var D = y[M - 1], u = y[M], v = D.bounds.max.y - D.bounds.min.y, m = D.bounds.max.x - D.bounds.min.x, d = u.bounds.max.y - u.bounds.min.y, S = u.bounds.max.x - u.bounds.min.x, x = { bodyA: D, pointA: { x: m * t, y: v * s }, bodyB: u, pointB: { x: S * i, y: d * f } }, C = r.extend(x, g); l.addConstraint(a, o.create(C)) } return a.label += " Chain", a }, e.mesh = function (a, t, s, i, f) { var g = a.bodies, y, M, D, u, v; for (y = 0; y < s; y++) { for (M = 1; M < t; M++)D = g[M - 1 + y * t], u = g[M + y * t], l.addConstraint(a, o.create(r.extend({ bodyA: D, bodyB: u }, f))); if (y > 0) for (M = 0; M < t; M++)D = g[M + (y - 1) * t], u = g[M + y * t], l.addConstraint(a, o.create(r.extend({ bodyA: D, bodyB: u }, f))), i && M > 0 && (v = g[M - 1 + (y - 1) * t], l.addConstraint(a, o.create(r.extend({ bodyA: v, bodyB: u }, f)))), i && M < t - 1 && (v = g[M + 1 + (y - 1) * t], l.addConstraint(a, o.create(r.extend({ bodyA: v, bodyB: u }, f)))) } return a.label += " Mesh", a }, e.pyramid = function (a, t, s, i, f, g, y) { return e.stack(a, t, s, i, f, g, function (M, D, u, v, m, d) { var S = Math.min(i, Math.ceil(s / 2)), x = m ? m.bounds.max.x - m.bounds.min.x : 0; if (!(v > S)) { v = S - v; var C = v, P = s - 1 - v; if (!(u < C || u > P)) { d === 1 && h.translate(m, { x: (u + (s % 2 === 1 ? 1 : -1)) * x, y: 0 }); var E = m ? u * x : 0; return y(a + E + u * f, D, u, v, m, d) } } }) }, e.newtonsCradle = function (a, t, s, i, f) { for (var g = l.create({ label: "Newtons Cradle" }), y = 0; y < s; y++) { var M = 1.9, D = n.circle(a + y * (i * M), t + f, i, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), u = o.create({ pointA: { x: a + y * (i * M), y: t }, bodyB: D }); l.addBody(g, D), l.addConstraint(g, u) } return g }, c(e, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), e.car = function (a, t, s, i, f) { var g = h.nextGroup(!0), y = 20, M = -s * .5 + y, D = s * .5 - y, u = 0, v = l.create({ label: "Car" }), m = n.rectangle(a, t, s, i, { collisionFilter: { group: g }, chamfer: { radius: i * .5 }, density: 2e-4 }), d = n.circle(a + M, t + u, f, { collisionFilter: { group: g }, friction: .8 }), S = n.circle(a + D, t + u, f, { collisionFilter: { group: g }, friction: .8 }), x = o.create({ bodyB: m, pointB: { x: M, y: u }, bodyA: d, stiffness: 1, length: 0 }), C = o.create({ bodyB: m, pointB: { x: D, y: u }, bodyA: S, stiffness: 1, length: 0 }); return l.addBody(v, m), l.addBody(v, d), l.addBody(v, S), l.addConstraint(v, x), l.addConstraint(v, C), v }, c(e, "car", "Composites.car ➤ moved to car example"), e.softBody = function (a, t, s, i, f, g, y, M, D, u) { D = r.extend({ inertia: 1 / 0 }, D), u = r.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, u); var v = e.stack(a, t, s, i, f, g, function (m, d) { return n.circle(m, d, M, D) }); return e.mesh(v, s, i, y, u), v.label = "Soft Body", v }, c(e, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(9), o = p(0), r = o.deprecated; (function () { e.create = function (h) { var n = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return o.extend(n, h) }, e.update = function (h, n, c, a) { var t, s, i, f = c.world, g = h.buckets, y, M, D = !1; for (t = 0; t < n.length; t++) { var u = n[t]; if (!(u.isSleeping && !a) && !(f.bounds && (u.bounds.max.x < f.bounds.min.x || u.bounds.min.x > f.bounds.max.x || u.bounds.max.y < f.bounds.min.y || u.bounds.min.y > f.bounds.max.y))) { var v = e._getRegion(h, u); if (!u.region || v.id !== u.region.id || a) { (!u.region || a) && (u.region = v); var m = e._regionUnion(v, u.region); for (s = m.startCol; s <= m.endCol; s++)for (i = m.startRow; i <= m.endRow; i++) { M = e._getBucketId(s, i), y = g[M]; var d = s >= v.startCol && s <= v.endCol && i >= v.startRow && i <= v.endRow, S = s >= u.region.startCol && s <= u.region.endCol && i >= u.region.startRow && i <= u.region.endRow; !d && S && S && y && e._bucketRemoveBody(h, y, u), (u.region === v || d && !S || a) && (y || (y = e._createBucket(g, M)), e._bucketAddBody(h, y, u)) } u.region = v, D = !0 } } } D && (h.pairsList = e._createActivePairsList(h)) }, r(e, "update", "Grid.update ➤ replaced by Matter.Detector"), e.clear = function (h) { h.buckets = {}, h.pairs = {}, h.pairsList = [] }, r(e, "clear", "Grid.clear ➤ replaced by Matter.Detector"), e._regionUnion = function (h, n) { var c = Math.min(h.startCol, n.startCol), a = Math.max(h.endCol, n.endCol), t = Math.min(h.startRow, n.startRow), s = Math.max(h.endRow, n.endRow); return e._createRegion(c, a, t, s) }, e._getRegion = function (h, n) { var c = n.bounds, a = Math.floor(c.min.x / h.bucketWidth), t = Math.floor(c.max.x / h.bucketWidth), s = Math.floor(c.min.y / h.bucketHeight), i = Math.floor(c.max.y / h.bucketHeight); return e._createRegion(a, t, s, i) }, e._createRegion = function (h, n, c, a) { return { id: h + "," + n + "," + c + "," + a, startCol: h, endCol: n, startRow: c, endRow: a } }, e._getBucketId = function (h, n) { return "C" + h + "R" + n }, e._createBucket = function (h, n) { var c = h[n] = []; return c }, e._bucketAddBody = function (h, n, c) { var a = h.pairs, t = l.id, s = n.length, i; for (i = 0; i < s; i++) { var f = n[i]; if (!(c.id === f.id || c.isStatic && f.isStatic)) { var g = t(c, f), y = a[g]; y ? y[2] += 1 : a[g] = [c, f, 1] } } n.push(c) }, e._bucketRemoveBody = function (h, n, c) { var a = h.pairs, t = l.id, s; n.splice(o.indexOf(n, c), 1); var i = n.length; for (s = 0; s < i; s++) { var f = a[t(c, n[s])]; f && (f[2] -= 1) } }, e._createActivePairsList = function (h) { var n, c = h.pairs, a = o.keys(c), t = a.length, s = [], i; for (i = 0; i < t; i++)n = c[a[i]], n[2] > 0 ? s.push(n) : delete c[a[i]]; return s } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(3), o = p(7), r = p(14), h = p(5), n = p(13), c = p(10), a = p(6), t = p(0), s = p(1); (function () { e.create = function (i, f) { var g = (i ? i.mouse : null) || (f ? f.mouse : null); g || (i && i.render && i.render.canvas ? g = r.create(i.render.canvas) : f && f.element ? g = r.create(f.element) : (g = r.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var y = c.create({ label: "Mouse Constraint", pointA: g.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), M = { type: "mouseConstraint", mouse: g, element: null, body: null, constraint: y, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, D = t.extend(M, f); return h.on(i, "beforeUpdate", function () { var u = a.allBodies(i.world); e.update(D, u), e._triggerEvents(D) }), D }, e.update = function (i, f) { var g = i.mouse, y = i.constraint, M = i.body; if (g.button === 0) { if (y.bodyB) o.set(y.bodyB, !1), y.pointA = g.position; else for (var D = 0; D < f.length; D++)if (M = f[D], s.contains(M.bounds, g.position) && n.canCollide(M.collisionFilter, i.collisionFilter)) for (var u = M.parts.length > 1 ? 1 : 0; u < M.parts.length; u++) { var v = M.parts[u]; if (l.contains(v.vertices, g.position)) { y.pointA = g.position, y.bodyB = i.body = M, y.pointB = { x: g.position.x - M.position.x, y: g.position.y - M.position.y }, y.angleB = M.angle, o.set(M, !1), h.trigger(i, "startdrag", { mouse: g, body: M }); break } } } else y.bodyB = i.body = null, y.pointB = null, M && h.trigger(i, "enddrag", { mouse: g, body: M }) }, e._triggerEvents = function (i) { var f = i.mouse, g = f.sourceEvents; g.mousemove && h.trigger(i, "mousemove", { mouse: f }), g.mousedown && h.trigger(i, "mousedown", { mouse: f }), g.mouseup && h.trigger(i, "mouseup", { mouse: f }), r.clearSourceEvents(f) } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(2), o = p(8), r = p(1), h = p(12), n = p(3); (function () { e.collides = function (c, a) { for (var t = [], s = a.length, i = c.bounds, f = o.collides, g = r.overlaps, y = 0; y < s; y++) { var M = a[y], D = M.parts.length, u = D === 1 ? 0 : 1; if (g(M.bounds, i)) for (var v = u; v < D; v++) { var m = M.parts[v]; if (g(m.bounds, i)) { var d = f(m, c); if (d) { t.push(d); break } } } } return t }, e.ray = function (c, a, t, s) { s = s || 1e-100; for (var i = l.angle(a, t), f = l.magnitude(l.sub(a, t)), g = (t.x + a.x) * .5, y = (t.y + a.y) * .5, M = h.rectangle(g, y, f, s, { angle: i }), D = e.collides(M, c), u = 0; u < D.length; u += 1) { var v = D[u]; v.body = v.bodyB = v.bodyA } return D }, e.region = function (c, a, t) { for (var s = [], i = 0; i < c.length; i++) { var f = c[i], g = r.overlaps(f.bounds, a); (g && !t || !g && t) && s.push(f) } return s }, e.point = function (c, a) { for (var t = [], s = 0; s < c.length; s++) { var i = c[s]; if (r.contains(i.bounds, a)) for (var f = i.parts.length === 1 ? 0 : 1; f < i.parts.length; f++) { var g = i.parts[f]; if (r.contains(g.bounds, a) && n.contains(g.vertices, a)) { t.push(i); break } } } return t } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(4), o = p(0), r = p(6), h = p(1), n = p(5), c = p(2), a = p(14); (function () { var t, s; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (u) { window.setTimeout(function () { u(o.now()) }, 1e3 / 60) }, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (u) { var v = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!u.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, m = o.extend(v, u); return m.canvas && (m.canvas.width = m.options.width || m.canvas.width, m.canvas.height = m.options.height || m.canvas.height), m.mouse = u.mouse, m.engine = u.engine, m.canvas = m.canvas || g(m.options.width, m.options.height), m.context = m.canvas.getContext("2d"), m.textures = {}, m.bounds = m.bounds || { min: { x: 0, y: 0 }, max: { x: m.canvas.width, y: m.canvas.height } }, m.controller = e, m.options.showBroadphase = !1, m.options.pixelRatio !== 1 && e.setPixelRatio(m, m.options.pixelRatio), o.isElement(m.element) && m.element.appendChild(m.canvas), m }, e.run = function (u) { (function v(m) { u.frameRequestId = t(v), i(u, m), e.world(u, m), u.context.setTransform(u.options.pixelRatio, 0, 0, u.options.pixelRatio, 0, 0), (u.options.showStats || u.options.showDebug) && e.stats(u, u.context, m), (u.options.showPerformance || u.options.showDebug) && e.performance(u, u.context, m), u.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (u) { s(u.frameRequestId) }, e.setPixelRatio = function (u, v) { var m = u.options, d = u.canvas; v === "auto" && (v = y(d)), m.pixelRatio = v, d.setAttribute("data-pixel-ratio", v), d.width = m.width * v, d.height = m.height * v, d.style.width = m.width + "px", d.style.height = m.height + "px" }, e.setSize = function (u, v, m) { u.options.width = v, u.options.height = m, u.bounds.max.x = u.bounds.min.x + v, u.bounds.max.y = u.bounds.min.y + m, u.options.pixelRatio !== 1 ? e.setPixelRatio(u, u.options.pixelRatio) : (u.canvas.width = v, u.canvas.height = m) }, e.lookAt = function (u, v, m, d) { d = typeof d < "u" ? d : !0, v = o.isArray(v) ? v : [v], m = m || { x: 0, y: 0 }; for (var S = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, x = 0; x < v.length; x += 1) { var C = v[x], P = C.bounds ? C.bounds.min : C.min || C.position || C, E = C.bounds ? C.bounds.max : C.max || C.position || C; P && E && (P.x < S.min.x && (S.min.x = P.x), E.x > S.max.x && (S.max.x = E.x), P.y < S.min.y && (S.min.y = P.y), E.y > S.max.y && (S.max.y = E.y)) } var B = S.max.x - S.min.x + 2 * m.x, I = S.max.y - S.min.y + 2 * m.y, R = u.canvas.height, L = u.canvas.width, F = L / R, k = B / I, W = 1, $ = 1; k > F ? $ = k / F : W = F / k, u.options.hasBounds = !0, u.bounds.min.x = S.min.x, u.bounds.max.x = S.min.x + B * W, u.bounds.min.y = S.min.y, u.bounds.max.y = S.min.y + I * $, d && (u.bounds.min.x += B * .5 - B * W * .5, u.bounds.max.x += B * .5 - B * W * .5, u.bounds.min.y += I * .5 - I * $ * .5, u.bounds.max.y += I * .5 - I * $ * .5), u.bounds.min.x -= m.x, u.bounds.max.x -= m.x, u.bounds.min.y -= m.y, u.bounds.max.y -= m.y, u.mouse && (a.setScale(u.mouse, { x: (u.bounds.max.x - u.bounds.min.x) / u.canvas.width, y: (u.bounds.max.y - u.bounds.min.y) / u.canvas.height }), a.setOffset(u.mouse, u.bounds.min)) }, e.startViewTransform = function (u) { var v = u.bounds.max.x - u.bounds.min.x, m = u.bounds.max.y - u.bounds.min.y, d = v / u.options.width, S = m / u.options.height; u.context.setTransform(u.options.pixelRatio / d, 0, 0, u.options.pixelRatio / S, 0, 0), u.context.translate(-u.bounds.min.x, -u.bounds.min.y) }, e.endViewTransform = function (u) { u.context.setTransform(u.options.pixelRatio, 0, 0, u.options.pixelRatio, 0, 0) }, e.world = function (u, v) { var m = o.now(), d = u.engine, S = d.world, x = u.canvas, C = u.context, P = u.options, E = u.timing, B = r.allBodies(S), I = r.allConstraints(S), R = P.wireframes ? P.wireframeBackground : P.background, L = [], F = [], k, W = { timestamp: d.timing.timestamp }; if (n.trigger(u, "beforeRender", W), u.currentBackground !== R && D(u, R), C.globalCompositeOperation = "source-in", C.fillStyle = "transparent", C.fillRect(0, 0, x.width, x.height), C.globalCompositeOperation = "source-over", P.hasBounds) { for (k = 0; k < B.length; k++) { var $ = B[k]; h.overlaps($.bounds, u.bounds) && L.push($) } for (k = 0; k < I.length; k++) { var U = I[k], G = U.bodyA, _ = U.bodyB, z = U.pointA, H = U.pointB; G && (z = c.add(G.position, U.pointA)), _ && (H = c.add(_.position, U.pointB)), !(!z || !H) && (h.contains(u.bounds, z) || h.contains(u.bounds, H)) && F.push(U) } e.startViewTransform(u), u.mouse && (a.setScale(u.mouse, { x: (u.bounds.max.x - u.bounds.min.x) / u.options.width, y: (u.bounds.max.y - u.bounds.min.y) / u.options.height }), a.setOffset(u.mouse, u.bounds.min)) } else F = I, L = B, u.options.pixelRatio !== 1 && u.context.setTransform(u.options.pixelRatio, 0, 0, u.options.pixelRatio, 0, 0); !P.wireframes || d.enableSleeping && P.showSleeping ? e.bodies(u, L, C) : (P.showConvexHulls && e.bodyConvexHulls(u, L, C), e.bodyWireframes(u, L, C)), P.showBounds && e.bodyBounds(u, L, C), (P.showAxes || P.showAngleIndicator) && e.bodyAxes(u, L, C), P.showPositions && e.bodyPositions(u, L, C), P.showVelocity && e.bodyVelocity(u, L, C), P.showIds && e.bodyIds(u, L, C), P.showSeparations && e.separations(u, d.pairs.list, C), P.showCollisions && e.collisions(u, d.pairs.list, C), P.showVertexNumbers && e.vertexNumbers(u, L, C), P.showMousePosition && e.mousePosition(u, u.mouse, C), e.constraints(F, C), P.hasBounds && e.endViewTransform(u), n.trigger(u, "afterRender", W), E.lastElapsed = o.now() - m }, e.stats = function (u, v, m) { for (var d = u.engine, S = d.world, x = r.allBodies(S), C = 0, P = 55, E = 44, B = 0, I = 0, R = 0; R < x.length; R += 1)C += x[R].parts.length; var L = { Part: C, Body: x.length, Cons: r.allConstraints(S).length, Comp: r.allComposites(S).length, Pair: d.pairs.list.length }; v.fillStyle = "#0e0f19", v.fillRect(B, I, P * 5.5, E), v.font = "12px Arial", v.textBaseline = "top", v.textAlign = "right"; for (var F in L) { var k = L[F]; v.fillStyle = "#aaa", v.fillText(F, B + P, I + 8), v.fillStyle = "#eee", v.fillText(k, B + P, I + 26), B += P } }, e.performance = function (u, v) { var m = u.engine, d = u.timing, S = d.deltaHistory, x = d.elapsedHistory, C = d.timestampElapsedHistory, P = d.engineDeltaHistory, E = d.engineUpdatesHistory, B = d.engineElapsedHistory, I = m.timing.lastUpdatesPerFrame, R = m.timing.lastDelta, L = f(S), F = f(x), k = f(P), W = f(E), $ = f(B), U = f(C), G = U / L || 0, _ = Math.round(L / R), z = 1e3 / L || 0, H = 4, J = 12, N = 60, oe = 34, X = 10, Z = 69; v.fillStyle = "#0e0f19", v.fillRect(0, 50, J * 5 + N * 6 + 22, oe), e.status(v, X, Z, N, H, S.length, Math.round(z) + " fps", z / e._goodFps, function (b) { return S[b] / L - 1 }), e.status(v, X + J + N, Z, N, H, P.length, R.toFixed(2) + " dt", e._goodDelta / R, function (b) { return P[b] / k - 1 }), e.status(v, X + (J + N) * 2, Z, N, H, E.length, I + " upf", Math.pow(o.clamp(W / _ || 1, 0, 1), 4), function (b) { return E[b] / W - 1 }), e.status(v, X + (J + N) * 3, Z, N, H, B.length, $.toFixed(2) + " ut", 1 - I * $ / e._goodFps, function (b) { return B[b] / $ - 1 }), e.status(v, X + (J + N) * 4, Z, N, H, x.length, F.toFixed(2) + " rt", 1 - F / e._goodFps, function (b) { return x[b] / F - 1 }), e.status(v, X + (J + N) * 5, Z, N, H, C.length, G.toFixed(2) + " x", G * G * G, function (b) { return (C[b] / S[b] / G || 0) - 1 }) }, e.status = function (u, v, m, d, S, x, C, P, E) { u.strokeStyle = "#888", u.fillStyle = "#444", u.lineWidth = 1, u.fillRect(v, m + 7, d, 1), u.beginPath(), u.moveTo(v, m + 7 - S * o.clamp(.4 * E(0), -2, 2)); for (var B = 0; B < d; B += 1)u.lineTo(v + B, m + 7 - (B < x ? S * o.clamp(.4 * E(B), -2, 2) : 0)); u.stroke(), u.fillStyle = "hsl(" + o.clamp(25 + 95 * P, 0, 120) + ",100%,60%)", u.fillRect(v, m - 7, 4, 4), u.font = "12px Arial", u.textBaseline = "middle", u.textAlign = "right", u.fillStyle = "#eee", u.fillText(C, v + d, m - 5) }, e.constraints = function (u, v) { for (var m = v, d = 0; d < u.length; d++) { var S = u[d]; if (!(!S.render.visible || !S.pointA || !S.pointB)) { var x = S.bodyA, C = S.bodyB, P, E; if (x ? P = c.add(x.position, S.pointA) : P = S.pointA, S.render.type === "pin") m.beginPath(), m.arc(P.x, P.y, 3, 0, 2 * Math.PI), m.closePath(); else { if (C ? E = c.add(C.position, S.pointB) : E = S.pointB, m.beginPath(), m.moveTo(P.x, P.y), S.render.type === "spring") for (var B = c.sub(E, P), I = c.perp(c.normalise(B)), R = Math.ceil(o.clamp(S.length / 5, 12, 20)), L, F = 1; F < R; F += 1)L = F % 2 === 0 ? 1 : -1, m.lineTo(P.x + B.x * (F / R) + I.x * L * 4, P.y + B.y * (F / R) + I.y * L * 4); m.lineTo(E.x, E.y) } S.render.lineWidth && (m.lineWidth = S.render.lineWidth, m.strokeStyle = S.render.strokeStyle, m.stroke()), S.render.anchors && (m.fillStyle = S.render.strokeStyle, m.beginPath(), m.arc(P.x, P.y, 3, 0, 2 * Math.PI), m.arc(E.x, E.y, 3, 0, 2 * Math.PI), m.closePath(), m.fill()) } } }, e.bodies = function (u, v, m) { var d = m; u.engine; var S = u.options, x = S.showInternalEdges || !S.wireframes, C, P, E, B; for (E = 0; E < v.length; E++)if (C = v[E], !!C.render.visible) { for (B = C.parts.length > 1 ? 1 : 0; B < C.parts.length; B++)if (P = C.parts[B], !!P.render.visible) { if (S.showSleeping && C.isSleeping ? d.globalAlpha = .5 * P.render.opacity : P.render.opacity !== 1 && (d.globalAlpha = P.render.opacity), P.render.sprite && P.render.sprite.texture && !S.wireframes) { var I = P.render.sprite, R = M(u, I.texture); d.translate(P.position.x, P.position.y), d.rotate(P.angle), d.drawImage(R, R.width * -I.xOffset * I.xScale, R.height * -I.yOffset * I.yScale, R.width * I.xScale, R.height * I.yScale), d.rotate(-P.angle), d.translate(-P.position.x, -P.position.y) } else { if (P.circleRadius) d.beginPath(), d.arc(P.position.x, P.position.y, P.circleRadius, 0, 2 * Math.PI); else { d.beginPath(), d.moveTo(P.vertices[0].x, P.vertices[0].y); for (var L = 1; L < P.vertices.length; L++)!P.vertices[L - 1].isInternal || x ? d.lineTo(P.vertices[L].x, P.vertices[L].y) : d.moveTo(P.vertices[L].x, P.vertices[L].y), P.vertices[L].isInternal && !x && d.moveTo(P.vertices[(L + 1) % P.vertices.length].x, P.vertices[(L + 1) % P.vertices.length].y); d.lineTo(P.vertices[0].x, P.vertices[0].y), d.closePath() } S.wireframes ? (d.lineWidth = 1, d.strokeStyle = u.options.wireframeStrokeStyle, d.stroke()) : (d.fillStyle = P.render.fillStyle, P.render.lineWidth && (d.lineWidth = P.render.lineWidth, d.strokeStyle = P.render.strokeStyle, d.stroke()), d.fill()) } d.globalAlpha = 1 } } }, e.bodyWireframes = function (u, v, m) { var d = m, S = u.options.showInternalEdges, x, C, P, E, B; for (d.beginPath(), P = 0; P < v.length; P++)if (x = v[P], !!x.render.visible) for (B = x.parts.length > 1 ? 1 : 0; B < x.parts.length; B++) { for (C = x.parts[B], d.moveTo(C.vertices[0].x, C.vertices[0].y), E = 1; E < C.vertices.length; E++)!C.vertices[E - 1].isInternal || S ? d.lineTo(C.vertices[E].x, C.vertices[E].y) : d.moveTo(C.vertices[E].x, C.vertices[E].y), C.vertices[E].isInternal && !S && d.moveTo(C.vertices[(E + 1) % C.vertices.length].x, C.vertices[(E + 1) % C.vertices.length].y); d.lineTo(C.vertices[0].x, C.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = u.options.wireframeStrokeStyle, d.stroke() }, e.bodyConvexHulls = function (u, v, m) { var d = m, S, x, C; for (d.beginPath(), x = 0; x < v.length; x++)if (S = v[x], !(!S.render.visible || S.parts.length === 1)) { for (d.moveTo(S.vertices[0].x, S.vertices[0].y), C = 1; C < S.vertices.length; C++)d.lineTo(S.vertices[C].x, S.vertices[C].y); d.lineTo(S.vertices[0].x, S.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = "rgba(255,255,255,0.2)", d.stroke() }, e.vertexNumbers = function (u, v, m) { var d = m, S, x, C; for (S = 0; S < v.length; S++) { var P = v[S].parts; for (C = P.length > 1 ? 1 : 0; C < P.length; C++) { var E = P[C]; for (x = 0; x < E.vertices.length; x++)d.fillStyle = "rgba(255,255,255,0.2)", d.fillText(S + "_" + x, E.position.x + (E.vertices[x].x - E.position.x) * .8, E.position.y + (E.vertices[x].y - E.position.y) * .8) } } }, e.mousePosition = function (u, v, m) { var d = m; d.fillStyle = "rgba(255,255,255,0.8)", d.fillText(v.position.x + "  " + v.position.y, v.position.x + 5, v.position.y - 5) }, e.bodyBounds = function (u, v, m) { var d = m; u.engine; var S = u.options; d.beginPath(); for (var x = 0; x < v.length; x++) { var C = v[x]; if (C.render.visible) for (var P = v[x].parts, E = P.length > 1 ? 1 : 0; E < P.length; E++) { var B = P[E]; d.rect(B.bounds.min.x, B.bounds.min.y, B.bounds.max.x - B.bounds.min.x, B.bounds.max.y - B.bounds.min.y) } } S.wireframes ? d.strokeStyle = "rgba(255,255,255,0.08)" : d.strokeStyle = "rgba(0,0,0,0.1)", d.lineWidth = 1, d.stroke() }, e.bodyAxes = function (u, v, m) { var d = m; u.engine; var S = u.options, x, C, P, E; for (d.beginPath(), C = 0; C < v.length; C++) { var B = v[C], I = B.parts; if (B.render.visible) if (S.showAxes) for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (x = I[P], E = 0; E < x.axes.length; E++) { var R = x.axes[E]; d.moveTo(x.position.x, x.position.y), d.lineTo(x.position.x + R.x * 20, x.position.y + R.y * 20) } else for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (x = I[P], E = 0; E < x.axes.length; E++)d.moveTo(x.position.x, x.position.y), d.lineTo((x.vertices[0].x + x.vertices[x.vertices.length - 1].x) / 2, (x.vertices[0].y + x.vertices[x.vertices.length - 1].y) / 2) } S.wireframes ? (d.strokeStyle = "indianred", d.lineWidth = 1) : (d.strokeStyle = "rgba(255, 255, 255, 0.4)", d.globalCompositeOperation = "overlay", d.lineWidth = 2), d.stroke(), d.globalCompositeOperation = "source-over" }, e.bodyPositions = function (u, v, m) { var d = m; u.engine; var S = u.options, x, C, P, E; for (d.beginPath(), P = 0; P < v.length; P++)if (x = v[P], !!x.render.visible) for (E = 0; E < x.parts.length; E++)C = x.parts[E], d.arc(C.position.x, C.position.y, 3, 0, 2 * Math.PI, !1), d.closePath(); for (S.wireframes ? d.fillStyle = "indianred" : d.fillStyle = "rgba(0,0,0,0.5)", d.fill(), d.beginPath(), P = 0; P < v.length; P++)x = v[P], x.render.visible && (d.arc(x.positionPrev.x, x.positionPrev.y, 2, 0, 2 * Math.PI, !1), d.closePath()); d.fillStyle = "rgba(255,165,0,0.8)", d.fill() }, e.bodyVelocity = function (u, v, m) { var d = m; d.beginPath(); for (var S = 0; S < v.length; S++) { var x = v[S]; if (x.render.visible) { var C = l.getVelocity(x); d.moveTo(x.position.x, x.position.y), d.lineTo(x.position.x + C.x, x.position.y + C.y) } } d.lineWidth = 3, d.strokeStyle = "cornflowerblue", d.stroke() }, e.bodyIds = function (u, v, m) { var d = m, S, x; for (S = 0; S < v.length; S++)if (v[S].render.visible) { var C = v[S].parts; for (x = C.length > 1 ? 1 : 0; x < C.length; x++) { var P = C[x]; d.font = "12px Arial", d.fillStyle = "rgba(255,255,255,0.5)", d.fillText(P.id, P.position.x + 10, P.position.y - 10) } } }, e.collisions = function (u, v, m) { var d = m, S = u.options, x, C, P, E; for (d.beginPath(), P = 0; P < v.length; P++)if (x = v[P], !!x.isActive) for (C = x.collision, E = 0; E < x.contactCount; E++) { var B = x.contacts[E], I = B.vertex; d.rect(I.x - 1.5, I.y - 1.5, 3.5, 3.5) } for (S.wireframes ? d.fillStyle = "rgba(255,255,255,0.7)" : d.fillStyle = "orange", d.fill(), d.beginPath(), P = 0; P < v.length; P++)if (x = v[P], !!x.isActive && (C = x.collision, x.contactCount > 0)) { var R = x.contacts[0].vertex.x, L = x.contacts[0].vertex.y; x.contactCount === 2 && (R = (x.contacts[0].vertex.x + x.contacts[1].vertex.x) / 2, L = (x.contacts[0].vertex.y + x.contacts[1].vertex.y) / 2), C.bodyB === C.supports[0].body || C.bodyA.isStatic === !0 ? d.moveTo(R - C.normal.x * 8, L - C.normal.y * 8) : d.moveTo(R + C.normal.x * 8, L + C.normal.y * 8), d.lineTo(R, L) } S.wireframes ? d.strokeStyle = "rgba(255,165,0,0.7)" : d.strokeStyle = "orange", d.lineWidth = 1, d.stroke() }, e.separations = function (u, v, m) { var d = m, S = u.options, x, C, P, E, B; for (d.beginPath(), B = 0; B < v.length; B++)if (x = v[B], !!x.isActive) { C = x.collision, P = C.bodyA, E = C.bodyB; var I = 1; !E.isStatic && !P.isStatic && (I = .5), E.isStatic && (I = 0), d.moveTo(E.position.x, E.position.y), d.lineTo(E.position.x - C.penetration.x * I, E.position.y - C.penetration.y * I), I = 1, !E.isStatic && !P.isStatic && (I = .5), P.isStatic && (I = 0), d.moveTo(P.position.x, P.position.y), d.lineTo(P.position.x + C.penetration.x * I, P.position.y + C.penetration.y * I) } S.wireframes ? d.strokeStyle = "rgba(255,165,0,0.5)" : d.strokeStyle = "orange", d.stroke() }, e.inspector = function (u, v) { u.engine; var m = u.selected, d = u.render, S = d.options, x; if (S.hasBounds) { var C = d.bounds.max.x - d.bounds.min.x, P = d.bounds.max.y - d.bounds.min.y, E = C / d.options.width, B = P / d.options.height; v.scale(1 / E, 1 / B), v.translate(-d.bounds.min.x, -d.bounds.min.y) } for (var I = 0; I < m.length; I++) { var R = m[I].data; switch (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.9)", v.setLineDash([1, 2]), R.type) { case "body": x = R.bounds, v.beginPath(), v.rect(Math.floor(x.min.x - 3), Math.floor(x.min.y - 3), Math.floor(x.max.x - x.min.x + 6), Math.floor(x.max.y - x.min.y + 6)), v.closePath(), v.stroke(); break; case "constraint": var L = R.pointA; R.bodyA && (L = R.pointB), v.beginPath(), v.arc(L.x, L.y, 10, 0, 2 * Math.PI), v.closePath(), v.stroke(); break }v.setLineDash([]), v.translate(-.5, -.5) } u.selectStart !== null && (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.6)", v.fillStyle = "rgba(255,165,0,0.1)", x = u.selectBounds, v.beginPath(), v.rect(Math.floor(x.min.x), Math.floor(x.min.y), Math.floor(x.max.x - x.min.x), Math.floor(x.max.y - x.min.y)), v.closePath(), v.stroke(), v.fill(), v.translate(-.5, -.5)), S.hasBounds && v.setTransform(1, 0, 0, 1, 0, 0) }; var i = function (u, v) { var m = u.engine, d = u.timing, S = d.historySize, x = m.timing.timestamp; d.delta = v - d.lastTime || e._goodDelta, d.lastTime = v, d.timestampElapsed = x - d.lastTimestamp || 0, d.lastTimestamp = x, d.deltaHistory.unshift(d.delta), d.deltaHistory.length = Math.min(d.deltaHistory.length, S), d.engineDeltaHistory.unshift(m.timing.lastDelta), d.engineDeltaHistory.length = Math.min(d.engineDeltaHistory.length, S), d.timestampElapsedHistory.unshift(d.timestampElapsed), d.timestampElapsedHistory.length = Math.min(d.timestampElapsedHistory.length, S), d.engineUpdatesHistory.unshift(m.timing.lastUpdatesPerFrame), d.engineUpdatesHistory.length = Math.min(d.engineUpdatesHistory.length, S), d.engineElapsedHistory.unshift(m.timing.lastElapsed), d.engineElapsedHistory.length = Math.min(d.engineElapsedHistory.length, S), d.elapsedHistory.unshift(d.lastElapsed), d.elapsedHistory.length = Math.min(d.elapsedHistory.length, S) }, f = function (u) { for (var v = 0, m = 0; m < u.length; m += 1)v += u[m]; return v / u.length || 0 }, g = function (u, v) { var m = document.createElement("canvas"); return m.width = u, m.height = v, m.oncontextmenu = function () { return !1 }, m.onselectstart = function () { return !1 }, m }, y = function (u) { var v = u.getContext("2d"), m = window.devicePixelRatio || 1, d = v.webkitBackingStorePixelRatio || v.mozBackingStorePixelRatio || v.msBackingStorePixelRatio || v.oBackingStorePixelRatio || v.backingStorePixelRatio || 1; return m / d }, M = function (u, v) { var m = u.textures[v]; return m || (m = u.textures[v] = new Image, m.src = v, m) }, D = function (u, v) { var m = v; /(jpg|gif|png)$/.test(v) && (m = "url(" + v + ")"), u.canvas.style.background = m, u.canvas.style.backgroundSize = "contain", u.currentBackground = v } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(5), o = p(17), r = p(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (n) { var c = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, a = r.extend(c, n); return a.fps = 0, a }, e.run = function (n, c) { return n.timeBuffer = e._frameDeltaFallback, function a(t) { n.frameRequestId = e._onNextFrame(n, a), t && n.enabled && e.tick(n, c, t) }(), n }, e.tick = function (n, c, a) { var t = r.now(), s = n.delta, i = 0, f = a - n.timeLastTick; if ((!f || !n.timeLastTick || f > Math.max(e._maxFrameDelta, n.maxFrameTime)) && (f = n.frameDelta || e._frameDeltaFallback), n.frameDeltaSmoothing) { n.frameDeltaHistory.push(f), n.frameDeltaHistory = n.frameDeltaHistory.slice(-n.frameDeltaHistorySize); var g = n.frameDeltaHistory.slice(0).sort(), y = n.frameDeltaHistory.slice(g.length * e._smoothingLowerBound, g.length * e._smoothingUpperBound), M = h(y); f = M || f } n.frameDeltaSnapping && (f = 1e3 / Math.round(1e3 / f)), n.frameDelta = f, n.timeLastTick = a, n.timeBuffer += n.frameDelta, n.timeBuffer = r.clamp(n.timeBuffer, 0, n.frameDelta + s * e._timeBufferMargin), n.lastUpdatesDeferred = 0; var D = n.maxUpdates || Math.ceil(n.maxFrameTime / s), u = { timestamp: c.timing.timestamp }; l.trigger(n, "beforeTick", u), l.trigger(n, "tick", u); for (var v = r.now(); s > 0 && n.timeBuffer >= s * e._timeBufferMargin;) { l.trigger(n, "beforeUpdate", u), o.update(c, s), l.trigger(n, "afterUpdate", u), n.timeBuffer -= s, i += 1; var m = r.now() - t, d = r.now() - v, S = m + e._elapsedNextEstimate * d / i; if (i >= D || S > n.maxFrameTime) { n.lastUpdatesDeferred = Math.round(Math.max(0, n.timeBuffer / s - e._timeBufferMargin)); break } } c.timing.lastUpdatesPerFrame = i, l.trigger(n, "afterTick", u), n.frameDeltaHistory.length >= 100 && (n.lastUpdatesDeferred && Math.round(n.frameDelta / s) > D ? r.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : n.lastUpdatesDeferred && r.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof n.isFixed < "u" && r.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (n.deltaMin || n.deltaMax) && r.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), n.fps !== 0 && r.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (n) { e._cancelNextFrame(n) }, e._onNextFrame = function (n, c) { if (typeof window < "u" && window.requestAnimationFrame) n.frameRequestId = window.requestAnimationFrame(c); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return n.frameRequestId }, e._cancelNextFrame = function (n) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(n.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var h = function (n) { for (var c = 0, a = n.length, t = 0; t < a; t += 1)c += n[t]; return c / a || 0 } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(8), o = p(0), r = o.deprecated; (function () { e.collides = function (h, n) { return l.collides(h, n) }, r(e, "collides", "SAT.collides ➤ replaced by Collision.collides") })() }, function (w, O, p) { var e = {}; w.exports = e, p(1); var l = p(0); (function () { e.pathToVertices = function (o, r) { typeof window < "u" && !("SVGPathSeg" in window) && l.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var h, n, c, a, t, s, i, f, g, y, M = [], D, u, v = 0, m = 0, d = 0; r = r || 15; var S = function (C, P, E) { var B = E % 2 === 1 && E > 1; if (!g || C != g.x || P != g.y) { g && B ? (D = g.x, u = g.y) : (D = 0, u = 0); var I = { x: D + C, y: u + P }; (B || !g) && (g = I), M.push(I), m = D + C, d = u + P } }, x = function (C) { var P = C.pathSegTypeAsLetter.toUpperCase(); if (P !== "Z") { switch (P) { case "M": case "L": case "T": case "C": case "S": case "Q": m = C.x, d = C.y; break; case "H": m = C.x; break; case "V": d = C.y; break }S(m, d, C.pathSegType) } }; for (e._svgPathToAbsolute(o), c = o.getTotalLength(), s = [], h = 0; h < o.pathSegList.numberOfItems; h += 1)s.push(o.pathSegList.getItem(h)); for (i = s.concat(); v < c;) { if (y = o.getPathSegAtLength(v), t = s[y], t != f) { for (; i.length && i[0] != t;)x(i.shift()); f = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": a = o.getPointAtLength(v), S(a.x, a.y, 0); break }v += r } for (h = 0, n = i.length; h < n; ++h)x(i[h]); return M }, e._svgPathToAbsolute = function (o) { for (var r, h, n, c, a, t, s = o.pathSegList, i = 0, f = 0, g = s.numberOfItems, y = 0; y < g; ++y) { var M = s.getItem(y), D = M.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(D)) "x" in M && (i = M.x), "y" in M && (f = M.y); else switch ("x1" in M && (n = i + M.x1), "x2" in M && (a = i + M.x2), "y1" in M && (c = f + M.y1), "y2" in M && (t = f + M.y2), "x" in M && (i += M.x), "y" in M && (f += M.y), D) { case "m": s.replaceItem(o.createSVGPathSegMovetoAbs(i, f), y); break; case "l": s.replaceItem(o.createSVGPathSegLinetoAbs(i, f), y); break; case "h": s.replaceItem(o.createSVGPathSegLinetoHorizontalAbs(i), y); break; case "v": s.replaceItem(o.createSVGPathSegLinetoVerticalAbs(f), y); break; case "c": s.replaceItem(o.createSVGPathSegCurvetoCubicAbs(i, f, n, c, a, t), y); break; case "s": s.replaceItem(o.createSVGPathSegCurvetoCubicSmoothAbs(i, f, a, t), y); break; case "q": s.replaceItem(o.createSVGPathSegCurvetoQuadraticAbs(i, f, n, c), y); break; case "t": s.replaceItem(o.createSVGPathSegCurvetoQuadraticSmoothAbs(i, f), y); break; case "a": s.replaceItem(o.createSVGPathSegArcAbs(i, f, M.r1, M.r2, M.angle, M.largeArcFlag, M.sweepFlag), y); break; case "z": case "Z": i = r, f = h; break }(D == "M" || D == "m") && (r = i, h = f) } } })() }, function (w, O, p) { var e = {}; w.exports = e; var l = p(6); p(0), function () { e.create = l.create, e.add = l.add, e.remove = l.remove, e.clear = l.clear, e.addComposite = l.addComposite, e.addBody = l.addBody, e.addConstraint = l.addConstraint }() }]) }) })(yt); const K = at(ee); class St { constructor(A) { V(this, "widthCanvas", document.body.clientWidth); V(this, "heightCanvas", re(137)); V(this, "DOM"); V(this, "dataImgs", []); V(this, "MatterJS"); this.DOM = { el: A }, this.MatterJS = { Engine: void 0, Render: void 0 }, A == null || A.querySelectorAll(".home-bubble-item").forEach(w => { var p; const O = (p = w.querySelector("img")) == null ? void 0 : p.getAttribute("src"); O && this.dataImgs.push(O), w.style.pointerEvents = "none", w.style.opacity = "0" }) } render() { var p, e, l, o; this.init(); const A = K.Runner.create(), w = (e = (p = this.MatterJS).Engine) == null ? void 0 : e.call(p), O = (o = (l = this.MatterJS).Render) == null ? void 0 : o.call(l); We.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !w || !O || (K.Render.run(O), K.Runner.run(A, w)) } }) } init() { const A = re(13.3), w = re(13.3) / 133, O = 293 / 133, p = K.Engine.create(), e = K.Render.create({ element: this.DOM.el, engine: p, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), l = t => { if (t * A < window.innerWidth) return { x: t * A, y: -50 }; { const s = -Math.ceil(t * A / window.innerWidth) * 200; return { x: Math.abs(window.innerWidth - A * t), y: s } } }; for (let t = 0; t < this.dataImgs.length; t++) { const { x: s, y: i } = l(t), f = ee.Bodies.circle(s, i, A, { friction: .1, frictionAir: 0, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[t], xScale: w, yScale: w } } }); K.Composite.add(p.world, f) } const o = ee.Bodies.circle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight / 2 + A * O / 2.4, A * O, { render: { fillStyle: "transparent" }, isStatic: !0 }), r = ee.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight + this.dataImgs.length / 2, 27184, this.dataImgs.length, { isStatic: !0 }), h = ee.Bodies.rectangle(0 - this.dataImgs.length / 2, this.DOM.el.clientHeight / 2, this.dataImgs.length, this.DOM.el.clientHeight * 5, { isStatic: !0 }), n = ee.Bodies.rectangle(this.DOM.el.clientWidth + this.dataImgs.length / 2, this.DOM.el.clientHeight / 2, this.dataImgs.length, this.DOM.el.clientHeight * 5, { isStatic: !0 }); K.Composite.add(p.world, [r, h, n, o]); const c = K.Mouse.create(e.canvas), a = K.MouseConstraint.create(p, { mouse: c, constraint: { stiffness: .2, render: { visible: !1 } } }); K.Composite.add(p.world, a), c.element.removeEventListener("wheel", c.mousewheel), c.element.removeEventListener("DOMMouseScroll", c.mousewheel), this.MatterJS.Render = () => e, this.MatterJS.Engine = () => p } } (() => { function T(...O) { const p = O.length; for (let e = 0; e < p; e++) { const l = O[e]; l.nodeType === 1 || l.nodeType === 11 ? this.appendChild(l) : this.appendChild(document.createTextNode(String(l))) } } function A(...O) { for (; this.lastChild;)this.removeChild(this.lastChild); O.length && this.append(...O) } function w(...O) { const p = this.parentNode; let e = O.length; if (p) for (e || p.removeChild(this); e--;) { let l = O[e]; typeof l != "object" ? l = this.ownerDocument.createTextNode(l) : l.parentNode && l.parentNode.removeChild(l), e ? p.insertBefore(this.previousSibling, l) : p.replaceChild(l, this) } } typeof Element < "u" && (Element.prototype.append || (Element.prototype.append = T, DocumentFragment.prototype.append = T), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = A, DocumentFragment.prototype.replaceChildren = A), Element.prototype.replaceWith || (Element.prototype.replaceWith = w, DocumentFragment.prototype.replaceWith = w)) })(); function te(T, A) { return Object.getOwnPropertyNames(Object(T)).reduce((w, O) => { const p = Object.getOwnPropertyDescriptor(Object(T), O), e = Object.getOwnPropertyDescriptor(Object(A), O); return Object.defineProperty(w, O, e || p) }, {}) } function le(T) { return typeof T == "string" } function Pe(T) { return Array.isArray(T) } function he(T = {}) { const A = te(T); let w; return A.types !== void 0 ? w = A.types : A.split !== void 0 && (w = A.split), w !== void 0 && (A.types = (le(w) || Pe(w) ? String(w) : "").split(",").map(O => String(O).trim()).filter(O => /((line)|(word)|(char))/i.test(O))), (A.absolute || A.position) && (A.absolute = A.absolute || /absolute/.test(T.position)), A } function De(T) { const A = le(T) || Pe(T) ? String(T) : ""; return { none: !A, lines: /line/i.test(A), words: /word/i.test(A), chars: /char/i.test(A) } } function de(T) { return T !== null && typeof T == "object" } function wt(T) { return de(T) && /^(1|3|11)$/.test(T.nodeType) } function Mt(T) { return typeof T == "number" && T > -1 && T % 1 === 0 } function Ct(T) { return de(T) && Mt(T.length) } function ie(T) { return Pe(T) ? T : T == null ? [] : Ct(T) ? Array.prototype.slice.call(T) : [T] } function ke(T) { let A = T; return le(T) && (/^(#[a-z]\w+)$/.test(T.trim()) ? A = document.getElementById(T.trim().slice(1)) : A = document.querySelectorAll(T)), ie(A).reduce((w, O) => [...w, ...ie(O).filter(wt)], []) } const { entries: Pt, keys: an, values: on } = Object, pe = "_splittype", q = {}; let Dt = 0; function Y(T, A, w) { if (!de(T)) return console.warn("[data.set] owner is not an object"), null; const O = T[pe] || (T[pe] = ++Dt), p = q[O] || (q[O] = {}); return w === void 0 ? A && Object.getPrototypeOf(A) === Object.prototype && (q[O] = { ...p, ...A }) : A !== void 0 && (p[A] = w), w } function ne(T, A) { const w = de(T) ? T[pe] : null, O = w && q[w] || {}; return A === void 0 ? O : O[A] } function Ue(T) { const A = T && T[pe]; A && (delete T[A], delete q[A]) } function At() { Pt(q).forEach(([T, { isRoot: A, isSplit: w }]) => { (!A || !w) && (q[T] = null, delete q[T]) }) } function Tt(T, A = " ") { return (T ? String(T) : "").trim().replace(/\s+/g, " ").split(A) } const Ae = "\\ud800-\\udfff", Ne = "\\u0300-\\u036f\\ufe20-\\ufe23", Ge = "\\u20d0-\\u20f0", be = "\\ufe0e\\ufe0f", Ot = `[${Ae}]`, we = `[${Ne}${Ge}]`, Me = "\\ud83c[\\udffb-\\udfff]", Et = `(?:${we}|${Me})`, ze = `[^${Ae}]`, Je = "(?:\\ud83c[\\udde6-\\uddff]){2}", Qe = "[\\ud800-\\udbff][\\udc00-\\udfff]", Xe = "\\u200d", Ze = `${Et}?`, Ke = `[${be}]?`, It = "(?:" + Xe + "(?:" + [ze, Je, Qe].join("|") + ")" + Ke + Ze + ")*", Bt = Ke + Ze + It, Lt = `(?:${[`${ze}${we}?`, we, Je, Qe, Ot].join("|")}
)`, Rt = RegExp(`${Me}(?=${Me})|${Lt}${Bt}`, "g"), Ft = [Xe, Ae, Ne, Ge, be], Ht = RegExp(`[${Ft.join("")}]`); function kt(T) { return T.split("") } function Ye(T) { return Ht.test(T) } function Vt(T) { return T.match(Rt) || [] } function Wt(T) { return Ye(T) ? Vt(T) : kt(T) } function $t(T) { return T == null ? "" : String(T) } function Ut(T, A = "") { return T = $t(T), T && le(T) && !A && Ye(T) ? Wt(T) : T.split(A) } function Ce(T, A) { const w = document.createElement(T); return A && Object.keys(A).forEach(O => { const p = A[O], e = le(p) ? p.trim() : p; e === null || e === "" || (O === "children" ? w.append(...ie(e)) : w.setAttribute(O, e)) }), w } var Te = { splitClass: "", lineClass: "line", wordClass: "word", charClass: "char", types: ["lines", "words", "chars"], absolute: !1, tagName: "div" }; function Nt(T, A) { A = te(Te, A); const w = De(A.types), O = A.tagName, p = T.nodeValue, e = document.createDocumentFragment(); let l = [], o = []; return /^\s/.test(p) && e.append(" "), l = Tt(p).reduce((r, h, n, c) => { let a, t; return w.chars && (t = Ut(h).map(s => { const i = Ce(O, { class: `${A.splitClass} ${A.charClass}`, style: "display: inline-block;", children: s }); return Y(i, "isChar", !0), o = [...o, i], i })), w.words || w.lines ? (a = Ce(O, { class: `${A.wordClass} ${A.splitClass}`, style: `display: inline-block; ${w.words && A.absolute ? "position: relative;" : ""}`, children: w.chars ? t : h }), Y(a, { isWord: !0, isWordStart: !0, isWordEnd: !0 }), e.appendChild(a)) : t.forEach(s => { e.appendChild(s) }), n < c.length - 1 && e.append(" "), w.words ? r.concat(a) : r }, []), /\s$/.test(p) && e.append(" "), T.replaceWith(e), { words: l, chars: o } } function je(T, A) { const w = T.nodeType, O = { words: [], chars: [] }; if (!/(1|3|11)/.test(w)) return O; if (w === 3 && /\S/.test(T.nodeValue)) return Nt(T, A); const p = ie(T.childNodes); if (p.length && (Y(T, "isSplit", !0), !ne(T).isRoot)) { T.style.display = "inline-block", T.style.position = "relative"; const e = T.nextSibling, l = T.previousSibling, o = T.textContent || "", r = e ? e.textContent : " ", h = l ? l.textContent : " "; Y(T, { isWordEnd: /\s$/.test(o) || /^\s/.test(r), isWordStart: /^\s/.test(o) || /\s$/.test(h) }) } return p.reduce((e, l) => { const { words: o, chars: r } = je(l, A); return { words: [...e.words, ...o], chars: [...e.chars, ...r] } }, O) } function Gt(T, A, w, O) { if (!w.absolute) return { top: A ? T.offsetTop : null }; const p = T.offsetParent, [e, l] = O; let o = 0, r = 0; if (p && p !== document.body) { const i = p.getBoundingClientRect(); o = i.x + e, r = i.y + l } const { width: h, height: n, x: c, y: a } = T.getBoundingClientRect(), t = a + l - r, s = c + e - o; return { width: h, height: n, top: t, left: s } } function qe(T) { ne(T).isWord ? (Ue(T), T.replaceWith(...T.childNodes)) : ie(T.children).forEach(A => qe(A)) } const bt = () => document.createDocumentFragment(); function zt(T, A, w) { const O = De(A.types), p = A.tagName, e = T.getElementsByTagName("*"), l = []; let o = [], r = null, h, n, c, a = []; const t = T.parentElement, s = T.nextElementSibling, i = bt(), f = window.getComputedStyle(T), g = f.textAlign, M = parseFloat(f.fontSize) * .2; return A.absolute && (c = { left: T.offsetLeft, top: T.offsetTop, width: T.offsetWidth }, n = T.offsetWidth, h = T.offsetHeight, Y(T, { cssWidth: T.style.width, cssHeight: T.style.height })), ie(e).forEach(D => { const u = D.parentElement === T, { width: v, height: m, top: d, left: S } = Gt(D, u, A, w); /^br$/i.test(D.nodeName) || (O.lines && u && ((r === null || d - r >= M) && (r = d, l.push(o = [])), o.push(D)), A.absolute && Y(D, { top: d, left: S, width: v, height: m })) }), t && t.removeChild(T), O.lines && (a = l.map(D => { const u = Ce(p, { class: `${A.splitClass} ${A.lineClass}`, style: `display: block; text-align: ${g}; width: 100%;` }); Y(u, "isLine", !0); const v = { height: 0, top: 1e4 }; return i.appendChild(u), D.forEach((m, d, S) => { const { isWordEnd: x, top: C, height: P } = ne(m), E = S[d + 1]; v.height = Math.max(v.height, P), v.top = Math.min(v.top, C), u.appendChild(m), x && ne(E).isWordStart && u.append(" ") }), A.absolute && Y(u, { height: v.height, top: v.top }), u }), O.words || qe(i), T.replaceChildren(i)), A.absolute && (T.style.width = `${T.style.width || n}px`, T.style.height = `${h}px`, ie(e).forEach(D => { const { isLine: u, top: v, left: m, width: d, height: S } = ne(D), x = ne(D.parentElement), C = !u && x.isLine; D.style.top = `${C ? v - x.top : v}px`, D.style.left = u ? `${c.left}px` : `${m - (C ? c.left : 0)}px`, D.style.height = `${S}px`, D.style.width = u ? `${c.width}px` : `${d}px`, D.style.position = "absolute" })), t && (s ? t.insertBefore(T, s) : t.appendChild(T)), a } let se = te(Te, {}); class ae { static get data() { return q } static get defaults() { return se } static set defaults(A) { se = te(se, he(A)) } static setDefaults(A) { return se = te(se, he(A)), Te } static revert(A) { ke(A).forEach(w => { const { isSplit: O, html: p, cssWidth: e, cssHeight: l } = ne(w); O && (w.innerHTML = p, w.style.width = e || "", w.style.height = l || "", Ue(w)) }) } static create(A, w) { return new ae(A, w) } constructor(A, w) { this.isSplit = !1, this.settings = te(se, he(w)), this.elements = ke(A), this.split() } split(A) { this.revert(), this.elements.forEach(p => { Y(p, "html", p.innerHTML) }), this.lines = [], this.words = [], this.chars = []; const w = [window.pageXOffset, window.pageYOffset]; A !== void 0 && (this.settings = te(this.settings, he(A))); const O = De(this.settings.types); O.none || (this.elements.forEach(p => { Y(p, "isRoot", !0); const { words: e, chars: l } = je(p, this.settings); this.words = [...this.words, ...e], this.chars = [...this.chars, ...l] }), this.elements.forEach(p => { if (O.lines || this.settings.absolute) { const e = zt(p, this.settings, w); this.lines = [...this.lines, ...e] } }), this.isSplit = !0, window.scrollTo(w[0], w[1]), At()) } revert() { this.isSplit && (this.lines = null, this.words = null, this.chars = null, this.isSplit = !1), ae.revert(this.elements) } } class Oe { constructor({ element: A, options: w, play: O, pause: p, init: e }) { V(this, "DOM"); V(this, "options"); V(this, "playAnimation"); V(this, "pauseAnimation"); V(this, "initAnimation"); this.DOM = { el: A }, this.initAnimation = e, this.playAnimation = O, this.pauseAnimation = p, this.options = w, this.init(), this.play() } init() { this.initAnimation() } play() { var O, p, e, l, o; const A = ot({ element: this.DOM.el, delayEnter: (O = this.options) == null ? void 0 : O.delayEnter, delayTrigger: (p = this.options) == null ? void 0 : p.delayTrigger }), w = lt({ element: this.DOM.el, threshold: (e = this.options) == null ? void 0 : e.threshold }); if ((l = this.options) != null && l.isOpserver) { if (!this.DOM.el) return; const r = new IntersectionObserver(h => { var n, c; if (h[0].isIntersecting) this.playAnimation({ delay: A }); else { const a = (n = this.DOM.el) == null ? void 0 : n.getBoundingClientRect(); a && a.top < 0 && ((c = this.DOM.el) == null || c.classList.add("animated"), this.DOM.el && (r == null || r.unobserve(this.DOM.el)), r == null || r.disconnect()) } }, { threshold: w / 100 }); r == null || r.observe(this.DOM.el) } else this.playAnimation({ scrollTrigger: { trigger: this.DOM.el, start: ((o = this.options) == null ? void 0 : o.start) || `top+=${w}% bottom`, once: !0 }, delay: A }) } reset() { console.log("reset") } } const Jt = "_counter_7lgos_1", Qt = "_counter_text_7lgos_4", Xt = "_textSpacing_7lgos_32", ye = { counter: Jt, counter_text: Qt, textSpacing: Xt }; class Zt {
    constructor(A, w) { V(this, "DOM"); this.DOM = { el: A, listChars: [] }, new Oe({ element: this.DOM.el, init: this.init.bind(this), play: this.play.bind(this), options: w }) } init() {
        const A = new ae(this.DOM.el, { types: "chars, chars" }); this.DOM.el.classList.add(ye.counter); const w = A.chars; if (w != null && w.length) for (const O in w) {
            const p = w[O], e = document.createElement("span"), l = p.innerText === "1"; if (e.classList.add(ye.counter_text), l && p.classList.add("char__one"), !isNaN(parseFloat(p.innerText))) {
                const o = parseFloat(p.innerText); e.insertAdjacentHTML("beforeend", `<span data-value="${o}"
                  class=${l ? `${ye.textSpacing}` : ""}>
                  <span>&ndash;</span>
                        ${Array(o + 1).join("0").split("0").map((h, n) => `
                                <span>
                                ${n}
                                </span>
                            `).join("")}
        			</span>`), p.removeChild(p.firstChild), p.appendChild(e); const r = e.querySelector("span[data-value]"); this.DOM.listChars.push(r)
            }
        }
    } play(A) { Q.to(this.DOM.listChars, { duration: 1.2, ease: "power1", y: (w, O) => `-${(parseInt(O.getAttribute("data-value") || "0") + 1) * 100}%`, stagger: { amount: .025, from: "end" }, ...A }) }
} const Kt = "_text__fade_1smbx_1", Yt = { text__fade: Kt }; class jt { constructor(A, w) { V(this, "DOM"); V(this, "animation"); this.DOM = { el: A, splitType: new ae(A, { types: "words, lines" }) }, this.animation = null, new Oe({ element: this.DOM.el, options: w, play: this.play.bind(this), pause: this.revert.bind(this), init: this.init.bind(this) }) } init() { var A; this.DOM.el.classList.add(Yt.text__fade), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(w => { const O = document.createElement("div"); O.appendChild(w), O.classList.add("line__fade"), this.DOM.el.appendChild(O) }), (A = this.DOM.splitType.lines) != null && A.length && Q.set(this.DOM.splitType.lines, { yPercent: 100, opacity: 0 }) } play(A) { this.animation = Q.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3.out", opacity: 1, stagger: .1, ...A }) } revert() { this.animation && this.animation.revert() } } const qt = "_text__mask_170lx_1", _t = { text__mask: qt }; class en { constructor(A, w) { V(this, "DOM"); V(this, "animation"); this.DOM = { el: A, splitType: new ae(A, { types: "words, lines" }) }, this.animation = null, new Oe({ element: this.DOM.el, options: w, play: this.play.bind(this), pause: this.revert.bind(this), init: this.init.bind(this) }) } init() { var A; this.DOM.el.classList.add(_t.text__mask), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(w => { const O = document.createElement("div"); O.appendChild(w), O.classList.add("line__mask"), this.DOM.el.appendChild(O) }), (A = this.DOM.splitType.lines) != null && A.length && Q.set(this.DOM.splitType.lines, { yPercent: 100 }) } play(A) { this.animation = Q.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3.out", stagger: .1, ...A }) } revert() { this.animation && this.animation.revert() } } class tn { constructor(A) { V(this, "DOM"); this.DOM = { el: A }; const w = A.querySelector(".home-bubble"), O = A.querySelector(".home-book-img-inner"); w && new St(w).render(), O && new $e({ el: O, offset: 30, direction: -1 }), new xt, this.maskText(), this.fadeText(), this.countText() } maskText() { const A = this.DOM.el.querySelectorAll(".js-text-mask"); A.length && A.forEach(w => { const O = w.getAttribute("data-delay-enter"), p = w.getAttribute("data-delay-trigger"), e = w.getAttribute("data-duration"); new en(w, { delayEnter: Number(O), delayTrigger: Number(p), duration: Number(e) }) }) } fadeText() { const A = this.DOM.el.querySelectorAll(".js-text-fade"); A.length && A.forEach(w => { const O = w.getAttribute("data-delay-enter"), p = w.getAttribute("data-delay-trigger"), e = w.getAttribute("data-duration"); new jt(w, { delayEnter: Number(O), delayTrigger: Number(p), duration: Number(e) }) }) } countText() { const A = this.DOM.el.querySelectorAll(".js-text-counter"); A.length && A.forEach(w => { const O = w.getAttribute("data-delay-enter"), p = w.getAttribute("data-delay-trigger"), e = w.getAttribute("data-duration"); new Zt(w, { delayEnter: Number(O), delayTrigger: Number(p), duration: Number(e) }) }) } } Q.registerPlugin(We); const nn = { start() { const A = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", A), A) return; const w = document.querySelector("div[data-page]"); if (!w) return; const O = w.getAttribute("data-page") || "home", p = { home: () => { new tn(w) }, about: () => { new mt } }; p[O] && p[O](), Ve.init(), new ct, new gt, new vt, ut.init({ once: !0, duration: 800, startEvent: "DOMContentLoaded", offset: re(10) }) } }; document.addEventListener("DOMContentLoaded", async () => { await ft, nn.start() });
