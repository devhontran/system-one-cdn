var $e = Object.defineProperty; var Qe = (R, A, w) => A in R ? $e(R, A, { enumerable: !0, configurable: !0, writable: !0, value: w }) : R[A] = w; var k = (R, A, w) => (Qe(R, typeof A != "symbol" ? A + "" : A, w), w); import { f as Re, u as ke, b, P as ae, s as ne, S as le, d as ge, e as Se, g as W, h as oe, i as ie, j as Je, k as Ze, l as Ke, m as Xe, _ as Fe, n as qe, L as Ye, A as je, o as _e, p as ve, q as et, r as tt, R as Ee, U as Ie, a as N, t as it, c as me, v as nt, w as se, M as st, x as at, y as rt } from "./global.js"; const ot = R => { Re.measure(R) }, He = R => { Re.mutate(R) }, Ve = (R, A, w, O, v) => parseFloat(((R - A) * (v - O) / (w - A) + O).toFixed(3)), ce = ({ el: R, elObServer: A = null, animIn: w, offsetPercent: O = null, animUnset: v, inScreen: e, outScreen: l }) => { let r = null, a = null, f = null, i = !1; const u = !!R.getAttribute("data-enteronly"), o = R.getAttribute("data-trigger-for"); o && (a = document.getElementById(o)); const t = () => { if (!i) return; const { isPageEnter: p } = ge; if (p) { const m = ge.isScrolled() ? parseFloat(R.getAttribute("data-offset") || "0") : parseFloat(R.getAttribute("data-screen-offset") || "0"); R.classList.add("anim-in"), w && w(m) } e && e() }, s = () => { const { winSize: p } = ge; O === null && ot(() => { const { height: m, top: S } = R.getBoundingClientRect(); S >= p.height && (O = Ve(m / p.height, 0, 1, .3, 0), O = Math.max(Math.min(O, .3), 0)) }), O = Number(R.getAttribute("data-threshold") || 0) || O, o ? ne(() => { f = new IntersectionObserver(m => { i = m[0].isIntersecting, i ? t() : l && l() }, { threshold: O || 0 }), f.observe(R) }) : ne(() => { r = le.create({ trigger: A || R, markers: !1, invalidateOnRefresh: !0, start: `${Number(O) * 100}% bottom`, onEnter: () => { i = !0, t() }, onLeave: () => { u && !e && !l && (v && v(), c(), i = !1), l && l() } }) }) }, n = () => i, c = () => { b.off(ae, t), r && r.kill(), o && a && (f == null || f.unobserve(a), f == null || f.disconnect()) }; return ke(() => (s(), b.on(ae, t), c)), { getIsVisible: n, removeEvent: c } }; class We {
    constructor(A, w, O) { k(this, "DOM"); k(this, "textSplit"); k(this, "input"); k(this, "old"); k(this, "isSpecial"); this.DOM = { el: A, listChars: [] }, ne(this.init.bind(this)), this.old = [1, 1, 0], this.input = w, this.isSpecial = O } init() {
        const A = new Se(this.DOM.el, { types: "chars, chars" }); W.killTweensOf([this.DOM.el, ...this.DOM.listChars]), this.textSplit = A, this.DOM.el.classList.add(oe.counter); const w = A.chars, O = globalThis.getComputedStyle(this.DOM.el).fontSize; if (w != null && w.length) for (const v in w) {
            const e = w[v], l = document.createElement("span"), r = e.innerText === "1"; if (l.classList.add(oe.counter_text), l.style.height = O, r && e.classList.add("char__one"), this.isSpecial && e.classList.add("char__special"), !isNaN(parseFloat(e.innerText))) {
                const a = parseFloat(e.innerText); l.insertAdjacentHTML("beforeend", `<span data-value="${a}"
                  class=${r ? `${oe.textSpacing}` : ""}>
                  <span>&ndash;</span>
                        ${Array(a + 1).join("0").split("0").map((u, o) => `
                                <span>
                                ${o}
                                </span>
                            `).join("")}
        			</span>`), e.removeChild(e.firstChild), e.appendChild(l); const f = l.querySelector("span[data-value]"); this.DOM.listChars.push(f); const { removeEvent: i } = ce({ el: this.DOM.el, animIn: u => { this.animIn(u), i() } }); ie(() => { i() })
            }
        }
    } handleSlide({ planType: A, valSaleUp: w, planUser: O, basePrice: v }) { var e; (e = this.input) == null || e.addEventListener("change", l => { var f; (f = this.textSplit) == null || f.revert(); const r = A === "month", a = (parseFloat(l.target.value) * O + v) * (r ? 1 : (100 - w) / 100 * 12); this.DOM.el.innerHTML = `${Math.floor(a)}`.replace(/\B(?=(\d{3})+(?!\d))/g, ".") }) } createNumberArray(A) { const w = A.toString().split(""); for (let O = 0; w.length < 3; O++)w[0] === "-" && (w[0] = "0"), w.unshift("0"); return w.map(O => parseInt(O)) } createNumberHTML(A, w, O) { var e; const v = O.querySelectorAll("span[data-value]"); for (let l = 0; l < v.length; l++) { const r = v[l], a = this.calcDeltaBetweenNumbers(w[l], A[l]); r.setAttribute("data-between", String(a.length)), r.setAttribute("data-value", String(A[l])), r.innerHTML = a.join(""); const f = (e = r.parentElement) == null ? void 0 : e.parentElement; f && (A[l] === 1 ? (f.classList.add("char__one"), f.classList.remove(oe.textSpacing)) : (f.classList.remove("char__one"), f.classList.remove(oe.textSpacing))) } return O } calcDeltaBetweenNumbers(A, w) { let O = [A], v = !0; if (A === w) return O.map(e => `<span>${e}</span>`); for (; v;)A++, A > 9 && (A = 0), O.push(A), A === w && (v = !1); return O.map(e => `<span>${e}</span>`) } animateNumber(A) { const w = this.createNumberArray(A); this.createNumberHTML(w, this.old, this.DOM.el); let O; O && clearTimeout(O), O = setTimeout(() => { const v = Array.from(this.DOM.el.querySelectorAll("span[data-between]")); W.killTweensOf([...v]), W.set(v, { y: 0 }); for (let e of v) { let l = Number(e.getAttribute("data-between")) - 1; W.to(e, { duration: 1, ease: "ease", y: `-${l * 100}%`, stagger: { amount: .025, from: "end" } }) } this.old = w }, 1) } animIn(A) { W.to(this.DOM.listChars, { duration: 1.2, ease: "power1", y: (w, O) => `-${(parseInt(O.getAttribute("data-value") || "0") + 1) * 100}%`, stagger: { amount: .025, from: "end" }, delay: A }) }
} class lt { constructor(A) { k(this, "DOM"); k(this, "animation"); this.DOM = { el: A, splitType: new Se(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var w; this.DOM.el.classList.add(Je.text__fade), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const v = document.createElement("div"); v.appendChild(O), v.classList.add("line__fade"), this.DOM.el.appendChild(v) }), (w = this.DOM.splitType.lines) != null && w.length && W.set(this.DOM.splitType.lines, { yPercent: 100, opacity: 0 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert(), this.revert() }) } animIn(A) { this.animation = W.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3.out", opacity: 1, stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } class ct { constructor(A) { k(this, "DOM"); k(this, "animation"); this.DOM = { el: A, splitType: new Se(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var w; this.DOM.el.classList.add(Ze.text__mask), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const v = document.createElement("div"); v.appendChild(O), v.classList.add("line__mask"), this.DOM.el.appendChild(v) }), (w = this.DOM.splitType.lines) != null && w.length && W.set(this.DOM.splitType.lines, { yPercent: 100 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert() }) } animIn(A) { this.animation = W.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3", stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } const ye = (R, A, w, O, v) => parseFloat(((R - A) * (v - O) / (w - A) + O).toFixed(3)), Le = R => { const A = parseFloat(getComputedStyle(document.documentElement).fontSize); return R / A }; class ft { constructor(A, w = {}) { k(this, "onHover"); k(this, "DOM"); k(this, "options"); k(this, "removeEvent"); this.DOM = { el: A }, this.options = { ...w }, this.addAnimType() } addAnimType() { this.DOM.el.classList.add(Ke.fade); let A; switch (this.options.type) { case "fade_tran": A = { from: { opacity: 0, y: "4rem" }, to: { keyframes: [{ opacity: 1, ease: "power3.inOut", duration: .8 }, { y: 0, ease: "power3.out", duration: .8, delay: -.6 }], delay: this.options.delay || 0 }, out: { opacity: 0, y: -30, ease: "power3.inOut", duration: .6 } }; break; default: A = { from: { opacity: 0 }, to: { opacity: 1, ease: "power3.inOut", duration: .8, delay: this.options.delay || 0, clearProps: "all" }, out: { opacity: 0, ease: "power3.inOut", duration: .6 } }; break }this.options.from = { ...A.from, ...this.options.from }, this.options.to = { ...A.to, ...this.options.to }, this.options.out = { ...A.out, ...this.options.out }, He(() => { const { removeEvent: w } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), w() } }); this.removeEvent = w, ie(() => { w() }) }), this.options.from && W.set(this.DOM.el, this.options.from) } animIn(A = 0) { const w = Object.assign({ delay: 0 }, this.options.to); w.delay += A, W.killTweensOf(this.DOM.el), this.options.from && W.fromTo(this.DOM.el, this.options.from, w), this.removeEvent && this.removeEvent() } } class ut { init() { this.loadImages() } maskText(A) { const w = A.querySelectorAll(".js-text-mask"); w.length && w.forEach(O => { new ct(O) }) } fadeWrap(A) { const w = A.querySelectorAll(".js-fade"); w.length && w.forEach(O => { new ft(O, { type: "fade_tran" }) }) } fadeText(A) { const w = A.querySelectorAll(".js-text-fade"); w.length && w.forEach(O => { new lt(O) }) } countText(A) { const w = A.querySelectorAll(".js-text-counter"); w.length && w.forEach(O => { new We(O) }) } loadImages() { const A = document.querySelectorAll("img"); for (let w = 0; w < A.length; w++) { const O = A[w]; if (O.getAttribute("srcset")) { const e = O.getAttribute("width") || O.width, l = O.getBoundingClientRect().y; if (O.setAttribute("sizes", `(max-width: ${e}px) 100vw, ${e}px`), l > window.innerHeight) { const r = O.srcset.split(" ")[0]; O.style.background = `url(${r}) no-repeat center / cover` } } } } loadPage() { const A = W.timeline(), w = document.querySelector(".pageloader"); A.set(w, { display: "block" }), A.to(w, { opacity: 0, duration: 3, ease: "power3.out", onComplete: () => { W.to(w, { display: "none" }) } }) } handleResize() { let A = window.innerWidth; function w() { const O = window.innerWidth; Math.abs(O - A) > 10 && window.location.reload(), A = O } window.addEventListener("resize", Xe(w, 200)) } } const Q = new ut, ht = "_parallax_79i64_1", vt = "_wrapper_79i64_5", dt = "_inner_79i64_12", xe = { parallax: ht, wrapper: vt, inner: dt }; class Me { constructor({ el: A, offset: w, scale: O, direction: v, ...e }) { k(this, "DOM"); k(this, "offset"); k(this, "scale"); k(this, "direction"); k(this, "options"); this.DOM = { el: A }, this.offset = w || 0, this.scale = O || 1.1, this.direction = v || -1, this.options = e, this.init() } init() { const A = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const w = document.createElement("div"); w.style.scale = `${this.scale}`, w.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, w.classList.add(xe.inner), A.classList.add(xe.parallax), this.DOM.el.classList.add(xe.wrapper), w.appendChild(A), this.DOM.el.appendChild(w), this.DOM.elInner = this.DOM.el; const { removeEvent: O } = ce({ el: this.DOM.el, animIn: () => { this.animIn(), O() } }); ie(() => { O() }) } animIn() { if (!this.DOM.elInner) return; const A = 100 + this.offset * 2, w = this.offset * A / 100 * this.direction, O = { trigger: this.DOM.el, start: "top bottom", end: "bottom top", scrub: 1 }; W.timeline({ scrollTrigger: O }).to(this.DOM.elInner, { y: `${w}%` }) } } class pt { constructor() { k(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.DOM.el && (this.hander(), this.movingImageFooter(), this.initMotion()) } initMotion() { this.DOM.el && (Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el)) } hander() { var w; const A = (w = this.DOM.el) == null ? void 0 : w.querySelector(".footer-bottom-inner-back"); A == null || A.addEventListener("click", () => { Fe.lenis.scrollTo("top", { lock: !0, duration: 1.2, onComplete: () => { console.log("scrolled") } }) }) } movingImageFooter() { var l, r, a, f, i; const A = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-inner-img"), w = (r = this.DOM.el) == null ? void 0 : r.querySelector(".footer-middle-list-imgs"); new Me({ el: w, offset: 25, direction: 1, scale: 1.3 }); const O = (a = this.DOM.el) == null ? void 0 : a.querySelectorAll(".footer-middle-list-imgs-item"), v = W.quickTo(A, "x", { duration: .9, ease: "power3.out" }), e = u => { O == null || O.forEach((o, t) => { t === u ? W.to(o, { opacity: 1, ease: "power3.out", duration: .6, willChange: "opacity" }) : W.to(o, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; e(1), A.style.willChange = "transform", (f = this.DOM.el) == null || f.addEventListener("mousemove", u => { if (!this.DOM.el) return; const o = u.pageX, t = ye(o, 0, window.innerWidth, -1, 1), s = Math.floor(ye(o, 0, window.innerWidth, 0, (O == null ? void 0 : O.length) || 3)), n = (this.DOM.el.clientWidth - A.clientWidth) / 2; v(t * n), e(s) }), (i = this.DOM.el) == null || i.addEventListener("mouseleave", () => { v(0), e(1) }) } } class gt { constructor() { k(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show() } show() { let A = 0; window.addEventListener("scroll", () => { var a; if (!this.DOM.el) return; const w = window.pageYOffset || document.documentElement.scrollTop || 0, O = ((a = this.DOM.footer) == null ? void 0 : a.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, v = w > this.DOM.el.clientHeight, l = A < w && w > this.DOM.el.clientHeight * 2 || O, r = A > w && !O; l ? this.DOM.el.classList.add("hidden") : r && (this.DOM.el.classList.remove("hidden"), this.DOM.el.classList.toggle("scrollDown", v)), A = w }) } } const mt = ({ el: R, isGsap: A = !0, isDebug: w, inScreen: O, onEnterBack: v, outScreen: e, threshold: l = 0, onToggle: r, onToggleOb: a, start: f, end: i }) => { let u = !1, o = null, t; return !qe() || A ? ne(() => { o = le.create({ trigger: R, start: f || `top+=${l * 100}% bottom`, end: i || "bottom top", markers: w, onToggle: c => { u = c.isActive, r && r(c), u ? O && O() : e && e() }, onEnterBack: v, invalidateOnRefresh: !0 }) }) : ne(() => { t = new IntersectionObserver(c => { u = c[0].isIntersecting, a && a(u), u ? O && O() : e && e() }, { threshold: l }), t.observe(R) }), { isInViewPointer: () => u, removeOb: () => { t && (t.unobserve(R), t.disconnect()), u = !1, o == null || o.kill(), o = null } } }; class xt { constructor() { k(this, "DOM"); k(this, "isReady"); k(this, "inited"); k(this, "windowIsBlur"); k(this, "isSimpleLoader"); k(this, "minProgress"); k(this, "processing"); k(this, "registerCount"); k(this, "lowNet"); k(this, "strokeDashoffset"); k(this, "obServerAPI"); k(this, "idAnimationLoop"); k(this, "runAnimation"); k(this, "delayPageEnter"); k(this, "delaLoadingOut"); this.registerLoader = this.registerLoader.bind(this), this.unRegisterLoader = this.unRegisterLoader.bind(this), this.init() } init() { this.DOM = { main: document.querySelector(".page-loading") }, document.body.classList.add("js-ready", "is-loading"), b.emit(Ye), this.inited = !!this.DOM.main, this.isReady = !1, this.windowIsBlur = !1, this.isSimpleLoader = !1, this.minProgress = 98, this.delayPageEnter = 1.2, this.delaLoadingOut = .3, this.processing = { delta: 0, percentStuck: 0, runWidth: 0 }, this.registerCount = 0, this.lowNet = 0, this.strokeDashoffset = 829, this.hideLoading = this.hideLoading.bind(this), ke(() => (b.on(Ee, this.registerLoader), b.on(Ie, this.unRegisterLoader), window.addEventListener("DOMContentLoaded", this.hideLoading), () => { b.off(Ee, this.registerLoader), b.off(Ie, this.unRegisterLoader), window.removeEventListener("DOMContentLoaded", this.hideLoading) })) } simpleLoaded() { var A; (A = this.DOM.main) == null || A.classList.add("is-simple"), this.isSimpleLoader = !0, this.pageLoaded() } simple() { this.obServerAPI = mt({ el: document.body }), this.isSimpleLoader = !0, this.isReady = !0, b.emit(je), document.body.classList.add("is-ready") } hideLoading() { b.emit(_e) } hide() { He(() => { this.DOM.main && (this.DOM.main.style.visibility = "hidden") }) } pageLoaded() { this.idAnimationLoop && cancelAnimationFrame(this.idAnimationLoop), document.body.classList.remove("is-loading"), document.body.classList.remove("is-simple"), b.emit(ve), b.emit(et), console.log("this.isSimpleLoader", this.isSimpleLoader), this.isSimpleLoader && (console.log("run_______"), this.DOM.main && W.to(this.DOM.main, { opacity: 0, duration: this.delayPageEnter, ease: "power3.inOut", onComplete: () => { setTimeout(() => this.hide(), 100), b.emit(ae), b.emit(tt) } })) } registerLoader() { this.registerCount++ } unRegisterLoader() { this.registerCount-- } } const Be = new xt; class yt { constructor(A) { k(this, "DOM"); this.DOM = { el: A }, b.emit(ae), this.initParticles = this.initParticles.bind(this), b.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el), this.handleStackCard() } clear() { this.initParticles() } handleStackCard() { console.log("hehe"); const A = this.DOM.el.querySelector(".about-vision-sticky-inner"), O = this.DOM.el.querySelector(".about-vision-sticky-left").querySelectorAll(".about-sticky-left-card"), v = this.DOM.el.querySelector(".about-vision-sticky-right-inner"), e = this.DOM.el.querySelectorAll(".about-sticky-right-img"); (() => { let r = null, a = null; W.timeline({ scrollTrigger: { trigger: ".about-vision-sticky", start: "top top", end: "bottom bottom", scrub: 1, onUpdate: t => { const { progress: s } = t, n = Math.round(Ve(s, 0, 1, 0, O.length - 1)); if (a !== null && s < a) i(r), u(r); else if (a !== null && s > a) { f(n); const c = Math.min(e.length - 1, n + 1); u(c) } r = n, a = s } } }); const f = t => { const s = Le((v.clientHeight - N(3.2) * 2) / O.length); O.forEach((n, c) => { t === c && W.to(n, { height: `${s}rem`, duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, i = t => { O.forEach((s, n) => { t === n && W.to(s, { height: "auto", duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, u = t => { e.forEach((s, n) => { n === t ? (W.killTweensOf(s), W.to(s, { opacity: 1, ease: "power3", duration: .8 })) : W.to(s, { opacity: 0, ease: "power3", duration: .8 }) }) }; u(0); const o = Le((window.innerHeight - v.clientHeight) / 2); A.style.top = `${o}rem` })() } } class St { constructor(A) { k(this, "DOM"); this.DOM = { wrapper: A.querySelector(".home-feature-cards"), listCards: A.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((A, w, O) => { if (!it) return; const v = O[0].clientHeight, e = (window.innerHeight - v) / 2, l = O.length * N(8), r = ye(w, 0, O.length - 1, .8125, 1); A.style.top = `${e + l}px`, A.style.transform = `translateY(-${(O.length - w) * N(8)}px)`, W.timeline({ scrollTrigger: { trigger: A, start: () => "top center", end: `+=${(O.length - w) * v} `, scrub: 1 } }).to(A, { scale: r, transformOrigin: "top center", ease: "none" }, 0) }) } } var te = {}, Mt = { get exports() { return te }, set exports(R) { te = R } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (R, A) { (function (O, v) { R.exports = v() })(me, function () { return function (w) { var O = {}; function v(e) { if (O[e]) return O[e].exports; var l = O[e] = { i: e, l: !1, exports: {} }; return w[e].call(l.exports, l, l.exports, v), l.l = !0, l.exports } return v.m = w, v.c = O, v.d = function (e, l, r) { v.o(e, l) || Object.defineProperty(e, l, { enumerable: !0, get: r }) }, v.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, v.t = function (e, l) { if (l & 1 && (e = v(e)), l & 8 || l & 4 && typeof e == "object" && e && e.__esModule) return e; var r = Object.create(null); if (v.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: e }), l & 2 && typeof e != "string") for (var a in e) v.d(r, a, function (f) { return e[f] }.bind(null, a)); return r }, v.n = function (e) { var l = e && e.__esModule ? function () { return e.default } : function () { return e }; return v.d(l, "a", l), l }, v.o = function (e, l) { return Object.prototype.hasOwnProperty.call(e, l) }, v.p = "", v(v.s = 20) }([function (w, O) { var v = {}; w.exports = v, function () { v._baseDelta = 1e3 / 60, v._nextId = 0, v._seed = 0, v._nowStartTime = +new Date, v._warnedOnce = {}, v._decomp = null, v.extend = function (l, r) { var a, f; typeof r == "boolean" ? (a = 2, f = r) : (a = 1, f = !0); for (var i = a; i < arguments.length; i++) { var u = arguments[i]; if (u) for (var o in u) f && u[o] && u[o].constructor === Object && (!l[o] || l[o].constructor === Object) ? (l[o] = l[o] || {}, v.extend(l[o], f, u[o])) : l[o] = u[o] } return l }, v.clone = function (l, r) { return v.extend({}, r, l) }, v.keys = function (l) { if (Object.keys) return Object.keys(l); var r = []; for (var a in l) r.push(a); return r }, v.values = function (l) { var r = []; if (Object.keys) { for (var a = Object.keys(l), f = 0; f < a.length; f++)r.push(l[a[f]]); return r } for (var i in l) r.push(l[i]); return r }, v.get = function (l, r, a, f) { r = r.split(".").slice(a, f); for (var i = 0; i < r.length; i += 1)l = l[r[i]]; return l }, v.set = function (l, r, a, f, i) { var u = r.split(".").slice(f, i); return v.get(l, r, 0, -1)[u[u.length - 1]] = a, a }, v.shuffle = function (l) { for (var r = l.length - 1; r > 0; r--) { var a = Math.floor(v.random() * (r + 1)), f = l[r]; l[r] = l[a], l[a] = f } return l }, v.choose = function (l) { return l[Math.floor(v.random() * l.length)] }, v.isElement = function (l) { return typeof HTMLElement < "u" ? l instanceof HTMLElement : !!(l && l.nodeType && l.nodeName) }, v.isArray = function (l) { return Object.prototype.toString.call(l) === "[object Array]" }, v.isFunction = function (l) { return typeof l == "function" }, v.isPlainObject = function (l) { return typeof l == "object" && l.constructor === Object }, v.isString = function (l) { return toString.call(l) === "[object String]" }, v.clamp = function (l, r, a) { return l < r ? r : l > a ? a : l }, v.sign = function (l) { return l < 0 ? -1 : 1 }, v.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - v._nowStartTime }, v.random = function (l, r) { return l = typeof l < "u" ? l : 0, r = typeof r < "u" ? r : 1, l + e() * (r - l) }; var e = function () { return v._seed = (v._seed * 9301 + 49297) % 233280, v._seed / 233280 }; v.colorToNumber = function (l) { return l = l.replace("#", ""), l.length == 3 && (l = l.charAt(0) + l.charAt(0) + l.charAt(1) + l.charAt(1) + l.charAt(2) + l.charAt(2)), parseInt(l, 16) }, v.logLevel = 1, v.log = function () { console && v.logLevel > 0 && v.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, v.info = function () { console && v.logLevel > 0 && v.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, v.warn = function () { console && v.logLevel > 0 && v.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, v.warnOnce = function () { var l = Array.prototype.slice.call(arguments).join(" "); v._warnedOnce[l] || (v.warn(l), v._warnedOnce[l] = !0) }, v.deprecated = function (l, r, a) { l[r] = v.chain(function () { v.warnOnce("ðŸ”… deprecated ðŸ”…", a) }, l[r]) }, v.nextId = function () { return v._nextId++ }, v.indexOf = function (l, r) { if (l.indexOf) return l.indexOf(r); for (var a = 0; a < l.length; a++)if (l[a] === r) return a; return -1 }, v.map = function (l, r) { if (l.map) return l.map(r); for (var a = [], f = 0; f < l.length; f += 1)a.push(r(l[f])); return a }, v.topologicalSort = function (l) { var r = [], a = [], f = []; for (var i in l) !a[i] && !f[i] && v._topologicalSort(i, a, f, l, r); return r }, v._topologicalSort = function (l, r, a, f, i) { var u = f[l] || []; a[l] = !0; for (var o = 0; o < u.length; o += 1) { var t = u[o]; a[t] || r[t] || v._topologicalSort(t, r, a, f, i) } a[l] = !1, r[l] = !0, i.push(l) }, v.chain = function () { for (var l = [], r = 0; r < arguments.length; r += 1) { var a = arguments[r]; a._chained ? l.push.apply(l, a._chained) : l.push(a) } var f = function () { for (var i, u = new Array(arguments.length), o = 0, t = arguments.length; o < t; o++)u[o] = arguments[o]; for (o = 0; o < l.length; o += 1) { var s = l[o].apply(i, u); typeof s < "u" && (i = s) } return i }; return f._chained = l, f }, v.chainPathBefore = function (l, r, a) { return v.set(l, r, v.chain(a, v.get(l, r))) }, v.chainPathAfter = function (l, r, a) { return v.set(l, r, v.chain(v.get(l, r), a)) }, v.setDecomp = function (l) { v._decomp = l }, v.getDecomp = function () { var l = v._decomp; try { !l && typeof window < "u" && (l = window.decomp), !l && typeof me < "u" && (l = me.decomp) } catch { l = null } return l } }() }, function (w, O) { var v = {}; w.exports = v, function () { v.create = function (e) { var l = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && v.update(l, e), l }, v.update = function (e, l, r) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var a = 0; a < l.length; a++) { var f = l[a]; f.x > e.max.x && (e.max.x = f.x), f.x < e.min.x && (e.min.x = f.x), f.y > e.max.y && (e.max.y = f.y), f.y < e.min.y && (e.min.y = f.y) } r && (r.x > 0 ? e.max.x += r.x : e.min.x += r.x, r.y > 0 ? e.max.y += r.y : e.min.y += r.y) }, v.contains = function (e, l) { return l.x >= e.min.x && l.x <= e.max.x && l.y >= e.min.y && l.y <= e.max.y }, v.overlaps = function (e, l) { return e.min.x <= l.max.x && e.max.x >= l.min.x && e.max.y >= l.min.y && e.min.y <= l.max.y }, v.translate = function (e, l) { e.min.x += l.x, e.max.x += l.x, e.min.y += l.y, e.max.y += l.y }, v.shift = function (e, l) { var r = e.max.x - e.min.x, a = e.max.y - e.min.y; e.min.x = l.x, e.max.x = l.x + r, e.min.y = l.y, e.max.y = l.y + a } }() }, function (w, O) { var v = {}; w.exports = v, function () { v.create = function (e, l) { return { x: e || 0, y: l || 0 } }, v.clone = function (e) { return { x: e.x, y: e.y } }, v.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, v.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, v.rotate = function (e, l, r) { var a = Math.cos(l), f = Math.sin(l); r || (r = {}); var i = e.x * a - e.y * f; return r.y = e.x * f + e.y * a, r.x = i, r }, v.rotateAbout = function (e, l, r, a) { var f = Math.cos(l), i = Math.sin(l); a || (a = {}); var u = r.x + ((e.x - r.x) * f - (e.y - r.y) * i); return a.y = r.y + ((e.x - r.x) * i + (e.y - r.y) * f), a.x = u, a }, v.normalise = function (e) { var l = v.magnitude(e); return l === 0 ? { x: 0, y: 0 } : { x: e.x / l, y: e.y / l } }, v.dot = function (e, l) { return e.x * l.x + e.y * l.y }, v.cross = function (e, l) { return e.x * l.y - e.y * l.x }, v.cross3 = function (e, l, r) { return (l.x - e.x) * (r.y - e.y) - (l.y - e.y) * (r.x - e.x) }, v.add = function (e, l, r) { return r || (r = {}), r.x = e.x + l.x, r.y = e.y + l.y, r }, v.sub = function (e, l, r) { return r || (r = {}), r.x = e.x - l.x, r.y = e.y - l.y, r }, v.mult = function (e, l) { return { x: e.x * l, y: e.y * l } }, v.div = function (e, l) { return { x: e.x / l, y: e.y / l } }, v.perp = function (e, l) { return l = l === !0 ? -1 : 1, { x: l * -e.y, y: l * e.x } }, v.neg = function (e) { return { x: -e.x, y: -e.y } }, v.angle = function (e, l) { return Math.atan2(l.y - e.y, l.x - e.x) }, v._temp = [v.create(), v.create(), v.create(), v.create(), v.create(), v.create()] }() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(2), r = v(0); (function () { e.create = function (a, f) { for (var i = [], u = 0; u < a.length; u++) { var o = a[u], t = { x: o.x, y: o.y, index: u, body: f, isInternal: !1 }; i.push(t) } return i }, e.fromPath = function (a, f) { var i = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, u = []; return a.replace(i, function (o, t, s) { u.push({ x: parseFloat(t), y: parseFloat(s) }) }), e.create(u, f) }, e.centre = function (a) { for (var f = e.area(a, !0), i = { x: 0, y: 0 }, u, o, t, s = 0; s < a.length; s++)t = (s + 1) % a.length, u = l.cross(a[s], a[t]), o = l.mult(l.add(a[s], a[t]), u), i = l.add(i, o); return l.div(i, 6 * f) }, e.mean = function (a) { for (var f = { x: 0, y: 0 }, i = 0; i < a.length; i++)f.x += a[i].x, f.y += a[i].y; return l.div(f, a.length) }, e.area = function (a, f) { for (var i = 0, u = a.length - 1, o = 0; o < a.length; o++)i += (a[u].x - a[o].x) * (a[u].y + a[o].y), u = o; return f ? i / 2 : Math.abs(i) / 2 }, e.inertia = function (a, f) { for (var i = 0, u = 0, o = a, t, s, n = 0; n < o.length; n++)s = (n + 1) % o.length, t = Math.abs(l.cross(o[s], o[n])), i += t * (l.dot(o[s], o[s]) + l.dot(o[s], o[n]) + l.dot(o[n], o[n])), u += t; return f / 6 * (i / u) }, e.translate = function (a, f, i) { i = typeof i < "u" ? i : 1; var u = a.length, o = f.x * i, t = f.y * i, s; for (s = 0; s < u; s++)a[s].x += o, a[s].y += t; return a }, e.rotate = function (a, f, i) { if (f !== 0) { var u = Math.cos(f), o = Math.sin(f), t = i.x, s = i.y, n = a.length, c, p, m, S; for (S = 0; S < n; S++)c = a[S], p = c.x - t, m = c.y - s, c.x = t + (p * u - m * o), c.y = s + (p * o + m * u); return a } }, e.contains = function (a, f) { for (var i = f.x, u = f.y, o = a.length, t = a[o - 1], s, n = 0; n < o; n++) { if (s = a[n], (i - t.x) * (s.y - t.y) + (u - t.y) * (t.x - s.x) > 0) return !1; t = s } return !0 }, e.scale = function (a, f, i, u) { if (f === 1 && i === 1) return a; u = u || e.centre(a); for (var o, t, s = 0; s < a.length; s++)o = a[s], t = l.sub(o, u), a[s].x = u.x + t.x * f, a[s].y = u.y + t.y * i; return a }, e.chamfer = function (a, f, i, u, o) { typeof f == "number" ? f = [f] : f = f || [8], i = typeof i < "u" ? i : -1, u = u || 2, o = o || 14; for (var t = [], s = 0; s < a.length; s++) { var n = a[s - 1 >= 0 ? s - 1 : a.length - 1], c = a[s], p = a[(s + 1) % a.length], m = f[s < f.length ? s : f.length - 1]; if (m === 0) { t.push(c); continue } var S = l.normalise({ x: c.y - n.y, y: n.x - c.x }), D = l.normalise({ x: p.y - c.y, y: c.x - p.x }), h = Math.sqrt(2 * Math.pow(m, 2)), g = l.mult(r.clone(S), m), x = l.normalise(l.mult(l.add(S, D), .5)), d = l.sub(c, l.mult(x, h)), M = i; i === -1 && (M = Math.pow(m, .32) * 1.75), M = r.clamp(M, u, o), M % 2 === 1 && (M += 1); for (var y = Math.acos(l.dot(S, D)), C = y / M, P = 0; P < M; P++)t.push(l.add(l.rotate(g, C * P), d)) } return t }, e.clockwiseSort = function (a) { var f = e.mean(a); return a.sort(function (i, u) { return l.angle(f, i) - l.angle(f, u) }), a }, e.isConvex = function (a) { var f = 0, i = a.length, u, o, t, s; if (i < 3) return null; for (u = 0; u < i; u++)if (o = (u + 1) % i, t = (u + 2) % i, s = (a[o].x - a[u].x) * (a[t].y - a[o].y), s -= (a[o].y - a[u].y) * (a[t].x - a[o].x), s < 0 ? f |= 1 : s > 0 && (f |= 2), f === 3) return !1; return f !== 0 ? !0 : null }, e.hull = function (a) { var f = [], i = [], u, o; for (a = a.slice(0), a.sort(function (t, s) { var n = t.x - s.x; return n !== 0 ? n : t.y - s.y }), o = 0; o < a.length; o += 1) { for (u = a[o]; i.length >= 2 && l.cross3(i[i.length - 2], i[i.length - 1], u) <= 0;)i.pop(); i.push(u) } for (o = a.length - 1; o >= 0; o -= 1) { for (u = a[o]; f.length >= 2 && l.cross3(f[f.length - 2], f[f.length - 1], u) <= 0;)f.pop(); f.push(u) } return f.pop(), i.pop(), f.concat(i) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(2), a = v(7), f = v(0), i = v(1), u = v(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var s = { id: f.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: l.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, n = f.extend(s, t); return o(n, t), n }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var o = function (t, s) { s = s || {}, e.set(t, { bounds: t.bounds || i.create(t.vertices), positionPrev: t.positionPrev || r.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), l.rotate(t.vertices, t.angle, t.position), u.rotate(t.axes, t.angle), i.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: s.axes || t.axes, area: s.area || t.area, mass: s.mass || t.mass, inertia: s.inertia || t.inertia }); var n = t.isStatic ? "#14151f" : f.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), c = t.isStatic ? "#555" : "#ccc", p = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || n, t.render.strokeStyle = t.render.strokeStyle || c, t.render.lineWidth = t.render.lineWidth || p, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, s, n) { var c; typeof s == "string" && (c = s, s = {}, s[c] = n); for (c in s) if (Object.prototype.hasOwnProperty.call(s, c)) switch (n = s[c], c) { case "isStatic": e.setStatic(t, n); break; case "isSleeping": a.set(t, n); break; case "mass": e.setMass(t, n); break; case "density": e.setDensity(t, n); break; case "inertia": e.setInertia(t, n); break; case "vertices": e.setVertices(t, n); break; case "position": e.setPosition(t, n); break; case "angle": e.setAngle(t, n); break; case "velocity": e.setVelocity(t, n); break; case "angularVelocity": e.setAngularVelocity(t, n); break; case "speed": e.setSpeed(t, n); break; case "angularSpeed": e.setAngularSpeed(t, n); break; case "parts": e.setParts(t, n); break; case "centre": e.setCentre(t, n); break; default: t[c] = n } }, e.setStatic = function (t, s) { for (var n = 0; n < t.parts.length; n++) { var c = t.parts[n]; s ? (c.isStatic || (c._original = { restitution: c.restitution, friction: c.friction, mass: c.mass, inertia: c.inertia, density: c.density, inverseMass: c.inverseMass, inverseInertia: c.inverseInertia }), c.restitution = 0, c.friction = 1, c.mass = c.inertia = c.density = 1 / 0, c.inverseMass = c.inverseInertia = 0, c.positionPrev.x = c.position.x, c.positionPrev.y = c.position.y, c.anglePrev = c.angle, c.angularVelocity = 0, c.speed = 0, c.angularSpeed = 0, c.motion = 0) : c._original && (c.restitution = c._original.restitution, c.friction = c._original.friction, c.mass = c._original.mass, c.inertia = c._original.inertia, c.density = c._original.density, c.inverseMass = c._original.inverseMass, c.inverseInertia = c._original.inverseInertia, c._original = null), c.isStatic = s } }, e.setMass = function (t, s) { var n = t.inertia / (t.mass / 6); t.inertia = n * (s / 6), t.inverseInertia = 1 / t.inertia, t.mass = s, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, s) { e.setMass(t, s * t.area), t.density = s }, e.setInertia = function (t, s) { t.inertia = s, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, s) { s[0].body === t ? t.vertices = s : t.vertices = l.create(s, t), t.axes = u.fromVertices(t.vertices), t.area = l.area(t.vertices), e.setMass(t, t.density * t.area); var n = l.centre(t.vertices); l.translate(t.vertices, n, -1), e.setInertia(t, e._inertiaScale * l.inertia(t.vertices, t.mass)), l.translate(t.vertices, t.position), i.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, s, n) { var c; for (s = s.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, c = 0; c < s.length; c++) { var p = s[c]; p !== t && (p.parent = t, t.parts.push(p)) } if (t.parts.length !== 1) { if (n = typeof n < "u" ? n : !0, n) { var m = []; for (c = 0; c < s.length; c++)m = m.concat(s[c].vertices); l.clockwiseSort(m); var S = l.hull(m), D = l.centre(S); e.setVertices(t, S), l.translate(t.vertices, D) } var h = e._totalProperties(t); t.area = h.area, t.parent = t, t.position.x = h.centre.x, t.position.y = h.centre.y, t.positionPrev.x = h.centre.x, t.positionPrev.y = h.centre.y, e.setMass(t, h.mass), e.setInertia(t, h.inertia), e.setPosition(t, h.centre) } }, e.setCentre = function (t, s, n) { n ? (t.positionPrev.x += s.x, t.positionPrev.y += s.y, t.position.x += s.x, t.position.y += s.y) : (t.positionPrev.x = s.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = s.y - (t.position.y - t.positionPrev.y), t.position.x = s.x, t.position.y = s.y) }, e.setPosition = function (t, s, n) { var c = r.sub(s, t.position); n ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = c.x, t.velocity.y = c.y, t.speed = r.magnitude(c)) : (t.positionPrev.x += c.x, t.positionPrev.y += c.y); for (var p = 0; p < t.parts.length; p++) { var m = t.parts[p]; m.position.x += c.x, m.position.y += c.y, l.translate(m.vertices, c), i.update(m.bounds, m.vertices, t.velocity) } }, e.setAngle = function (t, s, n) { var c = s - t.angle; n ? (t.anglePrev = t.angle, t.angularVelocity = c, t.angularSpeed = Math.abs(c)) : t.anglePrev += c; for (var p = 0; p < t.parts.length; p++) { var m = t.parts[p]; m.angle += c, l.rotate(m.vertices, c, t.position), u.rotate(m.axes, c), i.update(m.bounds, m.vertices, t.velocity), p > 0 && r.rotateAbout(m.position, c, t.position, m.position) } }, e.setVelocity = function (t, s) { var n = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - s.x * n, t.positionPrev.y = t.position.y - s.y * n, t.velocity.x = (t.position.x - t.positionPrev.x) / n, t.velocity.y = (t.position.y - t.positionPrev.y) / n, t.speed = r.magnitude(t.velocity) }, e.getVelocity = function (t) { var s = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * s, y: (t.position.y - t.positionPrev.y) * s } }, e.getSpeed = function (t) { return r.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, s) { e.setVelocity(t, r.mult(r.normalise(e.getVelocity(t)), s)) }, e.setAngularVelocity = function (t, s) { var n = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - s * n, t.angularVelocity = (t.angle - t.anglePrev) / n, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, s) { e.setAngularVelocity(t, f.sign(e.getAngularVelocity(t)) * s) }, e.translate = function (t, s, n) { e.setPosition(t, r.add(t.position, s), n) }, e.rotate = function (t, s, n, c) { if (!n) e.setAngle(t, t.angle + s, c); else { var p = Math.cos(s), m = Math.sin(s), S = t.position.x - n.x, D = t.position.y - n.y; e.setPosition(t, { x: n.x + (S * p - D * m), y: n.y + (S * m + D * p) }, c), e.setAngle(t, t.angle + s, c) } }, e.scale = function (t, s, n, c) { var p = 0, m = 0; c = c || t.position; for (var S = 0; S < t.parts.length; S++) { var D = t.parts[S]; l.scale(D.vertices, s, n, c), D.axes = u.fromVertices(D.vertices), D.area = l.area(D.vertices), e.setMass(D, t.density * D.area), l.translate(D.vertices, { x: -D.position.x, y: -D.position.y }), e.setInertia(D, e._inertiaScale * l.inertia(D.vertices, D.mass)), l.translate(D.vertices, { x: D.position.x, y: D.position.y }), S > 0 && (p += D.area, m += D.inertia), D.position.x = c.x + (D.position.x - c.x) * s, D.position.y = c.y + (D.position.y - c.y) * n, i.update(D.bounds, D.vertices, t.velocity) } t.parts.length > 1 && (t.area = p, t.isStatic || (e.setMass(t, t.density * p), e.setInertia(t, m))), t.circleRadius && (s === n ? t.circleRadius *= s : t.circleRadius = null) }, e.update = function (t, s) { s = (typeof s < "u" ? s : 1e3 / 60) * t.timeScale; var n = s * s, c = e._timeCorrection ? s / (t.deltaTime || s) : 1, p = 1 - t.frictionAir * (s / f._baseDelta), m = (t.position.x - t.positionPrev.x) * c, S = (t.position.y - t.positionPrev.y) * c; t.velocity.x = m * p + t.force.x / t.mass * n, t.velocity.y = S * p + t.force.y / t.mass * n, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = s, t.angularVelocity = (t.angle - t.anglePrev) * p * c + t.torque / t.inertia * n, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var D = 0; D < t.parts.length; D++) { var h = t.parts[D]; l.translate(h.vertices, t.velocity), D > 0 && (h.position.x += t.velocity.x, h.position.y += t.velocity.y), t.angularVelocity !== 0 && (l.rotate(h.vertices, t.angularVelocity, t.position), u.rotate(h.axes, t.angularVelocity), D > 0 && r.rotateAbout(h.position, t.angularVelocity, t.position, h.position)), i.update(h.bounds, h.vertices, t.velocity) } }, e.updateVelocities = function (t) { var s = e._baseDelta / t.deltaTime, n = t.velocity; n.x = (t.position.x - t.positionPrev.x) * s, n.y = (t.position.y - t.positionPrev.y) * s, t.speed = Math.sqrt(n.x * n.x + n.y * n.y), t.angularVelocity = (t.angle - t.anglePrev) * s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, s, n) { var c = { x: s.x - t.position.x, y: s.y - t.position.y }; t.force.x += n.x, t.force.y += n.y, t.torque += c.x * n.y - c.y * n.x }, e._totalProperties = function (t) { for (var s = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, n = t.parts.length === 1 ? 0 : 1; n < t.parts.length; n++) { var c = t.parts[n], p = c.mass !== 1 / 0 ? c.mass : 1; s.mass += p, s.area += c.area, s.inertia += c.inertia, s.centre = r.add(s.centre, r.mult(c.position, p)) } return s.centre = r.div(s.centre, s.mass), s } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(0); (function () { e.on = function (r, a, f) { for (var i = a.split(" "), u, o = 0; o < i.length; o++)u = i[o], r.events = r.events || {}, r.events[u] = r.events[u] || [], r.events[u].push(f); return f }, e.off = function (r, a, f) { if (!a) { r.events = {}; return } typeof a == "function" && (f = a, a = l.keys(r.events).join(" ")); for (var i = a.split(" "), u = 0; u < i.length; u++) { var o = r.events[i[u]], t = []; if (f && o) for (var s = 0; s < o.length; s++)o[s] !== f && t.push(o[s]); r.events[i[u]] = t } }, e.trigger = function (r, a, f) { var i, u, o, t, s = r.events; if (s && l.keys(s).length > 0) { f || (f = {}), i = a.split(" "); for (var n = 0; n < i.length; n++)if (u = i[n], o = s[u], o) { t = l.clone(f, !1), t.name = u, t.source = r; for (var c = 0; c < o.length; c++)o[c].apply(r, [t]) } } } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(5), r = v(0), a = v(1), f = v(4); (function () { e.create = function (i) { return r.extend({ id: r.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, i) }, e.setModified = function (i, u, o, t) { if (i.isModified = u, u && i.cache && (i.cache.allBodies = null, i.cache.allConstraints = null, i.cache.allComposites = null), o && i.parent && e.setModified(i.parent, u, o, t), t) for (var s = 0; s < i.composites.length; s++) { var n = i.composites[s]; e.setModified(n, u, o, t) } }, e.add = function (i, u) { var o = [].concat(u); l.trigger(i, "beforeAdd", { object: u }); for (var t = 0; t < o.length; t++) { var s = o[t]; switch (s.type) { case "body": if (s.parent !== s) { r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(i, s); break; case "constraint": e.addConstraint(i, s); break; case "composite": e.addComposite(i, s); break; case "mouseConstraint": e.addConstraint(i, s.constraint); break } } return l.trigger(i, "afterAdd", { object: u }), i }, e.remove = function (i, u, o) { var t = [].concat(u); l.trigger(i, "beforeRemove", { object: u }); for (var s = 0; s < t.length; s++) { var n = t[s]; switch (n.type) { case "body": e.removeBody(i, n, o); break; case "constraint": e.removeConstraint(i, n, o); break; case "composite": e.removeComposite(i, n, o); break; case "mouseConstraint": e.removeConstraint(i, n.constraint); break } } return l.trigger(i, "afterRemove", { object: u }), i }, e.addComposite = function (i, u) { return i.composites.push(u), u.parent = i, e.setModified(i, !0, !0, !1), i }, e.removeComposite = function (i, u, o) { var t = r.indexOf(i.composites, u); if (t !== -1) { var s = e.allBodies(u); e.removeCompositeAt(i, t); for (var n = 0; n < s.length; n++)s[n].sleepCounter = 0 } if (o) for (var n = 0; n < i.composites.length; n++)e.removeComposite(i.composites[n], u, !0); return i }, e.removeCompositeAt = function (i, u) { return i.composites.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.addBody = function (i, u) { return i.bodies.push(u), e.setModified(i, !0, !0, !1), i }, e.removeBody = function (i, u, o) { var t = r.indexOf(i.bodies, u); if (t !== -1 && (e.removeBodyAt(i, t), u.sleepCounter = 0), o) for (var s = 0; s < i.composites.length; s++)e.removeBody(i.composites[s], u, !0); return i }, e.removeBodyAt = function (i, u) { return i.bodies.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.addConstraint = function (i, u) { return i.constraints.push(u), e.setModified(i, !0, !0, !1), i }, e.removeConstraint = function (i, u, o) { var t = r.indexOf(i.constraints, u); if (t !== -1 && e.removeConstraintAt(i, t), o) for (var s = 0; s < i.composites.length; s++)e.removeConstraint(i.composites[s], u, !0); return i }, e.removeConstraintAt = function (i, u) { return i.constraints.splice(u, 1), e.setModified(i, !0, !0, !1), i }, e.clear = function (i, u, o) { if (o) for (var t = 0; t < i.composites.length; t++)e.clear(i.composites[t], u, !0); return u ? i.bodies = i.bodies.filter(function (s) { return s.isStatic }) : i.bodies.length = 0, i.constraints.length = 0, i.composites.length = 0, e.setModified(i, !0, !0, !1), i }, e.allBodies = function (i) { if (i.cache && i.cache.allBodies) return i.cache.allBodies; for (var u = [].concat(i.bodies), o = 0; o < i.composites.length; o++)u = u.concat(e.allBodies(i.composites[o])); return i.cache && (i.cache.allBodies = u), u }, e.allConstraints = function (i) { if (i.cache && i.cache.allConstraints) return i.cache.allConstraints; for (var u = [].concat(i.constraints), o = 0; o < i.composites.length; o++)u = u.concat(e.allConstraints(i.composites[o])); return i.cache && (i.cache.allConstraints = u), u }, e.allComposites = function (i) { if (i.cache && i.cache.allComposites) return i.cache.allComposites; for (var u = [].concat(i.composites), o = 0; o < i.composites.length; o++)u = u.concat(e.allComposites(i.composites[o])); return i.cache && (i.cache.allComposites = u), u }, e.get = function (i, u, o) { var t, s; switch (o) { case "body": t = e.allBodies(i); break; case "constraint": t = e.allConstraints(i); break; case "composite": t = e.allComposites(i).concat(i); break }return t ? (s = t.filter(function (n) { return n.id.toString() === u.toString() }), s.length === 0 ? null : s[0]) : null }, e.move = function (i, u, o) { return e.remove(i, u), e.add(o, u), i }, e.rebase = function (i) { for (var u = e.allBodies(i).concat(e.allConstraints(i)).concat(e.allComposites(i)), o = 0; o < u.length; o++)u[o].id = r.nextId(); return i }, e.translate = function (i, u, o) { for (var t = o ? e.allBodies(i) : i.bodies, s = 0; s < t.length; s++)f.translate(t[s], u); return i }, e.rotate = function (i, u, o, t) { for (var s = Math.cos(u), n = Math.sin(u), c = t ? e.allBodies(i) : i.bodies, p = 0; p < c.length; p++) { var m = c[p], S = m.position.x - o.x, D = m.position.y - o.y; f.setPosition(m, { x: o.x + (S * s - D * n), y: o.y + (S * n + D * s) }), f.rotate(m, u) } return i }, e.scale = function (i, u, o, t, s) { for (var n = s ? e.allBodies(i) : i.bodies, c = 0; c < n.length; c++) { var p = n[c], m = p.position.x - t.x, S = p.position.y - t.y; f.setPosition(p, { x: t.x + m * u, y: t.y + S * o }), f.scale(p, u, o) } return i }, e.bounds = function (i) { for (var u = e.allBodies(i), o = [], t = 0; t < u.length; t += 1) { var s = u[t]; o.push(s.bounds.min, s.bounds.max) } return a.create(o) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(4), r = v(5), a = v(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (f, i) { for (var u = i / a._baseDelta, o = e._motionSleepThreshold, t = 0; t < f.length; t++) { var s = f[t], n = l.getSpeed(s), c = l.getAngularSpeed(s), p = n * n + c * c; if (s.force.x !== 0 || s.force.y !== 0) { e.set(s, !1); continue } var m = Math.min(s.motion, p), S = Math.max(s.motion, p); s.motion = e._minBias * m + (1 - e._minBias) * S, s.sleepThreshold > 0 && s.motion < o ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold / u && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1) } }, e.afterCollisions = function (f) { for (var i = e._motionSleepThreshold, u = 0; u < f.length; u++) { var o = f[u]; if (o.isActive) { var t = o.collision, s = t.bodyA.parent, n = t.bodyB.parent; if (!(s.isSleeping && n.isSleeping || s.isStatic || n.isStatic) && (s.isSleeping || n.isSleeping)) { var c = s.isSleeping && !s.isStatic ? s : n, p = c === s ? n : s; !c.isStatic && p.motion > i && e.set(c, !1) } } } }, e.set = function (f, i) { var u = f.isSleeping; i ? (f.isSleeping = !0, f.sleepCounter = f.sleepThreshold, f.positionImpulse.x = 0, f.positionImpulse.y = 0, f.positionPrev.x = f.position.x, f.positionPrev.y = f.position.y, f.anglePrev = f.angle, f.speed = 0, f.angularSpeed = 0, f.motion = 0, u || r.trigger(f, "sleepStart")) : (f.isSleeping = !1, f.sleepCounter = 0, u && r.trigger(f, "sleepEnd")) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(9); (function () { var a = [], f = { overlap: 0, axis: null }, i = { overlap: 0, axis: null }; e.create = function (u, o) { return { pair: null, collided: !1, bodyA: u, bodyB: o, parentA: u.parent, parentB: o.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (u, o, t) { if (e._overlapAxes(f, u.vertices, o.vertices, u.axes), f.overlap <= 0 || (e._overlapAxes(i, o.vertices, u.vertices, o.axes), i.overlap <= 0)) return null; var s = t && t.table[r.id(u, o)], n; s ? n = s.collision : (n = e.create(u, o), n.collided = !0, n.bodyA = u.id < o.id ? u : o, n.bodyB = u.id < o.id ? o : u, n.parentA = n.bodyA.parent, n.parentB = n.bodyB.parent), u = n.bodyA, o = n.bodyB; var c; f.overlap < i.overlap ? c = f : c = i; var p = n.normal, m = n.tangent, S = n.penetration, D = n.supports, h = c.overlap, g = c.axis, x = g.x, d = g.y, M = o.position.x - u.position.x, y = o.position.y - u.position.y; x * M + d * y >= 0 && (x = -x, d = -d), p.x = x, p.y = d, m.x = -d, m.y = x, S.x = x * h, S.y = d * h, n.depth = h; var C = e._findSupports(u, o, p, 1), P = 0; if (l.contains(u.vertices, C[0]) && (D[P++] = C[0]), l.contains(u.vertices, C[1]) && (D[P++] = C[1]), P < 2) { var T = e._findSupports(o, u, p, -1); l.contains(o.vertices, T[0]) && (D[P++] = T[0]), P < 2 && l.contains(o.vertices, T[1]) && (D[P++] = T[1]) } return P === 0 && (D[P++] = C[0]), n.supportCount = P, n }, e._overlapAxes = function (u, o, t, s) { var n = o.length, c = t.length, p = o[0].x, m = o[0].y, S = t[0].x, D = t[0].y, h = s.length, g = Number.MAX_VALUE, x = 0, d, M, y, C, P, T; for (P = 0; P < h; P++) { var I = s[P], E = I.x, B = I.y, L = p * E + m * B, F = S * E + D * B, V = L, U = F; for (T = 1; T < n; T += 1)C = o[T].x * E + o[T].y * B, C > V ? V = C : C < L && (L = C); for (T = 1; T < c; T += 1)C = t[T].x * E + t[T].y * B, C > U ? U = C : C < F && (F = C); if (M = V - F, y = U - L, d = M < y ? M : y, d < g && (g = d, x = P, d <= 0)) break } u.axis = s[x], u.overlap = g }, e._findSupports = function (u, o, t, s) { var n = o.vertices, c = n.length, p = u.position.x, m = u.position.y, S = t.x * s, D = t.y * s, h = n[0], g = h, x = S * (p - g.x) + D * (m - g.y), d, M, y; for (y = 1; y < c; y += 1)g = n[y], M = S * (p - g.x) + D * (m - g.y), M < x && (x = M, h = g); return d = n[(c + h.index - 1) % c], x = S * (p - d.x) + D * (m - d.y), g = n[(h.index + 1) % c], S * (p - g.x) + D * (m - g.y) < x ? (a[0] = h, a[1] = g, a) : (a[0] = h, a[1] = d, a) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(16); (function () { e.create = function (r, a) { var f = r.bodyA, i = r.bodyB, u = { id: e.id(f, i), bodyA: f, bodyB: i, collision: r, contacts: [l.create(), l.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: f.isSensor || i.isSensor, timeCreated: a, timeUpdated: a, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(u, r, a), u }, e.update = function (r, a, f) { var i = a.supports, u = a.supportCount, o = r.contacts, t = a.parentA, s = a.parentB; r.isActive = !0, r.timeUpdated = f, r.collision = a, r.separation = a.depth, r.inverseMass = t.inverseMass + s.inverseMass, r.friction = t.friction < s.friction ? t.friction : s.friction, r.frictionStatic = t.frictionStatic > s.frictionStatic ? t.frictionStatic : s.frictionStatic, r.restitution = t.restitution > s.restitution ? t.restitution : s.restitution, r.slop = t.slop > s.slop ? t.slop : s.slop, r.contactCount = u, a.pair = r; var n = i[0], c = o[0], p = i[1], m = o[1]; (m.vertex === n || c.vertex === p) && (o[1] = c, o[0] = c = m, m = o[1]), c.vertex = n, m.vertex = p }, e.setActive = function (r, a, f) { a ? (r.isActive = !0, r.timeUpdated = f) : (r.isActive = !1, r.contactCount = 0) }, e.id = function (r, a) { return r.id < a.id ? r.id.toString(36) + ":" + a.id.toString(36) : a.id.toString(36) + ":" + r.id.toString(36) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(2), a = v(7), f = v(1), i = v(11), u = v(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (o) { var t = o; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var s = t.bodyA ? r.add(t.bodyA.position, t.pointA) : t.pointA, n = t.bodyB ? r.add(t.bodyB.position, t.pointB) : t.pointB, c = r.magnitude(r.sub(s, n)); t.length = typeof t.length < "u" ? t.length : c, t.id = t.id || u.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var p = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (p.type = "pin", p.anchors = !1) : t.stiffness < .9 && (p.type = "spring"), t.render = u.extend(p, t.render), t }, e.preSolveAll = function (o) { for (var t = 0; t < o.length; t += 1) { var s = o[t], n = s.constraintImpulse; s.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (s.position.x += n.x, s.position.y += n.y, s.angle += n.angle) } }, e.solveAll = function (o, t) { for (var s = u.clamp(t / u._baseDelta, 0, 1), n = 0; n < o.length; n += 1) { var c = o[n], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic; (p || m) && e.solve(o[n], s) } for (n = 0; n < o.length; n += 1)c = o[n], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic, !p && !m && e.solve(o[n], s) }, e.solve = function (o, t) { var s = o.bodyA, n = o.bodyB, c = o.pointA, p = o.pointB; if (!(!s && !n)) { s && !s.isStatic && (r.rotate(c, s.angle - o.angleA, c), o.angleA = s.angle), n && !n.isStatic && (r.rotate(p, n.angle - o.angleB, p), o.angleB = n.angle); var m = c, S = p; if (s && (m = r.add(s.position, c)), n && (S = r.add(n.position, p)), !(!m || !S)) { var D = r.sub(m, S), h = r.magnitude(D); h < e._minLength && (h = e._minLength); var g = (h - o.length) / h, x = o.stiffness >= 1 || o.length === 0, d = x ? o.stiffness * t : o.stiffness * t * t, M = o.damping * t, y = r.mult(D, g * d), C = (s ? s.inverseMass : 0) + (n ? n.inverseMass : 0), P = (s ? s.inverseInertia : 0) + (n ? n.inverseInertia : 0), T = C + P, I, E, B, L, F; if (M > 0) { var V = r.create(); B = r.div(D, h), F = r.sub(n && r.sub(n.position, n.positionPrev) || V, s && r.sub(s.position, s.positionPrev) || V), L = r.dot(B, F) } s && !s.isStatic && (E = s.inverseMass / C, s.constraintImpulse.x -= y.x * E, s.constraintImpulse.y -= y.y * E, s.position.x -= y.x * E, s.position.y -= y.y * E, M > 0 && (s.positionPrev.x -= M * B.x * L * E, s.positionPrev.y -= M * B.y * L * E), I = r.cross(c, y) / T * e._torqueDampen * s.inverseInertia * (1 - o.angularStiffness), s.constraintImpulse.angle -= I, s.angle -= I), n && !n.isStatic && (E = n.inverseMass / C, n.constraintImpulse.x += y.x * E, n.constraintImpulse.y += y.y * E, n.position.x += y.x * E, n.position.y += y.y * E, M > 0 && (n.positionPrev.x += M * B.x * L * E, n.positionPrev.y += M * B.y * L * E), I = r.cross(p, y) / T * e._torqueDampen * n.inverseInertia * (1 - o.angularStiffness), n.constraintImpulse.angle += I, n.angle += I) } } }, e.postSolveAll = function (o) { for (var t = 0; t < o.length; t++) { var s = o[t], n = s.constraintImpulse; if (!(s.isStatic || n.x === 0 && n.y === 0 && n.angle === 0)) { a.set(s, !1); for (var c = 0; c < s.parts.length; c++) { var p = s.parts[c]; l.translate(p.vertices, n), c > 0 && (p.position.x += n.x, p.position.y += n.y), n.angle !== 0 && (l.rotate(p.vertices, n.angle, s.position), i.rotate(p.axes, n.angle), c > 0 && r.rotateAbout(p.position, n.angle, s.position, p.position)), f.update(p.bounds, p.vertices, s.velocity) } n.angle *= e._warming, n.x *= e._warming, n.y *= e._warming } } }, e.pointAWorld = function (o) { return { x: (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), y: (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0) } }, e.pointBWorld = function (o) { return { x: (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), y: (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0) } }, e.currentLength = function (o) { var t = (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), s = (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0), n = (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), c = (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0), p = t - n, m = s - c; return Math.sqrt(p * p + m * m) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(2), r = v(0); (function () { e.fromVertices = function (a) { for (var f = {}, i = 0; i < a.length; i++) { var u = (i + 1) % a.length, o = l.normalise({ x: a[u].y - a[i].y, y: a[i].x - a[u].x }), t = o.y === 0 ? 1 / 0 : o.x / o.y; t = t.toFixed(3).toString(), f[t] = o } return r.values(f) }, e.rotate = function (a, f) { if (f !== 0) for (var i = Math.cos(f), u = Math.sin(f), o = 0; o < a.length; o++) { var t = a[o], s; s = t.x * i - t.y * u, t.y = t.x * u + t.y * i, t.x = s } } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(0), a = v(4), f = v(1), i = v(2); (function () { e.rectangle = function (u, o, t, s, n) { n = n || {}; var c = { label: "Rectangle Body", position: { x: u, y: o }, vertices: l.fromPath("L 0 0 L " + t + " 0 L " + t + " " + s + " L 0 " + s) }; if (n.chamfer) { var p = n.chamfer; c.vertices = l.chamfer(c.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete n.chamfer } return a.create(r.extend({}, c, n)) }, e.trapezoid = function (u, o, t, s, n, c) { c = c || {}, n >= 1 && r.warn("Bodies.trapezoid: slope parameter must be < 1."), n *= .5; var p = (1 - n * 2) * t, m = t * n, S = m + p, D = S + m, h; n < .5 ? h = "L 0 0 L " + m + " " + -s + " L " + S + " " + -s + " L " + D + " 0" : h = "L 0 0 L " + S + " " + -s + " L " + D + " 0"; var g = { label: "Trapezoid Body", position: { x: u, y: o }, vertices: l.fromPath(h) }; if (c.chamfer) { var x = c.chamfer; g.vertices = l.chamfer(g.vertices, x.radius, x.quality, x.qualityMin, x.qualityMax), delete c.chamfer } return a.create(r.extend({}, g, c)) }, e.circle = function (u, o, t, s, n) { s = s || {}; var c = { label: "Circle Body", circleRadius: t }; n = n || 25; var p = Math.ceil(Math.max(10, Math.min(n, t))); return p % 2 === 1 && (p += 1), e.polygon(u, o, p, t, r.extend({}, c, s)) }, e.polygon = function (u, o, t, s, n) { if (n = n || {}, t < 3) return e.circle(u, o, s, n); for (var c = 2 * Math.PI / t, p = "", m = c * .5, S = 0; S < t; S += 1) { var D = m + S * c, h = Math.cos(D) * s, g = Math.sin(D) * s; p += "L " + h.toFixed(3) + " " + g.toFixed(3) + " " } var x = { label: "Polygon Body", position: { x: u, y: o }, vertices: l.fromPath(p) }; if (n.chamfer) { var d = n.chamfer; x.vertices = l.chamfer(x.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete n.chamfer } return a.create(r.extend({}, x, n)) }, e.fromVertices = function (u, o, t, s, n, c, p, m) { var S = r.getDecomp(), D, h, g, x, d, M, y, C, P, T, I; for (D = !!(S && S.quickDecomp), s = s || {}, g = [], n = typeof n < "u" ? n : !1, c = typeof c < "u" ? c : .01, p = typeof p < "u" ? p : 10, m = typeof m < "u" ? m : .01, r.isArray(t[0]) || (t = [t]), T = 0; T < t.length; T += 1)if (M = t[T], x = l.isConvex(M), d = !x, d && !D && r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), x || !D) x ? M = l.clockwiseSort(M) : M = l.hull(M), g.push({ position: { x: u, y: o }, vertices: M }); else { var E = M.map(function (H) { return [H.x, H.y] }); S.makeCCW(E), c !== !1 && S.removeCollinearPoints(E, c), m !== !1 && S.removeDuplicatePoints && S.removeDuplicatePoints(E, m); var B = S.quickDecomp(E); for (y = 0; y < B.length; y++) { var L = B[y], F = L.map(function (H) { return { x: H[0], y: H[1] } }); p > 0 && l.area(F) < p || g.push({ position: l.centre(F), vertices: F }) } } for (y = 0; y < g.length; y++)g[y] = a.create(r.extend(g[y], s)); if (n) { var V = 5; for (y = 0; y < g.length; y++) { var U = g[y]; for (C = y + 1; C < g.length; C++) { var G = g[C]; if (f.overlaps(U.bounds, G.bounds)) { var z = U.vertices, J = G.vertices; for (P = 0; P < U.vertices.length; P++)for (I = 0; I < G.vertices.length; I++) { var ee = i.magnitudeSquared(i.sub(z[(P + 1) % z.length], J[I])), K = i.magnitudeSquared(i.sub(z[P], J[(I + 1) % J.length])); ee < V && K < V && (z[P].isInternal = !0, J[I].isInternal = !0) } } } } } return g.length > 1 ? (h = a.create(r.extend({ parts: g.slice(0) }, s)), a.setPosition(h, { x: u, y: o }), h) : g[0] } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(0), r = v(8); (function () { e.create = function (a) { var f = { bodies: [], collisions: [], pairs: null }; return l.extend(f, a) }, e.setBodies = function (a, f) { a.bodies = f.slice(0) }, e.clear = function (a) { a.bodies = [], a.collisions = [] }, e.collisions = function (a) { var f = a.pairs, i = a.bodies, u = i.length, o = e.canCollide, t = r.collides, s = a.collisions, n = 0, c, p; for (i.sort(e._compareBoundsX), c = 0; c < u; c++) { var m = i[c], S = m.bounds, D = m.bounds.max.x, h = m.bounds.max.y, g = m.bounds.min.y, x = m.isStatic || m.isSleeping, d = m.parts.length, M = d === 1; for (p = c + 1; p < u; p++) { var y = i[p], C = y.bounds; if (C.min.x > D) break; if (!(h < C.min.y || g > C.max.y) && !(x && (y.isStatic || y.isSleeping)) && o(m.collisionFilter, y.collisionFilter)) { var P = y.parts.length; if (M && P === 1) { var T = t(m, y, f); T && (s[n++] = T) } else for (var I = d > 1 ? 1 : 0, E = P > 1 ? 1 : 0, B = I; B < d; B++)for (var L = m.parts[B], S = L.bounds, F = E; F < P; F++) { var V = y.parts[F], C = V.bounds; if (!(S.min.x > C.max.x || S.max.x < C.min.x || S.max.y < C.min.y || S.min.y > C.max.y)) { var T = t(L, V, f); T && (s[n++] = T) } } } } } return s.length !== n && (s.length = n), s }, e.canCollide = function (a, f) { return a.group === f.group && a.group !== 0 ? a.group > 0 : (a.mask & f.category) !== 0 && (f.mask & a.category) !== 0 }, e._compareBoundsX = function (a, f) { return a.bounds.min.x - f.bounds.min.x } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(0); (function () { e.create = function (r) { var a = {}; return r || l.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), a.element = r || document.body, a.absolute = { x: 0, y: 0 }, a.position = { x: 0, y: 0 }, a.mousedownPosition = { x: 0, y: 0 }, a.mouseupPosition = { x: 0, y: 0 }, a.offset = { x: 0, y: 0 }, a.scale = { x: 1, y: 1 }, a.wheelDelta = 0, a.button = -1, a.pixelRatio = parseInt(a.element.getAttribute("data-pixel-ratio"), 10) || 1, a.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, a.mousemove = function (f) { var i = e._getRelativeMousePosition(f, a.element, a.pixelRatio), u = f.changedTouches; u && (a.button = 0, f.preventDefault()), a.absolute.x = i.x, a.absolute.y = i.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y, a.sourceEvents.mousemove = f }, a.mousedown = function (f) { var i = e._getRelativeMousePosition(f, a.element, a.pixelRatio), u = f.changedTouches; u ? (a.button = 0, f.preventDefault()) : a.button = f.button, a.absolute.x = i.x, a.absolute.y = i.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y, a.mousedownPosition.x = a.position.x, a.mousedownPosition.y = a.position.y, a.sourceEvents.mousedown = f }, a.mouseup = function (f) { var i = e._getRelativeMousePosition(f, a.element, a.pixelRatio), u = f.changedTouches; u && f.preventDefault(), a.button = -1, a.absolute.x = i.x, a.absolute.y = i.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y, a.mouseupPosition.x = a.position.x, a.mouseupPosition.y = a.position.y, a.sourceEvents.mouseup = f }, a.mousewheel = function (f) { a.wheelDelta = Math.max(-1, Math.min(1, f.wheelDelta || -f.detail)), f.preventDefault(), a.sourceEvents.mousewheel = f }, e.setElement(a, a.element), a }, e.setElement = function (r, a) { r.element = a, a.addEventListener("mousemove", r.mousemove, { passive: !0 }), a.addEventListener("mousedown", r.mousedown, { passive: !0 }), a.addEventListener("mouseup", r.mouseup, { passive: !0 }), a.addEventListener("wheel", r.mousewheel, { passive: !1 }), a.addEventListener("touchmove", r.mousemove, { passive: !1 }), a.addEventListener("touchstart", r.mousedown, { passive: !1 }), a.addEventListener("touchend", r.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (r) { r.sourceEvents.mousemove = null, r.sourceEvents.mousedown = null, r.sourceEvents.mouseup = null, r.sourceEvents.mousewheel = null, r.wheelDelta = 0 }, e.setOffset = function (r, a) { r.offset.x = a.x, r.offset.y = a.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y }, e.setScale = function (r, a) { r.scale.x = a.x, r.scale.y = a.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y }, e._getRelativeMousePosition = function (r, a, f) { var i = a.getBoundingClientRect(), u = document.documentElement || document.body.parentNode || document.body, o = window.pageXOffset !== void 0 ? window.pageXOffset : u.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : u.scrollTop, s = r.changedTouches, n, c; return s ? (n = s[0].pageX - i.left - o, c = s[0].pageY - i.top - t) : (n = r.pageX - i.left - o, c = r.pageY - i.top - t), { x: n / (a.clientWidth / (a.width || a.clientWidth) * f), y: c / (a.clientHeight / (a.height || a.clientHeight) * f) } } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(0); (function () { e._registry = {}, e.register = function (r) { if (e.isPlugin(r) || l.warn("Plugin.register:", e.toString(r), "does not implement all required fields."), r.name in e._registry) { var a = e._registry[r.name], f = e.versionParse(r.version).number, i = e.versionParse(a.version).number; f > i ? (l.warn("Plugin.register:", e.toString(a), "was upgraded to", e.toString(r)), e._registry[r.name] = r) : f < i ? l.warn("Plugin.register:", e.toString(a), "can not be downgraded to", e.toString(r)) : r !== a && l.warn("Plugin.register:", e.toString(r), "is already registered to different plugin object") } else e._registry[r.name] = r; return r }, e.resolve = function (r) { return e._registry[e.dependencyParse(r).name] }, e.toString = function (r) { return typeof r == "string" ? r : (r.name || "anonymous") + "@" + (r.version || r.range || "0.0.0") }, e.isPlugin = function (r) { return r && r.name && r.version && r.install }, e.isUsed = function (r, a) { return r.used.indexOf(a) > -1 }, e.isFor = function (r, a) { var f = r.for && e.dependencyParse(r.for); return !r.for || a.name === f.name && e.versionSatisfies(a.version, f.range) }, e.use = function (r, a) { if (r.uses = (r.uses || []).concat(a || []), r.uses.length === 0) { l.warn("Plugin.use:", e.toString(r), "does not specify any dependencies to install."); return } for (var f = e.dependencies(r), i = l.topologicalSort(f), u = [], o = 0; o < i.length; o += 1)if (i[o] !== r.name) { var t = e.resolve(i[o]); if (!t) { u.push("âŒ " + i[o]); continue } e.isUsed(r, t.name) || (e.isFor(t, r) || (l.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(r) + "."), t._warned = !0), t.install ? t.install(r) : (l.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (u.push("ðŸ”¶ " + e.toString(t)), delete t._warned) : u.push("âœ… " + e.toString(t)), r.used.push(t.name)) } u.length > 0 && l.info(u.join("  ")) }, e.dependencies = function (r, a) { var f = e.dependencyParse(r), i = f.name; if (a = a || {}, !(i in a)) { r = e.resolve(r) || r, a[i] = l.map(r.uses || [], function (o) { e.isPlugin(o) && e.register(o); var t = e.dependencyParse(o), s = e.resolve(o); return s && !e.versionSatisfies(s.version, t.range) ? (l.warn("Plugin.dependencies:", e.toString(s), "does not satisfy", e.toString(t), "used by", e.toString(f) + "."), s._warned = !0, r._warned = !0) : s || (l.warn("Plugin.dependencies:", e.toString(o), "used by", e.toString(f), "could not be resolved."), r._warned = !0), t.name }); for (var u = 0; u < a[i].length; u += 1)e.dependencies(a[i][u], a); return a } }, e.dependencyParse = function (r) { if (l.isString(r)) { var a = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return a.test(r) || l.warn("Plugin.dependencyParse:", r, "is not a valid dependency string."), { name: r.split("@")[0], range: r.split("@")[1] || "*" } } return { name: r.name, range: r.range || r.version } }, e.versionParse = function (r) { var a = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; a.test(r) || l.warn("Plugin.versionParse:", r, "is not a valid version or range."); var f = a.exec(r), i = Number(f[4]), u = Number(f[5]), o = Number(f[6]); return { isRange: !!(f[1] || f[2]), version: f[3], range: r, operator: f[1] || f[2] || "", major: i, minor: u, patch: o, parts: [i, u, o], prerelease: f[7], number: i * 1e8 + u * 1e4 + o } }, e.versionSatisfies = function (r, a) { a = a || "*"; var f = e.versionParse(a), i = e.versionParse(r); if (f.isRange) { if (f.operator === "*" || r === "*") return !0; if (f.operator === ">") return i.number > f.number; if (f.operator === ">=") return i.number >= f.number; if (f.operator === "~") return i.major === f.major && i.minor === f.minor && i.patch >= f.patch; if (f.operator === "^") return f.major > 0 ? i.major === f.major && i.number >= f.number : f.minor > 0 ? i.minor === f.minor && i.patch >= f.patch : i.patch === f.patch } return r === a || r === "*" } })() }, function (w, O) { var v = {}; w.exports = v, function () { v.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(7), r = v(18), a = v(13), f = v(19), i = v(5), u = v(6), o = v(10), t = v(0), s = v(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (n) { n = n || {}; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, p = t.extend(c, n); return p.world = n.world || u.create({ label: "World" }), p.pairs = n.pairs || f.create(), p.detector = n.detector || a.create(), p.detector.pairs = p.pairs, p.grid = { buckets: [] }, p.world.gravity = p.gravity, p.broadphase = p.grid, p.metrics = {}, p }, e.update = function (n, c) { var p = t.now(), m = n.world, S = n.detector, D = n.pairs, h = n.timing, g = h.timestamp, x; c > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), c = typeof c < "u" ? c : t._baseDelta, c *= h.timeScale, h.timestamp += c, h.lastDelta = c; var d = { timestamp: h.timestamp, delta: c }; i.trigger(n, "beforeUpdate", d); var M = u.allBodies(m), y = u.allConstraints(m); for (m.isModified && (a.setBodies(S, M), u.setModified(m, !1, !1, !0)), n.enableSleeping && l.update(M, c), e._bodiesApplyGravity(M, n.gravity), c > 0 && e._bodiesUpdate(M, c), i.trigger(n, "beforeSolve", d), o.preSolveAll(M), x = 0; x < n.constraintIterations; x++)o.solveAll(y, c); o.postSolveAll(M); var C = a.collisions(S); f.update(D, C, g), n.enableSleeping && l.afterCollisions(D.list), D.collisionStart.length > 0 && i.trigger(n, "collisionStart", { pairs: D.collisionStart, timestamp: h.timestamp, delta: c }); var P = t.clamp(20 / n.positionIterations, 0, 1); for (r.preSolvePosition(D.list), x = 0; x < n.positionIterations; x++)r.solvePosition(D.list, c, P); for (r.postSolvePosition(M), o.preSolveAll(M), x = 0; x < n.constraintIterations; x++)o.solveAll(y, c); for (o.postSolveAll(M), r.preSolveVelocity(D.list), x = 0; x < n.velocityIterations; x++)r.solveVelocity(D.list, c); return e._bodiesUpdateVelocities(M), D.collisionActive.length > 0 && i.trigger(n, "collisionActive", { pairs: D.collisionActive, timestamp: h.timestamp, delta: c }), D.collisionEnd.length > 0 && i.trigger(n, "collisionEnd", { pairs: D.collisionEnd, timestamp: h.timestamp, delta: c }), e._bodiesClearForces(M), i.trigger(n, "afterUpdate", d), n.timing.lastElapsed = t.now() - p, n }, e.merge = function (n, c) { if (t.extend(n, c), c.world) { n.world = c.world, e.clear(n); for (var p = u.allBodies(n.world), m = 0; m < p.length; m++) { var S = p[m]; l.set(S, !1), S.id = t.nextId() } } }, e.clear = function (n) { f.clear(n.pairs), a.clear(n.detector) }, e._bodiesClearForces = function (n) { for (var c = n.length, p = 0; p < c; p++) { var m = n[p]; m.force.x = 0, m.force.y = 0, m.torque = 0 } }, e._bodiesApplyGravity = function (n, c) { var p = typeof c.scale < "u" ? c.scale : .001, m = n.length; if (!(c.x === 0 && c.y === 0 || p === 0)) for (var S = 0; S < m; S++) { var D = n[S]; D.isStatic || D.isSleeping || (D.force.y += D.mass * c.y * p, D.force.x += D.mass * c.x * p) } }, e._bodiesUpdate = function (n, c) { for (var p = n.length, m = 0; m < p; m++) { var S = n[m]; S.isStatic || S.isSleeping || s.update(S, c) } }, e._bodiesUpdateVelocities = function (n) { for (var c = n.length, p = 0; p < c; p++)s.updateVelocities(n[p]) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(0), a = v(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (f) { var i, u, o, t = f.length; for (i = 0; i < t; i++)u = f[i], u.isActive && (o = u.contactCount, u.collision.parentA.totalContacts += o, u.collision.parentB.totalContacts += o) }, e.solvePosition = function (f, i, u) { var o, t, s, n, c, p, m, S, D = e._positionDampen * (u || 1), h = r.clamp(i / r._baseDelta, 0, 1), g = f.length; for (o = 0; o < g; o++)t = f[o], !(!t.isActive || t.isSensor) && (s = t.collision, n = s.parentA, c = s.parentB, p = s.normal, t.separation = s.depth + p.x * (c.positionImpulse.x - n.positionImpulse.x) + p.y * (c.positionImpulse.y - n.positionImpulse.y)); for (o = 0; o < g; o++)t = f[o], !(!t.isActive || t.isSensor) && (s = t.collision, n = s.parentA, c = s.parentB, p = s.normal, S = t.separation - t.slop * h, (n.isStatic || c.isStatic) && (S *= 2), n.isStatic || n.isSleeping || (m = D / n.totalContacts, n.positionImpulse.x += p.x * S * m, n.positionImpulse.y += p.y * S * m), c.isStatic || c.isSleeping || (m = D / c.totalContacts, c.positionImpulse.x -= p.x * S * m, c.positionImpulse.y -= p.y * S * m)) }, e.postSolvePosition = function (f) { for (var i = e._positionWarming, u = f.length, o = l.translate, t = a.update, s = 0; s < u; s++) { var n = f[s], c = n.positionImpulse, p = c.x, m = c.y, S = n.velocity; if (n.totalContacts = 0, p !== 0 || m !== 0) { for (var D = 0; D < n.parts.length; D++) { var h = n.parts[D]; o(h.vertices, c), t(h.bounds, h.vertices, S), h.position.x += p, h.position.y += m } n.positionPrev.x += p, n.positionPrev.y += m, p * S.x + m * S.y < 0 ? (c.x = 0, c.y = 0) : (c.x *= i, c.y *= i) } } }, e.preSolveVelocity = function (f) { var i = f.length, u, o; for (u = 0; u < i; u++) { var t = f[u]; if (!(!t.isActive || t.isSensor)) { var s = t.contacts, n = t.contactCount, c = t.collision, p = c.parentA, m = c.parentB, S = c.normal, D = c.tangent; for (o = 0; o < n; o++) { var h = s[o], g = h.vertex, x = h.normalImpulse, d = h.tangentImpulse; if (x !== 0 || d !== 0) { var M = S.x * x + D.x * d, y = S.y * x + D.y * d; p.isStatic || p.isSleeping || (p.positionPrev.x += M * p.inverseMass, p.positionPrev.y += y * p.inverseMass, p.anglePrev += p.inverseInertia * ((g.x - p.position.x) * y - (g.y - p.position.y) * M)), m.isStatic || m.isSleeping || (m.positionPrev.x -= M * m.inverseMass, m.positionPrev.y -= y * m.inverseMass, m.anglePrev -= m.inverseInertia * ((g.x - m.position.x) * y - (g.y - m.position.y) * M)) } } } } }, e.solveVelocity = function (f, i) { var u = i / r._baseDelta, o = u * u, t = o * u, s = -e._restingThresh * u, n = e._restingThreshTangent, c = e._frictionNormalMultiplier * u, p = e._frictionMaxStatic, m = f.length, S, D, h, g; for (h = 0; h < m; h++) { var x = f[h]; if (!(!x.isActive || x.isSensor)) { var d = x.collision, M = d.parentA, y = d.parentB, C = d.normal.x, P = d.normal.y, T = d.tangent.x, I = d.tangent.y, E = x.inverseMass, B = x.friction * x.frictionStatic * c, L = x.contacts, F = x.contactCount, V = 1 / F, U = M.position.x - M.positionPrev.x, G = M.position.y - M.positionPrev.y, z = M.angle - M.anglePrev, J = y.position.x - y.positionPrev.x, ee = y.position.y - y.positionPrev.y, K = y.angle - y.anglePrev; for (g = 0; g < F; g++) { var H = L[g], X = H.vertex, $ = X.x - M.position.x, re = X.y - M.position.y, q = X.x - y.position.x, Y = X.y - y.position.y, Z = U - re * z, Ue = G + $ * z, be = J - Y * K, Ne = ee + q * K, we = Z - be, Ce = Ue - Ne, de = C * we + P * Ce, _ = T * we + I * Ce, Pe = x.separation + de, pe = Math.min(Pe, 1); pe = Pe < 0 ? 0 : pe; var De = pe * B; _ < -De || _ > De ? (D = _ > 0 ? _ : -_, S = x.friction * (_ > 0 ? 1 : -1) * t, S < -D ? S = -D : S > D && (S = D)) : (S = _, D = p); var Oe = $ * P - re * C, Ae = q * P - Y * C, Te = V / (E + M.inverseInertia * Oe * Oe + y.inverseInertia * Ae * Ae), fe = (1 + x.restitution) * de * Te; if (S *= Te, de < s) H.normalImpulse = 0; else { var Ge = H.normalImpulse; H.normalImpulse += fe, H.normalImpulse > 0 && (H.normalImpulse = 0), fe = H.normalImpulse - Ge } if (_ < -n || _ > n) H.tangentImpulse = 0; else { var ze = H.tangentImpulse; H.tangentImpulse += S, H.tangentImpulse < -D && (H.tangentImpulse = -D), H.tangentImpulse > D && (H.tangentImpulse = D), S = H.tangentImpulse - ze } var ue = C * fe + T * S, he = P * fe + I * S; M.isStatic || M.isSleeping || (M.positionPrev.x += ue * M.inverseMass, M.positionPrev.y += he * M.inverseMass, M.anglePrev += ($ * he - re * ue) * M.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= ue * y.inverseMass, y.positionPrev.y -= he * y.inverseMass, y.anglePrev -= (q * he - Y * ue) * y.inverseInertia) } } } } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(9), r = v(0); (function () { e.create = function (a) { return r.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, a) }, e.update = function (a, f, i) { var u = l.update, o = l.create, t = l.setActive, s = a.table, n = a.list, c = n.length, p = c, m = a.collisionStart, S = a.collisionEnd, D = a.collisionActive, h = f.length, g = 0, x = 0, d = 0, M, y, C; for (C = 0; C < h; C++)M = f[C], y = M.pair, y ? (y.isActive && (D[d++] = y), u(y, M, i)) : (y = o(M, i), s[y.id] = y, m[g++] = y, n[p++] = y); for (p = 0, c = n.length, C = 0; C < c; C++)y = n[C], y.timeUpdated >= i ? n[p++] = y : (t(y, !1, i), y.collision.bodyA.sleepCounter > 0 && y.collision.bodyB.sleepCounter > 0 ? n[p++] = y : (S[x++] = y, delete s[y.id])); n.length !== p && (n.length = p), m.length !== g && (m.length = g), S.length !== x && (S.length = x), D.length !== d && (D.length = d) }, e.clear = function (a) { return a.table = {}, a.list.length = 0, a.collisionStart.length = 0, a.collisionActive.length = 0, a.collisionEnd.length = 0, a } })() }, function (w, O, v) { var e = w.exports = v(21); e.Axes = v(11), e.Bodies = v(12), e.Body = v(4), e.Bounds = v(1), e.Collision = v(8), e.Common = v(0), e.Composite = v(6), e.Composites = v(22), e.Constraint = v(10), e.Contact = v(16), e.Detector = v(13), e.Engine = v(17), e.Events = v(5), e.Grid = v(23), e.Mouse = v(14), e.MouseConstraint = v(24), e.Pair = v(9), e.Pairs = v(19), e.Plugin = v(15), e.Query = v(25), e.Render = v(26), e.Resolver = v(18), e.Runner = v(27), e.SAT = v(28), e.Sleeping = v(7), e.Svg = v(29), e.Vector = v(2), e.Vertices = v(3), e.World = v(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run âž¤ use Matter.Runner.run(engine) instead") }, function (w, O, v) { var e = {}; w.exports = e; var l = v(15), r = v(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { l.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (a, f) { return a = a.replace(/^Matter./, ""), r.chainPathBefore(e, a, f) }, e.after = function (a, f) { return a = a.replace(/^Matter./, ""), r.chainPathAfter(e, a, f) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(6), r = v(10), a = v(0), f = v(4), i = v(12), u = a.deprecated; (function () { e.stack = function (o, t, s, n, c, p, m) { for (var S = l.create({ label: "Stack" }), D = o, h = t, g, x = 0, d = 0; d < n; d++) { for (var M = 0, y = 0; y < s; y++) { var C = m(D, h, y, d, g, x); if (C) { var P = C.bounds.max.y - C.bounds.min.y, T = C.bounds.max.x - C.bounds.min.x; P > M && (M = P), f.translate(C, { x: T * .5, y: P * .5 }), D = C.bounds.max.x + c, l.addBody(S, C), g = C, x += 1 } else D += c } h += M + p, D = o } return S }, e.chain = function (o, t, s, n, c, p) { for (var m = o.bodies, S = 1; S < m.length; S++) { var D = m[S - 1], h = m[S], g = D.bounds.max.y - D.bounds.min.y, x = D.bounds.max.x - D.bounds.min.x, d = h.bounds.max.y - h.bounds.min.y, M = h.bounds.max.x - h.bounds.min.x, y = { bodyA: D, pointA: { x: x * t, y: g * s }, bodyB: h, pointB: { x: M * n, y: d * c } }, C = a.extend(y, p); l.addConstraint(o, r.create(C)) } return o.label += " Chain", o }, e.mesh = function (o, t, s, n, c) { var p = o.bodies, m, S, D, h, g; for (m = 0; m < s; m++) { for (S = 1; S < t; S++)D = p[S - 1 + m * t], h = p[S + m * t], l.addConstraint(o, r.create(a.extend({ bodyA: D, bodyB: h }, c))); if (m > 0) for (S = 0; S < t; S++)D = p[S + (m - 1) * t], h = p[S + m * t], l.addConstraint(o, r.create(a.extend({ bodyA: D, bodyB: h }, c))), n && S > 0 && (g = p[S - 1 + (m - 1) * t], l.addConstraint(o, r.create(a.extend({ bodyA: g, bodyB: h }, c)))), n && S < t - 1 && (g = p[S + 1 + (m - 1) * t], l.addConstraint(o, r.create(a.extend({ bodyA: g, bodyB: h }, c)))) } return o.label += " Mesh", o }, e.pyramid = function (o, t, s, n, c, p, m) { return e.stack(o, t, s, n, c, p, function (S, D, h, g, x, d) { var M = Math.min(n, Math.ceil(s / 2)), y = x ? x.bounds.max.x - x.bounds.min.x : 0; if (!(g > M)) { g = M - g; var C = g, P = s - 1 - g; if (!(h < C || h > P)) { d === 1 && f.translate(x, { x: (h + (s % 2 === 1 ? 1 : -1)) * y, y: 0 }); var T = x ? h * y : 0; return m(o + T + h * c, D, h, g, x, d) } } }) }, e.newtonsCradle = function (o, t, s, n, c) { for (var p = l.create({ label: "Newtons Cradle" }), m = 0; m < s; m++) { var S = 1.9, D = i.circle(o + m * (n * S), t + c, n, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), h = r.create({ pointA: { x: o + m * (n * S), y: t }, bodyB: D }); l.addBody(p, D), l.addConstraint(p, h) } return p }, u(e, "newtonsCradle", "Composites.newtonsCradle âž¤ moved to newtonsCradle example"), e.car = function (o, t, s, n, c) { var p = f.nextGroup(!0), m = 20, S = -s * .5 + m, D = s * .5 - m, h = 0, g = l.create({ label: "Car" }), x = i.rectangle(o, t, s, n, { collisionFilter: { group: p }, chamfer: { radius: n * .5 }, density: 2e-4 }), d = i.circle(o + S, t + h, c, { collisionFilter: { group: p }, friction: .8 }), M = i.circle(o + D, t + h, c, { collisionFilter: { group: p }, friction: .8 }), y = r.create({ bodyB: x, pointB: { x: S, y: h }, bodyA: d, stiffness: 1, length: 0 }), C = r.create({ bodyB: x, pointB: { x: D, y: h }, bodyA: M, stiffness: 1, length: 0 }); return l.addBody(g, x), l.addBody(g, d), l.addBody(g, M), l.addConstraint(g, y), l.addConstraint(g, C), g }, u(e, "car", "Composites.car âž¤ moved to car example"), e.softBody = function (o, t, s, n, c, p, m, S, D, h) { D = a.extend({ inertia: 1 / 0 }, D), h = a.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, h); var g = e.stack(o, t, s, n, c, p, function (x, d) { return i.circle(x, d, S, D) }); return e.mesh(g, s, n, m, h), g.label = "Soft Body", g }, u(e, "softBody", "Composites.softBody âž¤ moved to softBody and cloth examples") })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(9), r = v(0), a = r.deprecated; (function () { e.create = function (f) { var i = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return r.extend(i, f) }, e.update = function (f, i, u, o) { var t, s, n, c = u.world, p = f.buckets, m, S, D = !1; for (t = 0; t < i.length; t++) { var h = i[t]; if (!(h.isSleeping && !o) && !(c.bounds && (h.bounds.max.x < c.bounds.min.x || h.bounds.min.x > c.bounds.max.x || h.bounds.max.y < c.bounds.min.y || h.bounds.min.y > c.bounds.max.y))) { var g = e._getRegion(f, h); if (!h.region || g.id !== h.region.id || o) { (!h.region || o) && (h.region = g); var x = e._regionUnion(g, h.region); for (s = x.startCol; s <= x.endCol; s++)for (n = x.startRow; n <= x.endRow; n++) { S = e._getBucketId(s, n), m = p[S]; var d = s >= g.startCol && s <= g.endCol && n >= g.startRow && n <= g.endRow, M = s >= h.region.startCol && s <= h.region.endCol && n >= h.region.startRow && n <= h.region.endRow; !d && M && M && m && e._bucketRemoveBody(f, m, h), (h.region === g || d && !M || o) && (m || (m = e._createBucket(p, S)), e._bucketAddBody(f, m, h)) } h.region = g, D = !0 } } } D && (f.pairsList = e._createActivePairsList(f)) }, a(e, "update", "Grid.update âž¤ replaced by Matter.Detector"), e.clear = function (f) { f.buckets = {}, f.pairs = {}, f.pairsList = [] }, a(e, "clear", "Grid.clear âž¤ replaced by Matter.Detector"), e._regionUnion = function (f, i) { var u = Math.min(f.startCol, i.startCol), o = Math.max(f.endCol, i.endCol), t = Math.min(f.startRow, i.startRow), s = Math.max(f.endRow, i.endRow); return e._createRegion(u, o, t, s) }, e._getRegion = function (f, i) { var u = i.bounds, o = Math.floor(u.min.x / f.bucketWidth), t = Math.floor(u.max.x / f.bucketWidth), s = Math.floor(u.min.y / f.bucketHeight), n = Math.floor(u.max.y / f.bucketHeight); return e._createRegion(o, t, s, n) }, e._createRegion = function (f, i, u, o) { return { id: f + "," + i + "," + u + "," + o, startCol: f, endCol: i, startRow: u, endRow: o } }, e._getBucketId = function (f, i) { return "C" + f + "R" + i }, e._createBucket = function (f, i) { var u = f[i] = []; return u }, e._bucketAddBody = function (f, i, u) { var o = f.pairs, t = l.id, s = i.length, n; for (n = 0; n < s; n++) { var c = i[n]; if (!(u.id === c.id || u.isStatic && c.isStatic)) { var p = t(u, c), m = o[p]; m ? m[2] += 1 : o[p] = [u, c, 1] } } i.push(u) }, e._bucketRemoveBody = function (f, i, u) { var o = f.pairs, t = l.id, s; i.splice(r.indexOf(i, u), 1); var n = i.length; for (s = 0; s < n; s++) { var c = o[t(u, i[s])]; c && (c[2] -= 1) } }, e._createActivePairsList = function (f) { var i, u = f.pairs, o = r.keys(u), t = o.length, s = [], n; for (n = 0; n < t; n++)i = u[o[n]], i[2] > 0 ? s.push(i) : delete u[o[n]]; return s } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(3), r = v(7), a = v(14), f = v(5), i = v(13), u = v(10), o = v(6), t = v(0), s = v(1); (function () { e.create = function (n, c) { var p = (n ? n.mouse : null) || (c ? c.mouse : null); p || (n && n.render && n.render.canvas ? p = a.create(n.render.canvas) : c && c.element ? p = a.create(c.element) : (p = a.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var m = u.create({ label: "Mouse Constraint", pointA: p.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), S = { type: "mouseConstraint", mouse: p, element: null, body: null, constraint: m, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, D = t.extend(S, c); return f.on(n, "beforeUpdate", function () { var h = o.allBodies(n.world); e.update(D, h), e._triggerEvents(D) }), D }, e.update = function (n, c) { var p = n.mouse, m = n.constraint, S = n.body; if (p.button === 0) { if (m.bodyB) r.set(m.bodyB, !1), m.pointA = p.position; else for (var D = 0; D < c.length; D++)if (S = c[D], s.contains(S.bounds, p.position) && i.canCollide(S.collisionFilter, n.collisionFilter)) for (var h = S.parts.length > 1 ? 1 : 0; h < S.parts.length; h++) { var g = S.parts[h]; if (l.contains(g.vertices, p.position)) { m.pointA = p.position, m.bodyB = n.body = S, m.pointB = { x: p.position.x - S.position.x, y: p.position.y - S.position.y }, m.angleB = S.angle, r.set(S, !1), f.trigger(n, "startdrag", { mouse: p, body: S }); break } } } else m.bodyB = n.body = null, m.pointB = null, S && f.trigger(n, "enddrag", { mouse: p, body: S }) }, e._triggerEvents = function (n) { var c = n.mouse, p = c.sourceEvents; p.mousemove && f.trigger(n, "mousemove", { mouse: c }), p.mousedown && f.trigger(n, "mousedown", { mouse: c }), p.mouseup && f.trigger(n, "mouseup", { mouse: c }), a.clearSourceEvents(c) } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(2), r = v(8), a = v(1), f = v(12), i = v(3); (function () { e.collides = function (u, o) { for (var t = [], s = o.length, n = u.bounds, c = r.collides, p = a.overlaps, m = 0; m < s; m++) { var S = o[m], D = S.parts.length, h = D === 1 ? 0 : 1; if (p(S.bounds, n)) for (var g = h; g < D; g++) { var x = S.parts[g]; if (p(x.bounds, n)) { var d = c(x, u); if (d) { t.push(d); break } } } } return t }, e.ray = function (u, o, t, s) { s = s || 1e-100; for (var n = l.angle(o, t), c = l.magnitude(l.sub(o, t)), p = (t.x + o.x) * .5, m = (t.y + o.y) * .5, S = f.rectangle(p, m, c, s, { angle: n }), D = e.collides(S, u), h = 0; h < D.length; h += 1) { var g = D[h]; g.body = g.bodyB = g.bodyA } return D }, e.region = function (u, o, t) { for (var s = [], n = 0; n < u.length; n++) { var c = u[n], p = a.overlaps(c.bounds, o); (p && !t || !p && t) && s.push(c) } return s }, e.point = function (u, o) { for (var t = [], s = 0; s < u.length; s++) { var n = u[s]; if (a.contains(n.bounds, o)) for (var c = n.parts.length === 1 ? 0 : 1; c < n.parts.length; c++) { var p = n.parts[c]; if (a.contains(p.bounds, o) && i.contains(p.vertices, o)) { t.push(n); break } } } return t } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(4), r = v(0), a = v(6), f = v(1), i = v(5), u = v(2), o = v(14); (function () { var t, s; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (h) { window.setTimeout(function () { h(r.now()) }, 1e3 / 60) }, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (h) { var g = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!h.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, x = r.extend(g, h); return x.canvas && (x.canvas.width = x.options.width || x.canvas.width, x.canvas.height = x.options.height || x.canvas.height), x.mouse = h.mouse, x.engine = h.engine, x.canvas = x.canvas || p(x.options.width, x.options.height), x.context = x.canvas.getContext("2d"), x.textures = {}, x.bounds = x.bounds || { min: { x: 0, y: 0 }, max: { x: x.canvas.width, y: x.canvas.height } }, x.controller = e, x.options.showBroadphase = !1, x.options.pixelRatio !== 1 && e.setPixelRatio(x, x.options.pixelRatio), r.isElement(x.element) && x.element.appendChild(x.canvas), x }, e.run = function (h) { (function g(x) { h.frameRequestId = t(g), n(h, x), e.world(h, x), h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0), (h.options.showStats || h.options.showDebug) && e.stats(h, h.context, x), (h.options.showPerformance || h.options.showDebug) && e.performance(h, h.context, x), h.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (h) { s(h.frameRequestId) }, e.setPixelRatio = function (h, g) { var x = h.options, d = h.canvas; g === "auto" && (g = m(d)), x.pixelRatio = g, d.setAttribute("data-pixel-ratio", g), d.width = x.width * g, d.height = x.height * g, d.style.width = x.width + "px", d.style.height = x.height + "px" }, e.setSize = function (h, g, x) { h.options.width = g, h.options.height = x, h.bounds.max.x = h.bounds.min.x + g, h.bounds.max.y = h.bounds.min.y + x, h.options.pixelRatio !== 1 ? e.setPixelRatio(h, h.options.pixelRatio) : (h.canvas.width = g, h.canvas.height = x) }, e.lookAt = function (h, g, x, d) { d = typeof d < "u" ? d : !0, g = r.isArray(g) ? g : [g], x = x || { x: 0, y: 0 }; for (var M = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, y = 0; y < g.length; y += 1) { var C = g[y], P = C.bounds ? C.bounds.min : C.min || C.position || C, T = C.bounds ? C.bounds.max : C.max || C.position || C; P && T && (P.x < M.min.x && (M.min.x = P.x), T.x > M.max.x && (M.max.x = T.x), P.y < M.min.y && (M.min.y = P.y), T.y > M.max.y && (M.max.y = T.y)) } var I = M.max.x - M.min.x + 2 * x.x, E = M.max.y - M.min.y + 2 * x.y, B = h.canvas.height, L = h.canvas.width, F = L / B, V = I / E, U = 1, G = 1; V > F ? G = V / F : U = F / V, h.options.hasBounds = !0, h.bounds.min.x = M.min.x, h.bounds.max.x = M.min.x + I * U, h.bounds.min.y = M.min.y, h.bounds.max.y = M.min.y + E * G, d && (h.bounds.min.x += I * .5 - I * U * .5, h.bounds.max.x += I * .5 - I * U * .5, h.bounds.min.y += E * .5 - E * G * .5, h.bounds.max.y += E * .5 - E * G * .5), h.bounds.min.x -= x.x, h.bounds.max.x -= x.x, h.bounds.min.y -= x.y, h.bounds.max.y -= x.y, h.mouse && (o.setScale(h.mouse, { x: (h.bounds.max.x - h.bounds.min.x) / h.canvas.width, y: (h.bounds.max.y - h.bounds.min.y) / h.canvas.height }), o.setOffset(h.mouse, h.bounds.min)) }, e.startViewTransform = function (h) { var g = h.bounds.max.x - h.bounds.min.x, x = h.bounds.max.y - h.bounds.min.y, d = g / h.options.width, M = x / h.options.height; h.context.setTransform(h.options.pixelRatio / d, 0, 0, h.options.pixelRatio / M, 0, 0), h.context.translate(-h.bounds.min.x, -h.bounds.min.y) }, e.endViewTransform = function (h) { h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0) }, e.world = function (h, g) { var x = r.now(), d = h.engine, M = d.world, y = h.canvas, C = h.context, P = h.options, T = h.timing, I = a.allBodies(M), E = a.allConstraints(M), B = P.wireframes ? P.wireframeBackground : P.background, L = [], F = [], V, U = { timestamp: d.timing.timestamp }; if (i.trigger(h, "beforeRender", U), h.currentBackground !== B && D(h, B), C.globalCompositeOperation = "source-in", C.fillStyle = "transparent", C.fillRect(0, 0, y.width, y.height), C.globalCompositeOperation = "source-over", P.hasBounds) { for (V = 0; V < I.length; V++) { var G = I[V]; f.overlaps(G.bounds, h.bounds) && L.push(G) } for (V = 0; V < E.length; V++) { var z = E[V], J = z.bodyA, ee = z.bodyB, K = z.pointA, H = z.pointB; J && (K = u.add(J.position, z.pointA)), ee && (H = u.add(ee.position, z.pointB)), !(!K || !H) && (f.contains(h.bounds, K) || f.contains(h.bounds, H)) && F.push(z) } e.startViewTransform(h), h.mouse && (o.setScale(h.mouse, { x: (h.bounds.max.x - h.bounds.min.x) / h.options.width, y: (h.bounds.max.y - h.bounds.min.y) / h.options.height }), o.setOffset(h.mouse, h.bounds.min)) } else F = E, L = I, h.options.pixelRatio !== 1 && h.context.setTransform(h.options.pixelRatio, 0, 0, h.options.pixelRatio, 0, 0); !P.wireframes || d.enableSleeping && P.showSleeping ? e.bodies(h, L, C) : (P.showConvexHulls && e.bodyConvexHulls(h, L, C), e.bodyWireframes(h, L, C)), P.showBounds && e.bodyBounds(h, L, C), (P.showAxes || P.showAngleIndicator) && e.bodyAxes(h, L, C), P.showPositions && e.bodyPositions(h, L, C), P.showVelocity && e.bodyVelocity(h, L, C), P.showIds && e.bodyIds(h, L, C), P.showSeparations && e.separations(h, d.pairs.list, C), P.showCollisions && e.collisions(h, d.pairs.list, C), P.showVertexNumbers && e.vertexNumbers(h, L, C), P.showMousePosition && e.mousePosition(h, h.mouse, C), e.constraints(F, C), P.hasBounds && e.endViewTransform(h), i.trigger(h, "afterRender", U), T.lastElapsed = r.now() - x }, e.stats = function (h, g, x) { for (var d = h.engine, M = d.world, y = a.allBodies(M), C = 0, P = 55, T = 44, I = 0, E = 0, B = 0; B < y.length; B += 1)C += y[B].parts.length; var L = { Part: C, Body: y.length, Cons: a.allConstraints(M).length, Comp: a.allComposites(M).length, Pair: d.pairs.list.length }; g.fillStyle = "#0e0f19", g.fillRect(I, E, P * 5.5, T), g.font = "12px Arial", g.textBaseline = "top", g.textAlign = "right"; for (var F in L) { var V = L[F]; g.fillStyle = "#aaa", g.fillText(F, I + P, E + 8), g.fillStyle = "#eee", g.fillText(V, I + P, E + 26), I += P } }, e.performance = function (h, g) { var x = h.engine, d = h.timing, M = d.deltaHistory, y = d.elapsedHistory, C = d.timestampElapsedHistory, P = d.engineDeltaHistory, T = d.engineUpdatesHistory, I = d.engineElapsedHistory, E = x.timing.lastUpdatesPerFrame, B = x.timing.lastDelta, L = c(M), F = c(y), V = c(P), U = c(T), G = c(I), z = c(C), J = z / L || 0, ee = Math.round(L / B), K = 1e3 / L || 0, H = 4, X = 12, $ = 60, re = 34, q = 10, Y = 69; g.fillStyle = "#0e0f19", g.fillRect(0, 50, X * 5 + $ * 6 + 22, re), e.status(g, q, Y, $, H, M.length, Math.round(K) + " fps", K / e._goodFps, function (Z) { return M[Z] / L - 1 }), e.status(g, q + X + $, Y, $, H, P.length, B.toFixed(2) + " dt", e._goodDelta / B, function (Z) { return P[Z] / V - 1 }), e.status(g, q + (X + $) * 2, Y, $, H, T.length, E + " upf", Math.pow(r.clamp(U / ee || 1, 0, 1), 4), function (Z) { return T[Z] / U - 1 }), e.status(g, q + (X + $) * 3, Y, $, H, I.length, G.toFixed(2) + " ut", 1 - E * G / e._goodFps, function (Z) { return I[Z] / G - 1 }), e.status(g, q + (X + $) * 4, Y, $, H, y.length, F.toFixed(2) + " rt", 1 - F / e._goodFps, function (Z) { return y[Z] / F - 1 }), e.status(g, q + (X + $) * 5, Y, $, H, C.length, J.toFixed(2) + " x", J * J * J, function (Z) { return (C[Z] / M[Z] / J || 0) - 1 }) }, e.status = function (h, g, x, d, M, y, C, P, T) { h.strokeStyle = "#888", h.fillStyle = "#444", h.lineWidth = 1, h.fillRect(g, x + 7, d, 1), h.beginPath(), h.moveTo(g, x + 7 - M * r.clamp(.4 * T(0), -2, 2)); for (var I = 0; I < d; I += 1)h.lineTo(g + I, x + 7 - (I < y ? M * r.clamp(.4 * T(I), -2, 2) : 0)); h.stroke(), h.fillStyle = "hsl(" + r.clamp(25 + 95 * P, 0, 120) + ",100%,60%)", h.fillRect(g, x - 7, 4, 4), h.font = "12px Arial", h.textBaseline = "middle", h.textAlign = "right", h.fillStyle = "#eee", h.fillText(C, g + d, x - 5) }, e.constraints = function (h, g) { for (var x = g, d = 0; d < h.length; d++) { var M = h[d]; if (!(!M.render.visible || !M.pointA || !M.pointB)) { var y = M.bodyA, C = M.bodyB, P, T; if (y ? P = u.add(y.position, M.pointA) : P = M.pointA, M.render.type === "pin") x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.closePath(); else { if (C ? T = u.add(C.position, M.pointB) : T = M.pointB, x.beginPath(), x.moveTo(P.x, P.y), M.render.type === "spring") for (var I = u.sub(T, P), E = u.perp(u.normalise(I)), B = Math.ceil(r.clamp(M.length / 5, 12, 20)), L, F = 1; F < B; F += 1)L = F % 2 === 0 ? 1 : -1, x.lineTo(P.x + I.x * (F / B) + E.x * L * 4, P.y + I.y * (F / B) + E.y * L * 4); x.lineTo(T.x, T.y) } M.render.lineWidth && (x.lineWidth = M.render.lineWidth, x.strokeStyle = M.render.strokeStyle, x.stroke()), M.render.anchors && (x.fillStyle = M.render.strokeStyle, x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.arc(T.x, T.y, 3, 0, 2 * Math.PI), x.closePath(), x.fill()) } } }, e.bodies = function (h, g, x) { var d = x; h.engine; var M = h.options, y = M.showInternalEdges || !M.wireframes, C, P, T, I; for (T = 0; T < g.length; T++)if (C = g[T], !!C.render.visible) { for (I = C.parts.length > 1 ? 1 : 0; I < C.parts.length; I++)if (P = C.parts[I], !!P.render.visible) { if (M.showSleeping && C.isSleeping ? d.globalAlpha = .5 * P.render.opacity : P.render.opacity !== 1 && (d.globalAlpha = P.render.opacity), P.render.sprite && P.render.sprite.texture && !M.wireframes) { var E = P.render.sprite, B = S(h, E.texture); d.translate(P.position.x, P.position.y), d.rotate(P.angle), d.drawImage(B, B.width * -E.xOffset * E.xScale, B.height * -E.yOffset * E.yScale, B.width * E.xScale, B.height * E.yScale), d.rotate(-P.angle), d.translate(-P.position.x, -P.position.y) } else { if (P.circleRadius) d.beginPath(), d.arc(P.position.x, P.position.y, P.circleRadius, 0, 2 * Math.PI); else { d.beginPath(), d.moveTo(P.vertices[0].x, P.vertices[0].y); for (var L = 1; L < P.vertices.length; L++)!P.vertices[L - 1].isInternal || y ? d.lineTo(P.vertices[L].x, P.vertices[L].y) : d.moveTo(P.vertices[L].x, P.vertices[L].y), P.vertices[L].isInternal && !y && d.moveTo(P.vertices[(L + 1) % P.vertices.length].x, P.vertices[(L + 1) % P.vertices.length].y); d.lineTo(P.vertices[0].x, P.vertices[0].y), d.closePath() } M.wireframes ? (d.lineWidth = 1, d.strokeStyle = h.options.wireframeStrokeStyle, d.stroke()) : (d.fillStyle = P.render.fillStyle, P.render.lineWidth && (d.lineWidth = P.render.lineWidth, d.strokeStyle = P.render.strokeStyle, d.stroke()), d.fill()) } d.globalAlpha = 1 } } }, e.bodyWireframes = function (h, g, x) { var d = x, M = h.options.showInternalEdges, y, C, P, T, I; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (I = y.parts.length > 1 ? 1 : 0; I < y.parts.length; I++) { for (C = y.parts[I], d.moveTo(C.vertices[0].x, C.vertices[0].y), T = 1; T < C.vertices.length; T++)!C.vertices[T - 1].isInternal || M ? d.lineTo(C.vertices[T].x, C.vertices[T].y) : d.moveTo(C.vertices[T].x, C.vertices[T].y), C.vertices[T].isInternal && !M && d.moveTo(C.vertices[(T + 1) % C.vertices.length].x, C.vertices[(T + 1) % C.vertices.length].y); d.lineTo(C.vertices[0].x, C.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = h.options.wireframeStrokeStyle, d.stroke() }, e.bodyConvexHulls = function (h, g, x) { var d = x, M, y, C; for (d.beginPath(), y = 0; y < g.length; y++)if (M = g[y], !(!M.render.visible || M.parts.length === 1)) { for (d.moveTo(M.vertices[0].x, M.vertices[0].y), C = 1; C < M.vertices.length; C++)d.lineTo(M.vertices[C].x, M.vertices[C].y); d.lineTo(M.vertices[0].x, M.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = "rgba(255,255,255,0.2)", d.stroke() }, e.vertexNumbers = function (h, g, x) { var d = x, M, y, C; for (M = 0; M < g.length; M++) { var P = g[M].parts; for (C = P.length > 1 ? 1 : 0; C < P.length; C++) { var T = P[C]; for (y = 0; y < T.vertices.length; y++)d.fillStyle = "rgba(255,255,255,0.2)", d.fillText(M + "_" + y, T.position.x + (T.vertices[y].x - T.position.x) * .8, T.position.y + (T.vertices[y].y - T.position.y) * .8) } } }, e.mousePosition = function (h, g, x) { var d = x; d.fillStyle = "rgba(255,255,255,0.8)", d.fillText(g.position.x + "  " + g.position.y, g.position.x + 5, g.position.y - 5) }, e.bodyBounds = function (h, g, x) { var d = x; h.engine; var M = h.options; d.beginPath(); for (var y = 0; y < g.length; y++) { var C = g[y]; if (C.render.visible) for (var P = g[y].parts, T = P.length > 1 ? 1 : 0; T < P.length; T++) { var I = P[T]; d.rect(I.bounds.min.x, I.bounds.min.y, I.bounds.max.x - I.bounds.min.x, I.bounds.max.y - I.bounds.min.y) } } M.wireframes ? d.strokeStyle = "rgba(255,255,255,0.08)" : d.strokeStyle = "rgba(0,0,0,0.1)", d.lineWidth = 1, d.stroke() }, e.bodyAxes = function (h, g, x) { var d = x; h.engine; var M = h.options, y, C, P, T; for (d.beginPath(), C = 0; C < g.length; C++) { var I = g[C], E = I.parts; if (I.render.visible) if (M.showAxes) for (P = E.length > 1 ? 1 : 0; P < E.length; P++)for (y = E[P], T = 0; T < y.axes.length; T++) { var B = y.axes[T]; d.moveTo(y.position.x, y.position.y), d.lineTo(y.position.x + B.x * 20, y.position.y + B.y * 20) } else for (P = E.length > 1 ? 1 : 0; P < E.length; P++)for (y = E[P], T = 0; T < y.axes.length; T++)d.moveTo(y.position.x, y.position.y), d.lineTo((y.vertices[0].x + y.vertices[y.vertices.length - 1].x) / 2, (y.vertices[0].y + y.vertices[y.vertices.length - 1].y) / 2) } M.wireframes ? (d.strokeStyle = "indianred", d.lineWidth = 1) : (d.strokeStyle = "rgba(255, 255, 255, 0.4)", d.globalCompositeOperation = "overlay", d.lineWidth = 2), d.stroke(), d.globalCompositeOperation = "source-over" }, e.bodyPositions = function (h, g, x) { var d = x; h.engine; var M = h.options, y, C, P, T; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (T = 0; T < y.parts.length; T++)C = y.parts[T], d.arc(C.position.x, C.position.y, 3, 0, 2 * Math.PI, !1), d.closePath(); for (M.wireframes ? d.fillStyle = "indianred" : d.fillStyle = "rgba(0,0,0,0.5)", d.fill(), d.beginPath(), P = 0; P < g.length; P++)y = g[P], y.render.visible && (d.arc(y.positionPrev.x, y.positionPrev.y, 2, 0, 2 * Math.PI, !1), d.closePath()); d.fillStyle = "rgba(255,165,0,0.8)", d.fill() }, e.bodyVelocity = function (h, g, x) { var d = x; d.beginPath(); for (var M = 0; M < g.length; M++) { var y = g[M]; if (y.render.visible) { var C = l.getVelocity(y); d.moveTo(y.position.x, y.position.y), d.lineTo(y.position.x + C.x, y.position.y + C.y) } } d.lineWidth = 3, d.strokeStyle = "cornflowerblue", d.stroke() }, e.bodyIds = function (h, g, x) { var d = x, M, y; for (M = 0; M < g.length; M++)if (g[M].render.visible) { var C = g[M].parts; for (y = C.length > 1 ? 1 : 0; y < C.length; y++) { var P = C[y]; d.font = "12px Arial", d.fillStyle = "rgba(255,255,255,0.5)", d.fillText(P.id, P.position.x + 10, P.position.y - 10) } } }, e.collisions = function (h, g, x) { var d = x, M = h.options, y, C, P, T; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive) for (C = y.collision, T = 0; T < y.contactCount; T++) { var I = y.contacts[T], E = I.vertex; d.rect(E.x - 1.5, E.y - 1.5, 3.5, 3.5) } for (M.wireframes ? d.fillStyle = "rgba(255,255,255,0.7)" : d.fillStyle = "orange", d.fill(), d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive && (C = y.collision, y.contactCount > 0)) { var B = y.contacts[0].vertex.x, L = y.contacts[0].vertex.y; y.contactCount === 2 && (B = (y.contacts[0].vertex.x + y.contacts[1].vertex.x) / 2, L = (y.contacts[0].vertex.y + y.contacts[1].vertex.y) / 2), C.bodyB === C.supports[0].body || C.bodyA.isStatic === !0 ? d.moveTo(B - C.normal.x * 8, L - C.normal.y * 8) : d.moveTo(B + C.normal.x * 8, L + C.normal.y * 8), d.lineTo(B, L) } M.wireframes ? d.strokeStyle = "rgba(255,165,0,0.7)" : d.strokeStyle = "orange", d.lineWidth = 1, d.stroke() }, e.separations = function (h, g, x) { var d = x, M = h.options, y, C, P, T, I; for (d.beginPath(), I = 0; I < g.length; I++)if (y = g[I], !!y.isActive) { C = y.collision, P = C.bodyA, T = C.bodyB; var E = 1; !T.isStatic && !P.isStatic && (E = .5), T.isStatic && (E = 0), d.moveTo(T.position.x, T.position.y), d.lineTo(T.position.x - C.penetration.x * E, T.position.y - C.penetration.y * E), E = 1, !T.isStatic && !P.isStatic && (E = .5), P.isStatic && (E = 0), d.moveTo(P.position.x, P.position.y), d.lineTo(P.position.x + C.penetration.x * E, P.position.y + C.penetration.y * E) } M.wireframes ? d.strokeStyle = "rgba(255,165,0,0.5)" : d.strokeStyle = "orange", d.stroke() }, e.inspector = function (h, g) { h.engine; var x = h.selected, d = h.render, M = d.options, y; if (M.hasBounds) { var C = d.bounds.max.x - d.bounds.min.x, P = d.bounds.max.y - d.bounds.min.y, T = C / d.options.width, I = P / d.options.height; g.scale(1 / T, 1 / I), g.translate(-d.bounds.min.x, -d.bounds.min.y) } for (var E = 0; E < x.length; E++) { var B = x[E].data; switch (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.9)", g.setLineDash([1, 2]), B.type) { case "body": y = B.bounds, g.beginPath(), g.rect(Math.floor(y.min.x - 3), Math.floor(y.min.y - 3), Math.floor(y.max.x - y.min.x + 6), Math.floor(y.max.y - y.min.y + 6)), g.closePath(), g.stroke(); break; case "constraint": var L = B.pointA; B.bodyA && (L = B.pointB), g.beginPath(), g.arc(L.x, L.y, 10, 0, 2 * Math.PI), g.closePath(), g.stroke(); break }g.setLineDash([]), g.translate(-.5, -.5) } h.selectStart !== null && (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.6)", g.fillStyle = "rgba(255,165,0,0.1)", y = h.selectBounds, g.beginPath(), g.rect(Math.floor(y.min.x), Math.floor(y.min.y), Math.floor(y.max.x - y.min.x), Math.floor(y.max.y - y.min.y)), g.closePath(), g.stroke(), g.fill(), g.translate(-.5, -.5)), M.hasBounds && g.setTransform(1, 0, 0, 1, 0, 0) }; var n = function (h, g) { var x = h.engine, d = h.timing, M = d.historySize, y = x.timing.timestamp; d.delta = g - d.lastTime || e._goodDelta, d.lastTime = g, d.timestampElapsed = y - d.lastTimestamp || 0, d.lastTimestamp = y, d.deltaHistory.unshift(d.delta), d.deltaHistory.length = Math.min(d.deltaHistory.length, M), d.engineDeltaHistory.unshift(x.timing.lastDelta), d.engineDeltaHistory.length = Math.min(d.engineDeltaHistory.length, M), d.timestampElapsedHistory.unshift(d.timestampElapsed), d.timestampElapsedHistory.length = Math.min(d.timestampElapsedHistory.length, M), d.engineUpdatesHistory.unshift(x.timing.lastUpdatesPerFrame), d.engineUpdatesHistory.length = Math.min(d.engineUpdatesHistory.length, M), d.engineElapsedHistory.unshift(x.timing.lastElapsed), d.engineElapsedHistory.length = Math.min(d.engineElapsedHistory.length, M), d.elapsedHistory.unshift(d.lastElapsed), d.elapsedHistory.length = Math.min(d.elapsedHistory.length, M) }, c = function (h) { for (var g = 0, x = 0; x < h.length; x += 1)g += h[x]; return g / h.length || 0 }, p = function (h, g) { var x = document.createElement("canvas"); return x.width = h, x.height = g, x.oncontextmenu = function () { return !1 }, x.onselectstart = function () { return !1 }, x }, m = function (h) { var g = h.getContext("2d"), x = window.devicePixelRatio || 1, d = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1; return x / d }, S = function (h, g) { var x = h.textures[g]; return x || (x = h.textures[g] = new Image, x.src = g, x) }, D = function (h, g) { var x = g; /(jpg|gif|png)$/.test(g) && (x = "url(" + g + ")"), h.canvas.style.background = x, h.canvas.style.backgroundSize = "contain", h.currentBackground = g } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(5), r = v(17), a = v(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (i) { var u = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, o = a.extend(u, i); return o.fps = 0, o }, e.run = function (i, u) { return i.timeBuffer = e._frameDeltaFallback, function o(t) { i.frameRequestId = e._onNextFrame(i, o), t && i.enabled && e.tick(i, u, t) }(), i }, e.tick = function (i, u, o) { var t = a.now(), s = i.delta, n = 0, c = o - i.timeLastTick; if ((!c || !i.timeLastTick || c > Math.max(e._maxFrameDelta, i.maxFrameTime)) && (c = i.frameDelta || e._frameDeltaFallback), i.frameDeltaSmoothing) { i.frameDeltaHistory.push(c), i.frameDeltaHistory = i.frameDeltaHistory.slice(-i.frameDeltaHistorySize); var p = i.frameDeltaHistory.slice(0).sort(), m = i.frameDeltaHistory.slice(p.length * e._smoothingLowerBound, p.length * e._smoothingUpperBound), S = f(m); c = S || c } i.frameDeltaSnapping && (c = 1e3 / Math.round(1e3 / c)), i.frameDelta = c, i.timeLastTick = o, i.timeBuffer += i.frameDelta, i.timeBuffer = a.clamp(i.timeBuffer, 0, i.frameDelta + s * e._timeBufferMargin), i.lastUpdatesDeferred = 0; var D = i.maxUpdates || Math.ceil(i.maxFrameTime / s), h = { timestamp: u.timing.timestamp }; l.trigger(i, "beforeTick", h), l.trigger(i, "tick", h); for (var g = a.now(); s > 0 && i.timeBuffer >= s * e._timeBufferMargin;) { l.trigger(i, "beforeUpdate", h), r.update(u, s), l.trigger(i, "afterUpdate", h), i.timeBuffer -= s, n += 1; var x = a.now() - t, d = a.now() - g, M = x + e._elapsedNextEstimate * d / n; if (n >= D || M > i.maxFrameTime) { i.lastUpdatesDeferred = Math.round(Math.max(0, i.timeBuffer / s - e._timeBufferMargin)); break } } u.timing.lastUpdatesPerFrame = n, l.trigger(i, "afterTick", h), i.frameDeltaHistory.length >= 100 && (i.lastUpdatesDeferred && Math.round(i.frameDelta / s) > D ? a.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : i.lastUpdatesDeferred && a.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof i.isFixed < "u" && a.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (i.deltaMin || i.deltaMax) && a.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), i.fps !== 0 && a.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (i) { e._cancelNextFrame(i) }, e._onNextFrame = function (i, u) { if (typeof window < "u" && window.requestAnimationFrame) i.frameRequestId = window.requestAnimationFrame(u); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return i.frameRequestId }, e._cancelNextFrame = function (i) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(i.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var f = function (i) { for (var u = 0, o = i.length, t = 0; t < o; t += 1)u += i[t]; return u / o || 0 } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(8), r = v(0), a = r.deprecated; (function () { e.collides = function (f, i) { return l.collides(f, i) }, a(e, "collides", "SAT.collides âž¤ replaced by Collision.collides") })() }, function (w, O, v) { var e = {}; w.exports = e, v(1); var l = v(0); (function () { e.pathToVertices = function (r, a) { typeof window < "u" && !("SVGPathSeg" in window) && l.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var f, i, u, o, t, s, n, c, p, m, S = [], D, h, g = 0, x = 0, d = 0; a = a || 15; var M = function (C, P, T) { var I = T % 2 === 1 && T > 1; if (!p || C != p.x || P != p.y) { p && I ? (D = p.x, h = p.y) : (D = 0, h = 0); var E = { x: D + C, y: h + P }; (I || !p) && (p = E), S.push(E), x = D + C, d = h + P } }, y = function (C) { var P = C.pathSegTypeAsLetter.toUpperCase(); if (P !== "Z") { switch (P) { case "M": case "L": case "T": case "C": case "S": case "Q": x = C.x, d = C.y; break; case "H": x = C.x; break; case "V": d = C.y; break }M(x, d, C.pathSegType) } }; for (e._svgPathToAbsolute(r), u = r.getTotalLength(), s = [], f = 0; f < r.pathSegList.numberOfItems; f += 1)s.push(r.pathSegList.getItem(f)); for (n = s.concat(); g < u;) { if (m = r.getPathSegAtLength(g), t = s[m], t != c) { for (; n.length && n[0] != t;)y(n.shift()); c = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": o = r.getPointAtLength(g), M(o.x, o.y, 0); break }g += a } for (f = 0, i = n.length; f < i; ++f)y(n[f]); return S }, e._svgPathToAbsolute = function (r) { for (var a, f, i, u, o, t, s = r.pathSegList, n = 0, c = 0, p = s.numberOfItems, m = 0; m < p; ++m) { var S = s.getItem(m), D = S.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(D)) "x" in S && (n = S.x), "y" in S && (c = S.y); else switch ("x1" in S && (i = n + S.x1), "x2" in S && (o = n + S.x2), "y1" in S && (u = c + S.y1), "y2" in S && (t = c + S.y2), "x" in S && (n += S.x), "y" in S && (c += S.y), D) { case "m": s.replaceItem(r.createSVGPathSegMovetoAbs(n, c), m); break; case "l": s.replaceItem(r.createSVGPathSegLinetoAbs(n, c), m); break; case "h": s.replaceItem(r.createSVGPathSegLinetoHorizontalAbs(n), m); break; case "v": s.replaceItem(r.createSVGPathSegLinetoVerticalAbs(c), m); break; case "c": s.replaceItem(r.createSVGPathSegCurvetoCubicAbs(n, c, i, u, o, t), m); break; case "s": s.replaceItem(r.createSVGPathSegCurvetoCubicSmoothAbs(n, c, o, t), m); break; case "q": s.replaceItem(r.createSVGPathSegCurvetoQuadraticAbs(n, c, i, u), m); break; case "t": s.replaceItem(r.createSVGPathSegCurvetoQuadraticSmoothAbs(n, c), m); break; case "a": s.replaceItem(r.createSVGPathSegArcAbs(n, c, S.r1, S.r2, S.angle, S.largeArcFlag, S.sweepFlag), m); break; case "z": case "Z": n = a, c = f; break }(D == "M" || D == "m") && (a = n, f = c) } } })() }, function (w, O, v) { var e = {}; w.exports = e; var l = v(6); v(0), function () { e.create = l.create, e.add = l.add, e.remove = l.remove, e.clear = l.clear, e.addComposite = l.addComposite, e.addBody = l.addBody, e.addConstraint = l.addConstraint }() }]) }) })(Mt); const j = nt(te); class wt { constructor(A) { k(this, "widthCanvas", document.body.clientWidth); k(this, "heightCanvas"); k(this, "DOM"); k(this, "dataImgs", []); k(this, "MatterJS"); k(this, "sizeCustom"); this.DOM = { el: A }, this.MatterJS = { Engine: void 0, Render: void 0 }, this.sizeCustom = { mobile: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 171 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(17) }, tablet: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 190 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(19) }, desktop: { radius: N(13.3), scaleRatio: N(13.3) / 133, scaleCircleMain: 293 / 133, xLeftWall: 0, xRightWall: window.innerWidth, yMainCircle: N(51.2) + N(29.3) } }, this.heightCanvas = this.DOM.el.clientHeight, A == null || A.querySelectorAll(".home-bubble-item").forEach(w => { var v; const O = (v = w.querySelector("img")) == null ? void 0 : v.getAttribute("src"); O && this.dataImgs.push(O), w.style.pointerEvents = "none", w.style.opacity = "0" }) } render() { var v, e, l, r; this.init(); const A = j.Runner.create(), w = (e = (v = this.MatterJS).Engine) == null ? void 0 : e.call(v), O = (r = (l = this.MatterJS).Render) == null ? void 0 : r.call(l); le.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !w || !O || (j.Render.run(O), j.Runner.run(A, w)) } }) } init() { const A = this.sizeCustom[se].radius, w = this.sizeCustom[se].scaleRatio, O = this.sizeCustom[se].scaleCircleMain, v = this.sizeCustom[se].xLeftWall, e = this.sizeCustom[se].xRightWall, l = this.sizeCustom[se].yMainCircle, r = j.Engine.create(), a = j.Render.create({ element: this.DOM.el, engine: r, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), f = Math.floor(window.innerWidth / (A * 2)), u = (window.innerWidth - f * A * 2) / (f - 1); let o = 0; for (let S = 0; S < Math.round(this.dataImgs.length / f) && this.dataImgs[o]; S++) { for (let D = 0; D < f && this.dataImgs[o]; D++) { const h = D * A * 2 + u * D, g = -S * A * 2 - A * 2 - u * S, x = te.Bodies.circle(h, g, A, { friction: .001, frictionAir: .01, restitution: .8, timeScale: 1.05, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[o], xScale: w, yScale: w } } }); if (o++, j.Composite.add(r.world, x), o >= this.dataImgs.length) break } if (o >= this.dataImgs.length) break } const t = te.Bodies.circle(this.DOM.el.clientWidth / 2, l, A * O, { render: { fillStyle: "transparent" }, isStatic: !0 }), s = te.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight, this.DOM.el.clientWidth * 10, 1, { isStatic: !0, render: { fillStyle: "transparent" } }), n = te.Bodies.rectangle(v, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }), c = te.Bodies.rectangle(e, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }); j.Composite.add(r.world, [s, n, c, t]); const p = j.Mouse.create(a.canvas), m = j.MouseConstraint.create(r, { mouse: p, constraint: { stiffness: .2, render: { visible: !1 } } }); j.Composite.add(r.world, m), m.mouse.element.removeEventListener("touchstart", m.mouse.mousedown), m.mouse.element.removeEventListener("touchmove", m.mouse.mousemove), m.mouse.element.removeEventListener("touchend", m.mouse.mouseup), m.mouse.element.addEventListener("touchstart", m.mouse.mousedown, { passive: !0 }), m.mouse.element.addEventListener("touchmove", S => { m.body && m.mouse.mousemove(S) }), m.mouse.element.addEventListener("touchend", S => { m.body && m.mouse.mouseup(S) }), this.MatterJS.Render = () => a, this.MatterJS.Engine = () => r } } class Ct { constructor(A) { k(this, "DOM"); this.DOM = { el: A }, b.emit(ae), this.initParticles = this.initParticles.bind(this), b.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelectorAll(".lading-splide-wrap"), w = this.DOM.el.querySelector(".home-bubble"), O = this.DOM.el.querySelector(".home-book-img-inner"); A.length && A.forEach(v => { new st({ wrap: v, listSplide: v.querySelectorAll(".home-hero-brands") }) }), new St(this.DOM.el), w && new wt(w).render(), O && new Me({ el: O, offset: 30, direction: -1 }), this.heroVideoAction(), this.handleParallaxTitle(), this.initMotion() } clear() { this.initParticles() } initMotion() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el) } heroVideoAction() { const A = this.DOM.el.querySelector(".home-hero-img-btn"), w = this.DOM.el.querySelector(".home-hero-poup-video"), O = this.DOM.el.querySelector(".home-hero--poup-ic"), v = this.DOM.el.querySelector(".home-hero-poup-video-content"); A.addEventListener("click", () => { w.classList.add("is-show") }), O.addEventListener("click", () => e()), at({ element: v, action: () => e() }); const e = () => { w.classList.remove("is-show") } } handleParallaxTitle() { const A = this.DOM.el.querySelector(".home-feature-top-inner"), w = this.DOM.el.querySelector(".home-bubble"); if (!A || !w) return; const O = W.fromTo(A, { y: A.clientHeight / 2 }, { y: `-${window.innerHeight / 2 - A.clientHeight / 2}px`, ease: "none", duration: 3 }); le.create({ trigger: w, start: () => "bottom bottom", end: "bottom top", animation: O, scrub: !0 }) } } class Pt { constructor(A) { k(this, "DOM"); k(this, "planCurrent"); k(this, "planOptions", { month: { planUser: 35, basePrice: 75, valSaleUp: 0, type: "month" }, annual: { planUser: 35, basePrice: 75, valSaleUp: 10, type: "annual" } }); this.DOM = { el: A }, this.planCurrent = this.planOptions.month, b.emit(ae), this.initParticles = this.initParticles.bind(this), b.on(ve, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelector(".home-book-img-inner"); A && new Me({ el: A, offset: 30, direction: -1 }), this.initMotions(), this.handleSelectTypePlan(), this.handleActionPlanPricing() } initMotions() { Q.maskText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeText(this.DOM.el), Q.fadeWrap(this.DOM.el) } handleSelectTypePlan() { const A = this.DOM.el.querySelector(".pricing-hero-bg-wrap"), w = this.DOM.el.querySelector(".pricing-hero-bg"); A && this.DOM.el.querySelectorAll(".pricing-hero-tab-item").forEach(O => { O.addEventListener("click", () => { var f; const v = ((f = O.textContent) == null ? void 0 : f.toLowerCase()) || "month", e = A.getBoundingClientRect().x, l = O.getBoundingClientRect().x, r = O.getBoundingClientRect().width, a = this.planOptions[v]; this.planCurrent = a, W.to(w, { x: -(e - l), duration: .5, width: r, ease: "power3.out" }), this.handleActionPlanPricing() }) }) } handleActionPlanPricing() { var l, r, a, f; const A = (l = this.DOM.el.querySelector(".txt-168.txt-bold")) == null ? void 0 : l.querySelector(".js-text-counter"); console.log("text", A); const w = document.querySelector(".fs-rangeslider_input__custom"), O = !0, v = new We(A, w, O), e = 75; v.handleSlide({ planType: ((r = this.planCurrent) == null ? void 0 : r.type) || "month", planUser: ((a = this.planCurrent) == null ? void 0 : a.planUser) || 35, valSaleUp: ((f = this.planCurrent) == null ? void 0 : f.valSaleUp) || 0, basePrice: e }) } clear() { this.initParticles() } } W.registerPlugin(le); class Dt { constructor() { this.init(), this.bindEvents() } init() { const w = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", w), w) return; const O = document.querySelector("div[data-page]"); if (!O) return; const v = O.getAttribute("data-page") || "home", e = { home: () => { new Ct(O) }, about: () => { new yt(O) }, pricing: () => { new Pt(O) } }; e[v] && e[v](), Fe.init(), Q.init(), new gt, new pt } bindEvents() { b.on(rt, this.init.bind(this)), Be.simple(), Be.simpleLoaded() } } new Dt;
