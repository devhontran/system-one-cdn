var Qe = Object.defineProperty; var Je = (k, A, M) => A in k ? Qe(k, A, { enumerable: !0, configurable: !0, writable: !0, value: M }) : k[A] = M; var R = (k, A, M) => (Je(k, typeof A != "symbol" ? A + "" : A, M), M); import { f as Fe, u as He, b as U, P as re, s as ne, S as ae, d as me, e as we, g as H, h as le, i as ie, j as Ze, k as Ke, l as Xe, m as Ye, _ as Ve, n as je, L as _e, A as et, o as tt, p as de, q as it, r as nt, R as Le, U as Be, a as N, t as st, c as xe, v as rt, w as se, M as Se, x as at, y as ot } from "./global.js"; const lt = k => { Fe.measure(k) }, We = k => { Fe.mutate(k) }, be = (k, A, M, O, h) => parseFloat(((k - A) * (h - O) / (M - A) + O).toFixed(3)), ce = ({ el: k, elObServer: A = null, animIn: M, offsetPercent: O = null, animUnset: h, inScreen: e, outScreen: l, start: a }) => { let r = null, u = null, i = null, f = !1; const o = !!k.getAttribute("data-enteronly"), t = k.getAttribute("data-trigger-for"); t && (u = document.getElementById(t)); const n = () => { if (!f) return; const { isPageEnter: m } = me; if (m) { const S = me.isScrolled() ? parseFloat(k.getAttribute("data-offset") || "0") : parseFloat(k.getAttribute("data-screen-offset") || "0"); k.classList.add("anim-in"), M && M(S) } e && e() }, s = () => { const { winSize: m } = me; O === null && lt(() => { const { height: S, top: D } = k.getBoundingClientRect(); D >= m.height && (O = be(S / m.height, 0, 1, .3, 0), O = Math.max(Math.min(O, .3), 0)) }), O = Number(k.getAttribute("data-threshold") || 0) || O, t ? ne(() => { i = new IntersectionObserver(S => { f = S[0].isIntersecting, f ? n() : l && l() }, { threshold: O || 0 }), i.observe(k) }) : ne(() => { r = ae.create({ trigger: A || k, markers: !1, invalidateOnRefresh: !0, start: a || `${Number(O) * 100}% bottom`, onEnter: () => { f = !0, n() }, onLeave: () => { o && !e && !l && (h && h(), v(), f = !1), l && l() } }) }) }, c = () => f, v = () => { U.off(re, n), r && r.kill(), t && u && (i == null || i.unobserve(u), i == null || i.disconnect()) }; return He(() => (s(), U.on(re, n), v)), { getIsVisible: c, removeEvent: v } }; class pe {
    constructor(A, M, O) { R(this, "DOM"); R(this, "textSplit"); R(this, "input"); R(this, "old"); R(this, "isSpecial"); R(this, "planPricing"); this.DOM = { el: A, listChars: [] }, ne(this.init.bind(this)), this.old = [1, 1, 0], this.input = M, this.isSpecial = O } init() {
        const A = new we(this.DOM.el, { types: "chars, chars" }); H.killTweensOf([this.DOM.el, ...this.DOM.listChars]), this.textSplit = A, this.DOM.el.classList.add(le.counter); const M = A.chars, O = globalThis.getComputedStyle(this.DOM.el).fontSize; if (M != null && M.length) for (const h in M) {
            const e = M[h], l = document.createElement("span"), a = e.innerText === "1"; if (l.classList.add(le.counter_text), l.style.height = O, a && e.classList.add("char__one"), this.isSpecial && e.classList.add("char__special"), !isNaN(parseFloat(e.innerText))) {
                const r = parseFloat(e.innerText); l.insertAdjacentHTML("beforeend", `<span data-value="${r}"
                  class=${a ? `${le.textSpacing}` : ""}>
                  <span>&ndash;</span>
                        ${Array(r + 1).join("0").split("0").map((f, o) => `
                                <span>
                                ${o}
                                </span>
                            `).join("")}
        			</span>`), e.removeChild(e.firstChild), e.appendChild(l); const u = l.querySelector("span[data-value]"); this.DOM.listChars.push(u); const { removeEvent: i } = ce({ el: this.DOM.el, animIn: f => { this.animIn(f), i() } }); ie(() => { i() })
            }
        }
    } handleSlide({ type: A, valSaleUp: M, planUser: O, basePrice: h }) { var e; (e = this.input) == null || e.addEventListener("input", l => { var a, r, u, i; return this.handleCalcPricing({ currentValue: l.target.value, type: ((a = this.planPricing) == null ? void 0 : a.type) || A, valSaleUp: ((r = this.planPricing) == null ? void 0 : r.valSaleUp) || M, planUser: ((u = this.planPricing) == null ? void 0 : u.planUser) || O, basePrice: ((i = this.planPricing) == null ? void 0 : i.basePrice) || h }) }) } handleCalcPricing({ currentValue: A, type: M, valSaleUp: O, planUser: h, basePrice: e, isReinit: l }) { var u, i; this.planPricing = { planUser: h, basePrice: e, valSaleUp: O, type: M }, (u = this.textSplit) == null || u.revert(); const a = M === "month", r = (parseFloat(A || ((i = this.input) == null ? void 0 : i.value) || "1") * h + e) * (a ? 1 : (100 - O) / 100 * 12); this.DOM.el.innerHTML = `${Math.floor(r)}`, l && (this.init(), this.animIn()) } animIn(A) { H.to(this.DOM.listChars, { duration: 1.2, ease: "power1", y: (M, O) => `-${(parseInt(O.getAttribute("data-value") || "0") + 1) * 100}%`, stagger: { amount: .025, from: "end" }, delay: A }) } createNumberArray(A) { const M = A.toString().split(""); for (let O = 0; M.length < 3; O++)M[0] === "-" && (M[0] = "0"), M.unshift("0"); return M.map(O => parseInt(O)) } createNumberHTML(A, M, O) { var e; const h = O.querySelectorAll("span[data-value]"); for (let l = 0; l < h.length; l++) { const a = h[l], r = this.calcDeltaBetweenNumbers(M[l], A[l]); a.setAttribute("data-between", String(r.length)), a.setAttribute("data-value", String(A[l])), a.innerHTML = r.join(""); const u = (e = a.parentElement) == null ? void 0 : e.parentElement; u && (A[l] === 1 ? (u.classList.add("char__one"), u.classList.remove(le.textSpacing)) : (u.classList.remove("char__one"), u.classList.remove(le.textSpacing))) } return O } calcDeltaBetweenNumbers(A, M) { let O = [A], h = !0; if (A === M) return O.map(e => `<span>${e}</span>`); for (; h;)A++, A > 9 && (A = 0), O.push(A), A === M && (h = !1); return O.map(e => `<span>${e}</span>`) } animateNumber(A) { const M = this.createNumberArray(A); this.createNumberHTML(M, this.old, this.DOM.el); let O; O && clearTimeout(O), O = setTimeout(() => { const h = Array.from(this.DOM.el.querySelectorAll("span[data-between]")); H.killTweensOf([...h]), H.set(h, { y: 0 }); for (let e of h) { let l = Number(e.getAttribute("data-between")) - 1; H.to(e, { duration: 1, ease: "ease", y: `-${l * 100}%`, stagger: { amount: .025, from: "end" } }) } this.old = M }, 1) }
} class ct { constructor(A) { R(this, "DOM"); R(this, "animation"); this.DOM = { el: A, splitType: new we(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var M; this.DOM.el.classList.add(Ze.text__fade), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const h = document.createElement("div"); h.appendChild(O), h.classList.add("line__fade"), this.DOM.el.appendChild(h) }), (M = this.DOM.splitType.lines) != null && M.length && H.set(this.DOM.splitType.lines, { yPercent: 100, opacity: 0 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert(), this.revert() }) } animIn(A) { this.animation = H.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3.out", opacity: 1, stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } class ft { constructor(A) { R(this, "DOM"); R(this, "animation"); this.DOM = { el: A, splitType: new we(A, { types: "words, lines" }) }, this.animation = null, ne(this.init.bind(this)) } init() { var M; this.DOM.el.classList.add(Ke.text__mask), this.DOM.splitType.lines && this.DOM.splitType.lines.forEach(O => { const h = document.createElement("div"); h.appendChild(O), h.classList.add("line__mask"), this.DOM.el.appendChild(h) }), (M = this.DOM.splitType.lines) != null && M.length && H.set(this.DOM.splitType.lines, { yPercent: 100 }); const { removeEvent: A } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), A() } }); ie(() => { A(), this.DOM.splitType.revert && this.DOM.splitType.revert() }) } animIn(A) { this.animation = H.to(this.DOM.splitType.lines, { yPercent: 0, duration: 1.2, ease: "power3", stagger: .1, delay: A }) } revert() { this.animation && this.animation.revert() } } const Me = (k, A, M, O, h) => parseFloat(((k - A) * (h - O) / (M - A) + O).toFixed(3)), Re = k => { const A = parseFloat(getComputedStyle(document.documentElement).fontSize); return k / A }; class Ue { constructor(A, M = {}) { R(this, "onHover"); R(this, "DOM"); R(this, "options"); R(this, "removeEvent"); this.DOM = { el: A }, this.options = { ...M }, this.addAnimType() } addAnimType() { this.DOM.el.classList.add(Xe.fade); let A; switch (this.options.type) { case "fade_tran": H.set(this.DOM.el, { opacity: 0, y: "2.4rem" }), A = { to: { keyframes: [{ opacity: 1, ease: "power3.inOut", duration: .8 }, { y: 0, ease: "power3.out", duration: .8, delay: -.6 }], delay: this.options.delay || 0 }, out: { opacity: 0, y: -30, ease: "power3.inOut", duration: .6 } }; break; default: H.set(this.DOM.el, { opacity: 0 }), A = { to: { opacity: 1, ease: "power3.inOut", duration: 1, delay: this.options.delay || 0, clearProps: "all" }, out: { opacity: 0, ease: "power3.inOut", duration: .6 } }; break }this.options.to = { ...A.to, ...this.options.to }, this.options.out = { ...A.out, ...this.options.out }, We(() => { const { removeEvent: M } = ce({ el: this.DOM.el, animIn: O => { this.animIn(O), M() }, start: this.options.start }); this.removeEvent = M, ie(() => { M() }) }), this.options.from && H.set(this.DOM.el, this.options.from) } animIn(A = 0) { const M = Object.assign({ delay: 0 }, this.options.to); M.delay += A, H.killTweensOf(this.DOM.el), this.options.to && H.to(this.DOM.el, M), this.removeEvent && this.removeEvent() } } class ut { init() { this.loadImages() } maskText(A) { const M = A.querySelectorAll(".js-text-mask"); M.length && M.forEach(O => { new ft(O) }) } fadeWrap(A) { const M = A.querySelectorAll(".js-fade"); M.length && M.forEach(O => { new Ue(O, { type: "fade_tran" }) }) } fadeText(A) { const M = A.querySelectorAll(".js-text-fade"); M.length && M.forEach(O => { new ct(O) }) } countText(A) { const M = A.querySelectorAll(".js-text-counter"); M.length && M.forEach(O => { new pe(O) }) } loadImages() { const A = document.querySelectorAll("img"); for (let M = 0; M < A.length; M++) { const O = A[M]; if (O.getAttribute("srcset")) { const e = O.getAttribute("width") || O.width, l = O.getBoundingClientRect().y; if (O.setAttribute("sizes", `(max-width: ${e}px) 100vw, ${e}px`), l > window.innerHeight) { const a = O.srcset.split(" ")[0]; O.style.background = `url(${a}) no-repeat center / cover` } } } } loadPage() { const A = H.timeline(), M = document.querySelector(".pageloader"); A.set(M, { display: "block" }), A.to(M, { opacity: 0, duration: 3, ease: "power3.out", onComplete: () => { H.to(M, { display: "none" }) } }) } handleResize() { let A = window.innerWidth; function M() { const O = window.innerWidth; Math.abs(O - A) > 10 && window.location.reload(), A = O } window.addEventListener("resize", Ye(M, 200)) } } const Q = new ut, ht = "_parallax_79i64_1", pt = "_wrapper_79i64_5", dt = "_inner_79i64_12", ye = { parallax: ht, wrapper: pt, inner: dt }; class Ce { constructor({ el: A, offset: M, scale: O, direction: h, ...e }) { R(this, "DOM"); R(this, "offset"); R(this, "scale"); R(this, "direction"); R(this, "options"); this.DOM = { el: A }, this.offset = M || 0, this.scale = O || 1.1, this.direction = h || -1, this.options = e, this.init() } init() { const A = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const M = document.createElement("div"); M.style.scale = `${this.scale}`, M.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, M.classList.add(ye.inner), A.classList.add(ye.parallax), this.DOM.el.classList.add(ye.wrapper), M.appendChild(A), this.DOM.el.appendChild(M), this.DOM.elInner = this.DOM.el; const { removeEvent: O } = ce({ el: this.DOM.el, animIn: () => { this.animIn(), O() } }); ie(() => { O() }) } animIn() { if (!this.DOM.elInner) return; const A = 100 + this.offset * 2, M = this.offset * A / 100 * this.direction, O = { trigger: this.DOM.el, start: "top bottom", end: "bottom top", scrub: 1 }; H.timeline({ scrollTrigger: O }).to(this.DOM.elInner, { y: `${M}%` }) } } class vt { constructor() { R(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.DOM.el && (this.hander(), this.movingImageFooter(), this.initMotion()) } initMotion() { this.DOM.el && (Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el)) } hander() { var M; const A = (M = this.DOM.el) == null ? void 0 : M.querySelector(".footer-bottom-inner-back"); A == null || A.addEventListener("click", () => { Ve.lenis.scrollTo("top", { lock: !0, duration: 1.2, onComplete: () => { console.log("scrolled") } }) }) } movingImageFooter() { var l, a, r, u, i; const A = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-inner-img"), M = (a = this.DOM.el) == null ? void 0 : a.querySelector(".footer-middle-list-imgs"); new Ce({ el: M, offset: 25, direction: 1, scale: 1.3 }); const O = (r = this.DOM.el) == null ? void 0 : r.querySelectorAll(".footer-middle-list-imgs-item"), h = H.quickTo(A, "x", { duration: .9, ease: "power3.out" }), e = f => { O == null || O.forEach((o, t) => { t === f ? H.to(o, { opacity: 1, ease: "power3.out", duration: .6, willChange: "opacity" }) : H.to(o, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; e(1), A.style.willChange = "transform", (u = this.DOM.el) == null || u.addEventListener("mousemove", f => { if (!this.DOM.el) return; const o = f.pageX, t = Me(o, 0, window.innerWidth, -1, 1), n = Math.floor(Me(o, 0, window.innerWidth, 0, (O == null ? void 0 : O.length) || 3)), s = (this.DOM.el.clientWidth - A.clientWidth) / 2; h(t * s), e(n) }), (i = this.DOM.el) == null || i.addEventListener("mouseleave", () => { h(0), e(1) }) } } class gt { constructor() { R(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show() } show() { let A = 0; window.addEventListener("scroll", () => { var r; if (!this.DOM.el) return; const M = window.pageYOffset || document.documentElement.scrollTop || 0, O = ((r = this.DOM.footer) == null ? void 0 : r.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, h = M > this.DOM.el.clientHeight, l = A < M && M > this.DOM.el.clientHeight * 2 || O, a = A > M && !O; l ? this.DOM.el.classList.add("hidden") : a && (this.DOM.el.classList.remove("hidden"), this.DOM.el.classList.toggle("scrollDown", h)), A = M }) } } const mt = ({ el: k, isGsap: A = !0, isDebug: M, inScreen: O, onEnterBack: h, outScreen: e, threshold: l = 0, onToggle: a, onToggleOb: r, start: u, end: i }) => { let f = !1, o = null, t; return !je() || A ? ne(() => { o = ae.create({ trigger: k, start: u || `top+=${l * 100}% bottom`, end: i || "bottom top", markers: M, onToggle: c => { f = c.isActive, a && a(c), f ? O && O() : e && e() }, onEnterBack: h, invalidateOnRefresh: !0 }) }) : ne(() => { t = new IntersectionObserver(c => { f = c[0].isIntersecting, r && r(f), f ? O && O() : e && e() }, { threshold: l }), t.observe(k) }), { isInViewPointer: () => f, removeOb: () => { t && (t.unobserve(k), t.disconnect()), f = !1, o == null || o.kill(), o = null } } }; class xt { constructor() { R(this, "DOM"); R(this, "isReady"); R(this, "inited"); R(this, "windowIsBlur"); R(this, "isSimpleLoader"); R(this, "minProgress"); R(this, "processing"); R(this, "registerCount"); R(this, "lowNet"); R(this, "strokeDashoffset"); R(this, "obServerAPI"); R(this, "idAnimationLoop"); R(this, "runAnimation"); R(this, "delayPageEnter"); R(this, "delaLoadingOut"); this.registerLoader = this.registerLoader.bind(this), this.unRegisterLoader = this.unRegisterLoader.bind(this), this.init() } init() { this.DOM = { main: document.querySelector(".page-loading") }, document.body.classList.add("js-ready", "is-loading"), U.emit(_e), this.inited = !!this.DOM.main, this.isReady = !1, this.windowIsBlur = !1, this.isSimpleLoader = !1, this.minProgress = 98, this.delayPageEnter = 1.2, this.delaLoadingOut = .3, this.processing = { delta: 0, percentStuck: 0, runWidth: 0 }, this.registerCount = 0, this.lowNet = 0, this.strokeDashoffset = 829, this.hideLoading = this.hideLoading.bind(this), He(() => (U.on(Le, this.registerLoader), U.on(Be, this.unRegisterLoader), window.addEventListener("DOMContentLoaded", this.hideLoading), () => { U.off(Le, this.registerLoader), U.off(Be, this.unRegisterLoader), window.removeEventListener("DOMContentLoaded", this.hideLoading) })) } simpleLoaded() { var A; (A = this.DOM.main) == null || A.classList.add("is-simple"), this.isSimpleLoader = !0, this.pageLoaded() } simple() { this.obServerAPI = mt({ el: document.body }), this.isSimpleLoader = !0, this.isReady = !0, U.emit(et), document.body.classList.add("is-ready") } hideLoading() { U.emit(tt) } hide() { We(() => { this.DOM.main && (this.DOM.main.style.visibility = "hidden") }) } pageLoaded() { this.idAnimationLoop && cancelAnimationFrame(this.idAnimationLoop), document.body.classList.remove("is-loading"), document.body.classList.remove("is-simple"), U.emit(de), U.emit(it), console.log("this.isSimpleLoader", this.isSimpleLoader), this.isSimpleLoader && (console.log("run_______"), this.DOM.main && H.to(this.DOM.main, { opacity: 0, duration: this.delayPageEnter, ease: "power3.inOut", onComplete: () => { setTimeout(() => this.hide(), 100), U.emit(re), U.emit(nt) } })) } registerLoader() { this.registerCount++ } unRegisterLoader() { this.registerCount-- } } const ke = new xt; class yt { constructor(A) { R(this, "DOM"); this.DOM = { el: A }, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(de, this.initParticles), ie(this.clear.bind(this)) } initParticles() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el), this.handleStackCard() } clear() { this.initParticles() } handleStackCard() { console.log("hehe"); const A = this.DOM.el.querySelector(".about-vision-sticky-inner"), O = this.DOM.el.querySelector(".about-vision-sticky-left").querySelectorAll(".about-sticky-left-card"), h = this.DOM.el.querySelector(".about-vision-sticky-right-inner"), e = this.DOM.el.querySelectorAll(".about-sticky-right-img"); (() => { let a = null, r = null; H.timeline({ scrollTrigger: { trigger: ".about-vision-sticky", start: "top top", end: "bottom bottom", scrub: 1, onUpdate: t => { const { progress: n } = t, s = Math.round(be(n, 0, 1, 0, O.length - 1)); if (r !== null && n < r) i(a), f(a); else if (r !== null && n > r) { u(s); const c = Math.min(e.length - 1, s + 1); f(c) } a = s, r = n } } }); const u = t => { const n = Re((h.clientHeight - N(3.2) * 2) / O.length); O.forEach((s, c) => { t === c && H.to(s, { height: `${n}rem`, duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, i = t => { O.forEach((n, s) => { t === s && H.to(n, { height: "auto", duration: 1.2, ease: "power3", overwrite: "auto" }) }) }, f = t => { e.forEach((n, s) => { s === t ? (H.killTweensOf(n), H.to(n, { opacity: 1, ease: "power3", duration: .8 })) : H.to(n, { opacity: 0, ease: "power3", duration: .8 }) }) }; f(0); const o = Re((window.innerHeight - h.clientHeight) / 2); A.style.top = `${o}rem` })() } } class St { constructor(A) { R(this, "DOM"); this.DOM = { wrapper: A.querySelector(".home-feature-cards"), listCards: A.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((A, M, O) => { if (!st) return; const h = O[0].clientHeight, e = (window.innerHeight - h) / 2, l = O.length * N(8), a = Me(M, 0, O.length - 1, .8125, 1); A.style.top = `${e + l}px`, A.style.transform = `translateY(-${(O.length - M) * N(8)}px)`, H.timeline({ scrollTrigger: { trigger: A, start: () => "top center", end: `+=${(O.length - M) * h} `, scrub: 1 } }).to(A, { scale: a, transformOrigin: "top center", ease: "none" }, 0) }) } } var te = {}, Mt = { get exports() { return te }, set exports(k) { te = k } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (k, A) { (function (O, h) { k.exports = h() })(xe, function () { return function (M) { var O = {}; function h(e) { if (O[e]) return O[e].exports; var l = O[e] = { i: e, l: !1, exports: {} }; return M[e].call(l.exports, l, l.exports, h), l.l = !0, l.exports } return h.m = M, h.c = O, h.d = function (e, l, a) { h.o(e, l) || Object.defineProperty(e, l, { enumerable: !0, get: a }) }, h.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, h.t = function (e, l) { if (l & 1 && (e = h(e)), l & 8 || l & 4 && typeof e == "object" && e && e.__esModule) return e; var a = Object.create(null); if (h.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: e }), l & 2 && typeof e != "string") for (var r in e) h.d(a, r, function (u) { return e[u] }.bind(null, r)); return a }, h.n = function (e) { var l = e && e.__esModule ? function () { return e.default } : function () { return e }; return h.d(l, "a", l), l }, h.o = function (e, l) { return Object.prototype.hasOwnProperty.call(e, l) }, h.p = "", h(h.s = 20) }([function (M, O) { var h = {}; M.exports = h, function () { h._baseDelta = 1e3 / 60, h._nextId = 0, h._seed = 0, h._nowStartTime = +new Date, h._warnedOnce = {}, h._decomp = null, h.extend = function (l, a) { var r, u; typeof a == "boolean" ? (r = 2, u = a) : (r = 1, u = !0); for (var i = r; i < arguments.length; i++) { var f = arguments[i]; if (f) for (var o in f) u && f[o] && f[o].constructor === Object && (!l[o] || l[o].constructor === Object) ? (l[o] = l[o] || {}, h.extend(l[o], u, f[o])) : l[o] = f[o] } return l }, h.clone = function (l, a) { return h.extend({}, a, l) }, h.keys = function (l) { if (Object.keys) return Object.keys(l); var a = []; for (var r in l) a.push(r); return a }, h.values = function (l) { var a = []; if (Object.keys) { for (var r = Object.keys(l), u = 0; u < r.length; u++)a.push(l[r[u]]); return a } for (var i in l) a.push(l[i]); return a }, h.get = function (l, a, r, u) { a = a.split(".").slice(r, u); for (var i = 0; i < a.length; i += 1)l = l[a[i]]; return l }, h.set = function (l, a, r, u, i) { var f = a.split(".").slice(u, i); return h.get(l, a, 0, -1)[f[f.length - 1]] = r, r }, h.shuffle = function (l) { for (var a = l.length - 1; a > 0; a--) { var r = Math.floor(h.random() * (a + 1)), u = l[a]; l[a] = l[r], l[r] = u } return l }, h.choose = function (l) { return l[Math.floor(h.random() * l.length)] }, h.isElement = function (l) { return typeof HTMLElement < "u" ? l instanceof HTMLElement : !!(l && l.nodeType && l.nodeName) }, h.isArray = function (l) { return Object.prototype.toString.call(l) === "[object Array]" }, h.isFunction = function (l) { return typeof l == "function" }, h.isPlainObject = function (l) { return typeof l == "object" && l.constructor === Object }, h.isString = function (l) { return toString.call(l) === "[object String]" }, h.clamp = function (l, a, r) { return l < a ? a : l > r ? r : l }, h.sign = function (l) { return l < 0 ? -1 : 1 }, h.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - h._nowStartTime }, h.random = function (l, a) { return l = typeof l < "u" ? l : 0, a = typeof a < "u" ? a : 1, l + e() * (a - l) }; var e = function () { return h._seed = (h._seed * 9301 + 49297) % 233280, h._seed / 233280 }; h.colorToNumber = function (l) { return l = l.replace("#", ""), l.length == 3 && (l = l.charAt(0) + l.charAt(0) + l.charAt(1) + l.charAt(1) + l.charAt(2) + l.charAt(2)), parseInt(l, 16) }, h.logLevel = 1, h.log = function () { console && h.logLevel > 0 && h.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, h.info = function () { console && h.logLevel > 0 && h.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, h.warn = function () { console && h.logLevel > 0 && h.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, h.warnOnce = function () { var l = Array.prototype.slice.call(arguments).join(" "); h._warnedOnce[l] || (h.warn(l), h._warnedOnce[l] = !0) }, h.deprecated = function (l, a, r) { l[a] = h.chain(function () { h.warnOnce("🔅 deprecated 🔅", r) }, l[a]) }, h.nextId = function () { return h._nextId++ }, h.indexOf = function (l, a) { if (l.indexOf) return l.indexOf(a); for (var r = 0; r < l.length; r++)if (l[r] === a) return r; return -1 }, h.map = function (l, a) { if (l.map) return l.map(a); for (var r = [], u = 0; u < l.length; u += 1)r.push(a(l[u])); return r }, h.topologicalSort = function (l) { var a = [], r = [], u = []; for (var i in l) !r[i] && !u[i] && h._topologicalSort(i, r, u, l, a); return a }, h._topologicalSort = function (l, a, r, u, i) { var f = u[l] || []; r[l] = !0; for (var o = 0; o < f.length; o += 1) { var t = f[o]; r[t] || a[t] || h._topologicalSort(t, a, r, u, i) } r[l] = !1, a[l] = !0, i.push(l) }, h.chain = function () { for (var l = [], a = 0; a < arguments.length; a += 1) { var r = arguments[a]; r._chained ? l.push.apply(l, r._chained) : l.push(r) } var u = function () { for (var i, f = new Array(arguments.length), o = 0, t = arguments.length; o < t; o++)f[o] = arguments[o]; for (o = 0; o < l.length; o += 1) { var n = l[o].apply(i, f); typeof n < "u" && (i = n) } return i }; return u._chained = l, u }, h.chainPathBefore = function (l, a, r) { return h.set(l, a, h.chain(r, h.get(l, a))) }, h.chainPathAfter = function (l, a, r) { return h.set(l, a, h.chain(h.get(l, a), r)) }, h.setDecomp = function (l) { h._decomp = l }, h.getDecomp = function () { var l = h._decomp; try { !l && typeof window < "u" && (l = window.decomp), !l && typeof xe < "u" && (l = xe.decomp) } catch { l = null } return l } }() }, function (M, O) { var h = {}; M.exports = h, function () { h.create = function (e) { var l = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && h.update(l, e), l }, h.update = function (e, l, a) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var r = 0; r < l.length; r++) { var u = l[r]; u.x > e.max.x && (e.max.x = u.x), u.x < e.min.x && (e.min.x = u.x), u.y > e.max.y && (e.max.y = u.y), u.y < e.min.y && (e.min.y = u.y) } a && (a.x > 0 ? e.max.x += a.x : e.min.x += a.x, a.y > 0 ? e.max.y += a.y : e.min.y += a.y) }, h.contains = function (e, l) { return l.x >= e.min.x && l.x <= e.max.x && l.y >= e.min.y && l.y <= e.max.y }, h.overlaps = function (e, l) { return e.min.x <= l.max.x && e.max.x >= l.min.x && e.max.y >= l.min.y && e.min.y <= l.max.y }, h.translate = function (e, l) { e.min.x += l.x, e.max.x += l.x, e.min.y += l.y, e.max.y += l.y }, h.shift = function (e, l) { var a = e.max.x - e.min.x, r = e.max.y - e.min.y; e.min.x = l.x, e.max.x = l.x + a, e.min.y = l.y, e.max.y = l.y + r } }() }, function (M, O) { var h = {}; M.exports = h, function () { h.create = function (e, l) { return { x: e || 0, y: l || 0 } }, h.clone = function (e) { return { x: e.x, y: e.y } }, h.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, h.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, h.rotate = function (e, l, a) { var r = Math.cos(l), u = Math.sin(l); a || (a = {}); var i = e.x * r - e.y * u; return a.y = e.x * u + e.y * r, a.x = i, a }, h.rotateAbout = function (e, l, a, r) { var u = Math.cos(l), i = Math.sin(l); r || (r = {}); var f = a.x + ((e.x - a.x) * u - (e.y - a.y) * i); return r.y = a.y + ((e.x - a.x) * i + (e.y - a.y) * u), r.x = f, r }, h.normalise = function (e) { var l = h.magnitude(e); return l === 0 ? { x: 0, y: 0 } : { x: e.x / l, y: e.y / l } }, h.dot = function (e, l) { return e.x * l.x + e.y * l.y }, h.cross = function (e, l) { return e.x * l.y - e.y * l.x }, h.cross3 = function (e, l, a) { return (l.x - e.x) * (a.y - e.y) - (l.y - e.y) * (a.x - e.x) }, h.add = function (e, l, a) { return a || (a = {}), a.x = e.x + l.x, a.y = e.y + l.y, a }, h.sub = function (e, l, a) { return a || (a = {}), a.x = e.x - l.x, a.y = e.y - l.y, a }, h.mult = function (e, l) { return { x: e.x * l, y: e.y * l } }, h.div = function (e, l) { return { x: e.x / l, y: e.y / l } }, h.perp = function (e, l) { return l = l === !0 ? -1 : 1, { x: l * -e.y, y: l * e.x } }, h.neg = function (e) { return { x: -e.x, y: -e.y } }, h.angle = function (e, l) { return Math.atan2(l.y - e.y, l.x - e.x) }, h._temp = [h.create(), h.create(), h.create(), h.create(), h.create(), h.create()] }() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(2), a = h(0); (function () { e.create = function (r, u) { for (var i = [], f = 0; f < r.length; f++) { var o = r[f], t = { x: o.x, y: o.y, index: f, body: u, isInternal: !1 }; i.push(t) } return i }, e.fromPath = function (r, u) { var i = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, f = []; return r.replace(i, function (o, t, n) { f.push({ x: parseFloat(t), y: parseFloat(n) }) }), e.create(f, u) }, e.centre = function (r) { for (var u = e.area(r, !0), i = { x: 0, y: 0 }, f, o, t, n = 0; n < r.length; n++)t = (n + 1) % r.length, f = l.cross(r[n], r[t]), o = l.mult(l.add(r[n], r[t]), f), i = l.add(i, o); return l.div(i, 6 * u) }, e.mean = function (r) { for (var u = { x: 0, y: 0 }, i = 0; i < r.length; i++)u.x += r[i].x, u.y += r[i].y; return l.div(u, r.length) }, e.area = function (r, u) { for (var i = 0, f = r.length - 1, o = 0; o < r.length; o++)i += (r[f].x - r[o].x) * (r[f].y + r[o].y), f = o; return u ? i / 2 : Math.abs(i) / 2 }, e.inertia = function (r, u) { for (var i = 0, f = 0, o = r, t, n, s = 0; s < o.length; s++)n = (s + 1) % o.length, t = Math.abs(l.cross(o[n], o[s])), i += t * (l.dot(o[n], o[n]) + l.dot(o[n], o[s]) + l.dot(o[s], o[s])), f += t; return u / 6 * (i / f) }, e.translate = function (r, u, i) { i = typeof i < "u" ? i : 1; var f = r.length, o = u.x * i, t = u.y * i, n; for (n = 0; n < f; n++)r[n].x += o, r[n].y += t; return r }, e.rotate = function (r, u, i) { if (u !== 0) { var f = Math.cos(u), o = Math.sin(u), t = i.x, n = i.y, s = r.length, c, v, m, S; for (S = 0; S < s; S++)c = r[S], v = c.x - t, m = c.y - n, c.x = t + (v * f - m * o), c.y = n + (v * o + m * f); return r } }, e.contains = function (r, u) { for (var i = u.x, f = u.y, o = r.length, t = r[o - 1], n, s = 0; s < o; s++) { if (n = r[s], (i - t.x) * (n.y - t.y) + (f - t.y) * (t.x - n.x) > 0) return !1; t = n } return !0 }, e.scale = function (r, u, i, f) { if (u === 1 && i === 1) return r; f = f || e.centre(r); for (var o, t, n = 0; n < r.length; n++)o = r[n], t = l.sub(o, f), r[n].x = f.x + t.x * u, r[n].y = f.y + t.y * i; return r }, e.chamfer = function (r, u, i, f, o) { typeof u == "number" ? u = [u] : u = u || [8], i = typeof i < "u" ? i : -1, f = f || 2, o = o || 14; for (var t = [], n = 0; n < r.length; n++) { var s = r[n - 1 >= 0 ? n - 1 : r.length - 1], c = r[n], v = r[(n + 1) % r.length], m = u[n < u.length ? n : u.length - 1]; if (m === 0) { t.push(c); continue } var S = l.normalise({ x: c.y - s.y, y: s.x - c.x }), D = l.normalise({ x: v.y - c.y, y: c.x - v.x }), p = Math.sqrt(2 * Math.pow(m, 2)), g = l.mult(a.clone(S), m), x = l.normalise(l.mult(l.add(S, D), .5)), d = l.sub(c, l.mult(x, p)), w = i; i === -1 && (w = Math.pow(m, .32) * 1.75), w = a.clamp(w, f, o), w % 2 === 1 && (w += 1); for (var y = Math.acos(l.dot(S, D)), C = y / w, P = 0; P < w; P++)t.push(l.add(l.rotate(g, C * P), d)) } return t }, e.clockwiseSort = function (r) { var u = e.mean(r); return r.sort(function (i, f) { return l.angle(u, i) - l.angle(u, f) }), r }, e.isConvex = function (r) { var u = 0, i = r.length, f, o, t, n; if (i < 3) return null; for (f = 0; f < i; f++)if (o = (f + 1) % i, t = (f + 2) % i, n = (r[o].x - r[f].x) * (r[t].y - r[o].y), n -= (r[o].y - r[f].y) * (r[t].x - r[o].x), n < 0 ? u |= 1 : n > 0 && (u |= 2), u === 3) return !1; return u !== 0 ? !0 : null }, e.hull = function (r) { var u = [], i = [], f, o; for (r = r.slice(0), r.sort(function (t, n) { var s = t.x - n.x; return s !== 0 ? s : t.y - n.y }), o = 0; o < r.length; o += 1) { for (f = r[o]; i.length >= 2 && l.cross3(i[i.length - 2], i[i.length - 1], f) <= 0;)i.pop(); i.push(f) } for (o = r.length - 1; o >= 0; o -= 1) { for (f = r[o]; u.length >= 2 && l.cross3(u[u.length - 2], u[u.length - 1], f) <= 0;)u.pop(); u.push(f) } return u.pop(), i.pop(), u.concat(i) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(2), r = h(7), u = h(0), i = h(1), f = h(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var n = { id: u.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: l.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, s = u.extend(n, t); return o(s, t), s }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var o = function (t, n) { n = n || {}, e.set(t, { bounds: t.bounds || i.create(t.vertices), positionPrev: t.positionPrev || a.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), l.rotate(t.vertices, t.angle, t.position), f.rotate(t.axes, t.angle), i.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: n.axes || t.axes, area: n.area || t.area, mass: n.mass || t.mass, inertia: n.inertia || t.inertia }); var s = t.isStatic ? "#14151f" : u.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), c = t.isStatic ? "#555" : "#ccc", v = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || s, t.render.strokeStyle = t.render.strokeStyle || c, t.render.lineWidth = t.render.lineWidth || v, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, n, s) { var c; typeof n == "string" && (c = n, n = {}, n[c] = s); for (c in n) if (Object.prototype.hasOwnProperty.call(n, c)) switch (s = n[c], c) { case "isStatic": e.setStatic(t, s); break; case "isSleeping": r.set(t, s); break; case "mass": e.setMass(t, s); break; case "density": e.setDensity(t, s); break; case "inertia": e.setInertia(t, s); break; case "vertices": e.setVertices(t, s); break; case "position": e.setPosition(t, s); break; case "angle": e.setAngle(t, s); break; case "velocity": e.setVelocity(t, s); break; case "angularVelocity": e.setAngularVelocity(t, s); break; case "speed": e.setSpeed(t, s); break; case "angularSpeed": e.setAngularSpeed(t, s); break; case "parts": e.setParts(t, s); break; case "centre": e.setCentre(t, s); break; default: t[c] = s } }, e.setStatic = function (t, n) { for (var s = 0; s < t.parts.length; s++) { var c = t.parts[s]; n ? (c.isStatic || (c._original = { restitution: c.restitution, friction: c.friction, mass: c.mass, inertia: c.inertia, density: c.density, inverseMass: c.inverseMass, inverseInertia: c.inverseInertia }), c.restitution = 0, c.friction = 1, c.mass = c.inertia = c.density = 1 / 0, c.inverseMass = c.inverseInertia = 0, c.positionPrev.x = c.position.x, c.positionPrev.y = c.position.y, c.anglePrev = c.angle, c.angularVelocity = 0, c.speed = 0, c.angularSpeed = 0, c.motion = 0) : c._original && (c.restitution = c._original.restitution, c.friction = c._original.friction, c.mass = c._original.mass, c.inertia = c._original.inertia, c.density = c._original.density, c.inverseMass = c._original.inverseMass, c.inverseInertia = c._original.inverseInertia, c._original = null), c.isStatic = n } }, e.setMass = function (t, n) { var s = t.inertia / (t.mass / 6); t.inertia = s * (n / 6), t.inverseInertia = 1 / t.inertia, t.mass = n, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, n) { e.setMass(t, n * t.area), t.density = n }, e.setInertia = function (t, n) { t.inertia = n, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, n) { n[0].body === t ? t.vertices = n : t.vertices = l.create(n, t), t.axes = f.fromVertices(t.vertices), t.area = l.area(t.vertices), e.setMass(t, t.density * t.area); var s = l.centre(t.vertices); l.translate(t.vertices, s, -1), e.setInertia(t, e._inertiaScale * l.inertia(t.vertices, t.mass)), l.translate(t.vertices, t.position), i.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, n, s) { var c; for (n = n.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, c = 0; c < n.length; c++) { var v = n[c]; v !== t && (v.parent = t, t.parts.push(v)) } if (t.parts.length !== 1) { if (s = typeof s < "u" ? s : !0, s) { var m = []; for (c = 0; c < n.length; c++)m = m.concat(n[c].vertices); l.clockwiseSort(m); var S = l.hull(m), D = l.centre(S); e.setVertices(t, S), l.translate(t.vertices, D) } var p = e._totalProperties(t); t.area = p.area, t.parent = t, t.position.x = p.centre.x, t.position.y = p.centre.y, t.positionPrev.x = p.centre.x, t.positionPrev.y = p.centre.y, e.setMass(t, p.mass), e.setInertia(t, p.inertia), e.setPosition(t, p.centre) } }, e.setCentre = function (t, n, s) { s ? (t.positionPrev.x += n.x, t.positionPrev.y += n.y, t.position.x += n.x, t.position.y += n.y) : (t.positionPrev.x = n.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = n.y - (t.position.y - t.positionPrev.y), t.position.x = n.x, t.position.y = n.y) }, e.setPosition = function (t, n, s) { var c = a.sub(n, t.position); s ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = c.x, t.velocity.y = c.y, t.speed = a.magnitude(c)) : (t.positionPrev.x += c.x, t.positionPrev.y += c.y); for (var v = 0; v < t.parts.length; v++) { var m = t.parts[v]; m.position.x += c.x, m.position.y += c.y, l.translate(m.vertices, c), i.update(m.bounds, m.vertices, t.velocity) } }, e.setAngle = function (t, n, s) { var c = n - t.angle; s ? (t.anglePrev = t.angle, t.angularVelocity = c, t.angularSpeed = Math.abs(c)) : t.anglePrev += c; for (var v = 0; v < t.parts.length; v++) { var m = t.parts[v]; m.angle += c, l.rotate(m.vertices, c, t.position), f.rotate(m.axes, c), i.update(m.bounds, m.vertices, t.velocity), v > 0 && a.rotateAbout(m.position, c, t.position, m.position) } }, e.setVelocity = function (t, n) { var s = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - n.x * s, t.positionPrev.y = t.position.y - n.y * s, t.velocity.x = (t.position.x - t.positionPrev.x) / s, t.velocity.y = (t.position.y - t.positionPrev.y) / s, t.speed = a.magnitude(t.velocity) }, e.getVelocity = function (t) { var n = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * n, y: (t.position.y - t.positionPrev.y) * n } }, e.getSpeed = function (t) { return a.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, n) { e.setVelocity(t, a.mult(a.normalise(e.getVelocity(t)), n)) }, e.setAngularVelocity = function (t, n) { var s = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - n * s, t.angularVelocity = (t.angle - t.anglePrev) / s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, n) { e.setAngularVelocity(t, u.sign(e.getAngularVelocity(t)) * n) }, e.translate = function (t, n, s) { e.setPosition(t, a.add(t.position, n), s) }, e.rotate = function (t, n, s, c) { if (!s) e.setAngle(t, t.angle + n, c); else { var v = Math.cos(n), m = Math.sin(n), S = t.position.x - s.x, D = t.position.y - s.y; e.setPosition(t, { x: s.x + (S * v - D * m), y: s.y + (S * m + D * v) }, c), e.setAngle(t, t.angle + n, c) } }, e.scale = function (t, n, s, c) { var v = 0, m = 0; c = c || t.position; for (var S = 0; S < t.parts.length; S++) { var D = t.parts[S]; l.scale(D.vertices, n, s, c), D.axes = f.fromVertices(D.vertices), D.area = l.area(D.vertices), e.setMass(D, t.density * D.area), l.translate(D.vertices, { x: -D.position.x, y: -D.position.y }), e.setInertia(D, e._inertiaScale * l.inertia(D.vertices, D.mass)), l.translate(D.vertices, { x: D.position.x, y: D.position.y }), S > 0 && (v += D.area, m += D.inertia), D.position.x = c.x + (D.position.x - c.x) * n, D.position.y = c.y + (D.position.y - c.y) * s, i.update(D.bounds, D.vertices, t.velocity) } t.parts.length > 1 && (t.area = v, t.isStatic || (e.setMass(t, t.density * v), e.setInertia(t, m))), t.circleRadius && (n === s ? t.circleRadius *= n : t.circleRadius = null) }, e.update = function (t, n) { n = (typeof n < "u" ? n : 1e3 / 60) * t.timeScale; var s = n * n, c = e._timeCorrection ? n / (t.deltaTime || n) : 1, v = 1 - t.frictionAir * (n / u._baseDelta), m = (t.position.x - t.positionPrev.x) * c, S = (t.position.y - t.positionPrev.y) * c; t.velocity.x = m * v + t.force.x / t.mass * s, t.velocity.y = S * v + t.force.y / t.mass * s, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = n, t.angularVelocity = (t.angle - t.anglePrev) * v * c + t.torque / t.inertia * s, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var D = 0; D < t.parts.length; D++) { var p = t.parts[D]; l.translate(p.vertices, t.velocity), D > 0 && (p.position.x += t.velocity.x, p.position.y += t.velocity.y), t.angularVelocity !== 0 && (l.rotate(p.vertices, t.angularVelocity, t.position), f.rotate(p.axes, t.angularVelocity), D > 0 && a.rotateAbout(p.position, t.angularVelocity, t.position, p.position)), i.update(p.bounds, p.vertices, t.velocity) } }, e.updateVelocities = function (t) { var n = e._baseDelta / t.deltaTime, s = t.velocity; s.x = (t.position.x - t.positionPrev.x) * n, s.y = (t.position.y - t.positionPrev.y) * n, t.speed = Math.sqrt(s.x * s.x + s.y * s.y), t.angularVelocity = (t.angle - t.anglePrev) * n, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, n, s) { var c = { x: n.x - t.position.x, y: n.y - t.position.y }; t.force.x += s.x, t.force.y += s.y, t.torque += c.x * s.y - c.y * s.x }, e._totalProperties = function (t) { for (var n = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, s = t.parts.length === 1 ? 0 : 1; s < t.parts.length; s++) { var c = t.parts[s], v = c.mass !== 1 / 0 ? c.mass : 1; n.mass += v, n.area += c.area, n.inertia += c.inertia, n.centre = a.add(n.centre, a.mult(c.position, v)) } return n.centre = a.div(n.centre, n.mass), n } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(0); (function () { e.on = function (a, r, u) { for (var i = r.split(" "), f, o = 0; o < i.length; o++)f = i[o], a.events = a.events || {}, a.events[f] = a.events[f] || [], a.events[f].push(u); return u }, e.off = function (a, r, u) { if (!r) { a.events = {}; return } typeof r == "function" && (u = r, r = l.keys(a.events).join(" ")); for (var i = r.split(" "), f = 0; f < i.length; f++) { var o = a.events[i[f]], t = []; if (u && o) for (var n = 0; n < o.length; n++)o[n] !== u && t.push(o[n]); a.events[i[f]] = t } }, e.trigger = function (a, r, u) { var i, f, o, t, n = a.events; if (n && l.keys(n).length > 0) { u || (u = {}), i = r.split(" "); for (var s = 0; s < i.length; s++)if (f = i[s], o = n[f], o) { t = l.clone(u, !1), t.name = f, t.source = a; for (var c = 0; c < o.length; c++)o[c].apply(a, [t]) } } } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(5), a = h(0), r = h(1), u = h(4); (function () { e.create = function (i) { return a.extend({ id: a.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, i) }, e.setModified = function (i, f, o, t) { if (i.isModified = f, f && i.cache && (i.cache.allBodies = null, i.cache.allConstraints = null, i.cache.allComposites = null), o && i.parent && e.setModified(i.parent, f, o, t), t) for (var n = 0; n < i.composites.length; n++) { var s = i.composites[n]; e.setModified(s, f, o, t) } }, e.add = function (i, f) { var o = [].concat(f); l.trigger(i, "beforeAdd", { object: f }); for (var t = 0; t < o.length; t++) { var n = o[t]; switch (n.type) { case "body": if (n.parent !== n) { a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(i, n); break; case "constraint": e.addConstraint(i, n); break; case "composite": e.addComposite(i, n); break; case "mouseConstraint": e.addConstraint(i, n.constraint); break } } return l.trigger(i, "afterAdd", { object: f }), i }, e.remove = function (i, f, o) { var t = [].concat(f); l.trigger(i, "beforeRemove", { object: f }); for (var n = 0; n < t.length; n++) { var s = t[n]; switch (s.type) { case "body": e.removeBody(i, s, o); break; case "constraint": e.removeConstraint(i, s, o); break; case "composite": e.removeComposite(i, s, o); break; case "mouseConstraint": e.removeConstraint(i, s.constraint); break } } return l.trigger(i, "afterRemove", { object: f }), i }, e.addComposite = function (i, f) { return i.composites.push(f), f.parent = i, e.setModified(i, !0, !0, !1), i }, e.removeComposite = function (i, f, o) { var t = a.indexOf(i.composites, f); if (t !== -1) { var n = e.allBodies(f); e.removeCompositeAt(i, t); for (var s = 0; s < n.length; s++)n[s].sleepCounter = 0 } if (o) for (var s = 0; s < i.composites.length; s++)e.removeComposite(i.composites[s], f, !0); return i }, e.removeCompositeAt = function (i, f) { return i.composites.splice(f, 1), e.setModified(i, !0, !0, !1), i }, e.addBody = function (i, f) { return i.bodies.push(f), e.setModified(i, !0, !0, !1), i }, e.removeBody = function (i, f, o) { var t = a.indexOf(i.bodies, f); if (t !== -1 && (e.removeBodyAt(i, t), f.sleepCounter = 0), o) for (var n = 0; n < i.composites.length; n++)e.removeBody(i.composites[n], f, !0); return i }, e.removeBodyAt = function (i, f) { return i.bodies.splice(f, 1), e.setModified(i, !0, !0, !1), i }, e.addConstraint = function (i, f) { return i.constraints.push(f), e.setModified(i, !0, !0, !1), i }, e.removeConstraint = function (i, f, o) { var t = a.indexOf(i.constraints, f); if (t !== -1 && e.removeConstraintAt(i, t), o) for (var n = 0; n < i.composites.length; n++)e.removeConstraint(i.composites[n], f, !0); return i }, e.removeConstraintAt = function (i, f) { return i.constraints.splice(f, 1), e.setModified(i, !0, !0, !1), i }, e.clear = function (i, f, o) { if (o) for (var t = 0; t < i.composites.length; t++)e.clear(i.composites[t], f, !0); return f ? i.bodies = i.bodies.filter(function (n) { return n.isStatic }) : i.bodies.length = 0, i.constraints.length = 0, i.composites.length = 0, e.setModified(i, !0, !0, !1), i }, e.allBodies = function (i) { if (i.cache && i.cache.allBodies) return i.cache.allBodies; for (var f = [].concat(i.bodies), o = 0; o < i.composites.length; o++)f = f.concat(e.allBodies(i.composites[o])); return i.cache && (i.cache.allBodies = f), f }, e.allConstraints = function (i) { if (i.cache && i.cache.allConstraints) return i.cache.allConstraints; for (var f = [].concat(i.constraints), o = 0; o < i.composites.length; o++)f = f.concat(e.allConstraints(i.composites[o])); return i.cache && (i.cache.allConstraints = f), f }, e.allComposites = function (i) { if (i.cache && i.cache.allComposites) return i.cache.allComposites; for (var f = [].concat(i.composites), o = 0; o < i.composites.length; o++)f = f.concat(e.allComposites(i.composites[o])); return i.cache && (i.cache.allComposites = f), f }, e.get = function (i, f, o) { var t, n; switch (o) { case "body": t = e.allBodies(i); break; case "constraint": t = e.allConstraints(i); break; case "composite": t = e.allComposites(i).concat(i); break }return t ? (n = t.filter(function (s) { return s.id.toString() === f.toString() }), n.length === 0 ? null : n[0]) : null }, e.move = function (i, f, o) { return e.remove(i, f), e.add(o, f), i }, e.rebase = function (i) { for (var f = e.allBodies(i).concat(e.allConstraints(i)).concat(e.allComposites(i)), o = 0; o < f.length; o++)f[o].id = a.nextId(); return i }, e.translate = function (i, f, o) { for (var t = o ? e.allBodies(i) : i.bodies, n = 0; n < t.length; n++)u.translate(t[n], f); return i }, e.rotate = function (i, f, o, t) { for (var n = Math.cos(f), s = Math.sin(f), c = t ? e.allBodies(i) : i.bodies, v = 0; v < c.length; v++) { var m = c[v], S = m.position.x - o.x, D = m.position.y - o.y; u.setPosition(m, { x: o.x + (S * n - D * s), y: o.y + (S * s + D * n) }), u.rotate(m, f) } return i }, e.scale = function (i, f, o, t, n) { for (var s = n ? e.allBodies(i) : i.bodies, c = 0; c < s.length; c++) { var v = s[c], m = v.position.x - t.x, S = v.position.y - t.y; u.setPosition(v, { x: t.x + m * f, y: t.y + S * o }), u.scale(v, f, o) } return i }, e.bounds = function (i) { for (var f = e.allBodies(i), o = [], t = 0; t < f.length; t += 1) { var n = f[t]; o.push(n.bounds.min, n.bounds.max) } return r.create(o) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(4), a = h(5), r = h(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (u, i) { for (var f = i / r._baseDelta, o = e._motionSleepThreshold, t = 0; t < u.length; t++) { var n = u[t], s = l.getSpeed(n), c = l.getAngularSpeed(n), v = s * s + c * c; if (n.force.x !== 0 || n.force.y !== 0) { e.set(n, !1); continue } var m = Math.min(n.motion, v), S = Math.max(n.motion, v); n.motion = e._minBias * m + (1 - e._minBias) * S, n.sleepThreshold > 0 && n.motion < o ? (n.sleepCounter += 1, n.sleepCounter >= n.sleepThreshold / f && e.set(n, !0)) : n.sleepCounter > 0 && (n.sleepCounter -= 1) } }, e.afterCollisions = function (u) { for (var i = e._motionSleepThreshold, f = 0; f < u.length; f++) { var o = u[f]; if (o.isActive) { var t = o.collision, n = t.bodyA.parent, s = t.bodyB.parent; if (!(n.isSleeping && s.isSleeping || n.isStatic || s.isStatic) && (n.isSleeping || s.isSleeping)) { var c = n.isSleeping && !n.isStatic ? n : s, v = c === n ? s : n; !c.isStatic && v.motion > i && e.set(c, !1) } } } }, e.set = function (u, i) { var f = u.isSleeping; i ? (u.isSleeping = !0, u.sleepCounter = u.sleepThreshold, u.positionImpulse.x = 0, u.positionImpulse.y = 0, u.positionPrev.x = u.position.x, u.positionPrev.y = u.position.y, u.anglePrev = u.angle, u.speed = 0, u.angularSpeed = 0, u.motion = 0, f || a.trigger(u, "sleepStart")) : (u.isSleeping = !1, u.sleepCounter = 0, f && a.trigger(u, "sleepEnd")) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(9); (function () { var r = [], u = { overlap: 0, axis: null }, i = { overlap: 0, axis: null }; e.create = function (f, o) { return { pair: null, collided: !1, bodyA: f, bodyB: o, parentA: f.parent, parentB: o.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (f, o, t) { if (e._overlapAxes(u, f.vertices, o.vertices, f.axes), u.overlap <= 0 || (e._overlapAxes(i, o.vertices, f.vertices, o.axes), i.overlap <= 0)) return null; var n = t && t.table[a.id(f, o)], s; n ? s = n.collision : (s = e.create(f, o), s.collided = !0, s.bodyA = f.id < o.id ? f : o, s.bodyB = f.id < o.id ? o : f, s.parentA = s.bodyA.parent, s.parentB = s.bodyB.parent), f = s.bodyA, o = s.bodyB; var c; u.overlap < i.overlap ? c = u : c = i; var v = s.normal, m = s.tangent, S = s.penetration, D = s.supports, p = c.overlap, g = c.axis, x = g.x, d = g.y, w = o.position.x - f.position.x, y = o.position.y - f.position.y; x * w + d * y >= 0 && (x = -x, d = -d), v.x = x, v.y = d, m.x = -d, m.y = x, S.x = x * p, S.y = d * p, s.depth = p; var C = e._findSupports(f, o, v, 1), P = 0; if (l.contains(f.vertices, C[0]) && (D[P++] = C[0]), l.contains(f.vertices, C[1]) && (D[P++] = C[1]), P < 2) { var T = e._findSupports(o, f, v, -1); l.contains(o.vertices, T[0]) && (D[P++] = T[0]), P < 2 && l.contains(o.vertices, T[1]) && (D[P++] = T[1]) } return P === 0 && (D[P++] = C[0]), s.supportCount = P, s }, e._overlapAxes = function (f, o, t, n) { var s = o.length, c = t.length, v = o[0].x, m = o[0].y, S = t[0].x, D = t[0].y, p = n.length, g = Number.MAX_VALUE, x = 0, d, w, y, C, P, T; for (P = 0; P < p; P++) { var E = n[P], I = E.x, B = E.y, L = v * I + m * B, F = S * I + D * B, W = L, b = F; for (T = 1; T < s; T += 1)C = o[T].x * I + o[T].y * B, C > W ? W = C : C < L && (L = C); for (T = 1; T < c; T += 1)C = t[T].x * I + t[T].y * B, C > b ? b = C : C < F && (F = C); if (w = W - F, y = b - L, d = w < y ? w : y, d < g && (g = d, x = P, d <= 0)) break } f.axis = n[x], f.overlap = g }, e._findSupports = function (f, o, t, n) { var s = o.vertices, c = s.length, v = f.position.x, m = f.position.y, S = t.x * n, D = t.y * n, p = s[0], g = p, x = S * (v - g.x) + D * (m - g.y), d, w, y; for (y = 1; y < c; y += 1)g = s[y], w = S * (v - g.x) + D * (m - g.y), w < x && (x = w, p = g); return d = s[(c + p.index - 1) % c], x = S * (v - d.x) + D * (m - d.y), g = s[(p.index + 1) % c], S * (v - g.x) + D * (m - g.y) < x ? (r[0] = p, r[1] = g, r) : (r[0] = p, r[1] = d, r) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(16); (function () { e.create = function (a, r) { var u = a.bodyA, i = a.bodyB, f = { id: e.id(u, i), bodyA: u, bodyB: i, collision: a, contacts: [l.create(), l.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: u.isSensor || i.isSensor, timeCreated: r, timeUpdated: r, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(f, a, r), f }, e.update = function (a, r, u) { var i = r.supports, f = r.supportCount, o = a.contacts, t = r.parentA, n = r.parentB; a.isActive = !0, a.timeUpdated = u, a.collision = r, a.separation = r.depth, a.inverseMass = t.inverseMass + n.inverseMass, a.friction = t.friction < n.friction ? t.friction : n.friction, a.frictionStatic = t.frictionStatic > n.frictionStatic ? t.frictionStatic : n.frictionStatic, a.restitution = t.restitution > n.restitution ? t.restitution : n.restitution, a.slop = t.slop > n.slop ? t.slop : n.slop, a.contactCount = f, r.pair = a; var s = i[0], c = o[0], v = i[1], m = o[1]; (m.vertex === s || c.vertex === v) && (o[1] = c, o[0] = c = m, m = o[1]), c.vertex = s, m.vertex = v }, e.setActive = function (a, r, u) { r ? (a.isActive = !0, a.timeUpdated = u) : (a.isActive = !1, a.contactCount = 0) }, e.id = function (a, r) { return a.id < r.id ? a.id.toString(36) + ":" + r.id.toString(36) : r.id.toString(36) + ":" + a.id.toString(36) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(2), r = h(7), u = h(1), i = h(11), f = h(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (o) { var t = o; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var n = t.bodyA ? a.add(t.bodyA.position, t.pointA) : t.pointA, s = t.bodyB ? a.add(t.bodyB.position, t.pointB) : t.pointB, c = a.magnitude(a.sub(n, s)); t.length = typeof t.length < "u" ? t.length : c, t.id = t.id || f.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var v = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (v.type = "pin", v.anchors = !1) : t.stiffness < .9 && (v.type = "spring"), t.render = f.extend(v, t.render), t }, e.preSolveAll = function (o) { for (var t = 0; t < o.length; t += 1) { var n = o[t], s = n.constraintImpulse; n.isStatic || s.x === 0 && s.y === 0 && s.angle === 0 || (n.position.x += s.x, n.position.y += s.y, n.angle += s.angle) } }, e.solveAll = function (o, t) { for (var n = f.clamp(t / f._baseDelta, 0, 1), s = 0; s < o.length; s += 1) { var c = o[s], v = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic; (v || m) && e.solve(o[s], n) } for (s = 0; s < o.length; s += 1)c = o[s], v = !c.bodyA || c.bodyA && c.bodyA.isStatic, m = !c.bodyB || c.bodyB && c.bodyB.isStatic, !v && !m && e.solve(o[s], n) }, e.solve = function (o, t) { var n = o.bodyA, s = o.bodyB, c = o.pointA, v = o.pointB; if (!(!n && !s)) { n && !n.isStatic && (a.rotate(c, n.angle - o.angleA, c), o.angleA = n.angle), s && !s.isStatic && (a.rotate(v, s.angle - o.angleB, v), o.angleB = s.angle); var m = c, S = v; if (n && (m = a.add(n.position, c)), s && (S = a.add(s.position, v)), !(!m || !S)) { var D = a.sub(m, S), p = a.magnitude(D); p < e._minLength && (p = e._minLength); var g = (p - o.length) / p, x = o.stiffness >= 1 || o.length === 0, d = x ? o.stiffness * t : o.stiffness * t * t, w = o.damping * t, y = a.mult(D, g * d), C = (n ? n.inverseMass : 0) + (s ? s.inverseMass : 0), P = (n ? n.inverseInertia : 0) + (s ? s.inverseInertia : 0), T = C + P, E, I, B, L, F; if (w > 0) { var W = a.create(); B = a.div(D, p), F = a.sub(s && a.sub(s.position, s.positionPrev) || W, n && a.sub(n.position, n.positionPrev) || W), L = a.dot(B, F) } n && !n.isStatic && (I = n.inverseMass / C, n.constraintImpulse.x -= y.x * I, n.constraintImpulse.y -= y.y * I, n.position.x -= y.x * I, n.position.y -= y.y * I, w > 0 && (n.positionPrev.x -= w * B.x * L * I, n.positionPrev.y -= w * B.y * L * I), E = a.cross(c, y) / T * e._torqueDampen * n.inverseInertia * (1 - o.angularStiffness), n.constraintImpulse.angle -= E, n.angle -= E), s && !s.isStatic && (I = s.inverseMass / C, s.constraintImpulse.x += y.x * I, s.constraintImpulse.y += y.y * I, s.position.x += y.x * I, s.position.y += y.y * I, w > 0 && (s.positionPrev.x += w * B.x * L * I, s.positionPrev.y += w * B.y * L * I), E = a.cross(v, y) / T * e._torqueDampen * s.inverseInertia * (1 - o.angularStiffness), s.constraintImpulse.angle += E, s.angle += E) } } }, e.postSolveAll = function (o) { for (var t = 0; t < o.length; t++) { var n = o[t], s = n.constraintImpulse; if (!(n.isStatic || s.x === 0 && s.y === 0 && s.angle === 0)) { r.set(n, !1); for (var c = 0; c < n.parts.length; c++) { var v = n.parts[c]; l.translate(v.vertices, s), c > 0 && (v.position.x += s.x, v.position.y += s.y), s.angle !== 0 && (l.rotate(v.vertices, s.angle, n.position), i.rotate(v.axes, s.angle), c > 0 && a.rotateAbout(v.position, s.angle, n.position, v.position)), u.update(v.bounds, v.vertices, n.velocity) } s.angle *= e._warming, s.x *= e._warming, s.y *= e._warming } } }, e.pointAWorld = function (o) { return { x: (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), y: (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0) } }, e.pointBWorld = function (o) { return { x: (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), y: (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0) } }, e.currentLength = function (o) { var t = (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), n = (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0), s = (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), c = (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0), v = t - s, m = n - c; return Math.sqrt(v * v + m * m) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(2), a = h(0); (function () { e.fromVertices = function (r) { for (var u = {}, i = 0; i < r.length; i++) { var f = (i + 1) % r.length, o = l.normalise({ x: r[f].y - r[i].y, y: r[i].x - r[f].x }), t = o.y === 0 ? 1 / 0 : o.x / o.y; t = t.toFixed(3).toString(), u[t] = o } return a.values(u) }, e.rotate = function (r, u) { if (u !== 0) for (var i = Math.cos(u), f = Math.sin(u), o = 0; o < r.length; o++) { var t = r[o], n; n = t.x * i - t.y * f, t.y = t.x * f + t.y * i, t.x = n } } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(0), r = h(4), u = h(1), i = h(2); (function () { e.rectangle = function (f, o, t, n, s) { s = s || {}; var c = { label: "Rectangle Body", position: { x: f, y: o }, vertices: l.fromPath("L 0 0 L " + t + " 0 L " + t + " " + n + " L 0 " + n) }; if (s.chamfer) { var v = s.chamfer; c.vertices = l.chamfer(c.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete s.chamfer } return r.create(a.extend({}, c, s)) }, e.trapezoid = function (f, o, t, n, s, c) { c = c || {}, s >= 1 && a.warn("Bodies.trapezoid: slope parameter must be < 1."), s *= .5; var v = (1 - s * 2) * t, m = t * s, S = m + v, D = S + m, p; s < .5 ? p = "L 0 0 L " + m + " " + -n + " L " + S + " " + -n + " L " + D + " 0" : p = "L 0 0 L " + S + " " + -n + " L " + D + " 0"; var g = { label: "Trapezoid Body", position: { x: f, y: o }, vertices: l.fromPath(p) }; if (c.chamfer) { var x = c.chamfer; g.vertices = l.chamfer(g.vertices, x.radius, x.quality, x.qualityMin, x.qualityMax), delete c.chamfer } return r.create(a.extend({}, g, c)) }, e.circle = function (f, o, t, n, s) { n = n || {}; var c = { label: "Circle Body", circleRadius: t }; s = s || 25; var v = Math.ceil(Math.max(10, Math.min(s, t))); return v % 2 === 1 && (v += 1), e.polygon(f, o, v, t, a.extend({}, c, n)) }, e.polygon = function (f, o, t, n, s) { if (s = s || {}, t < 3) return e.circle(f, o, n, s); for (var c = 2 * Math.PI / t, v = "", m = c * .5, S = 0; S < t; S += 1) { var D = m + S * c, p = Math.cos(D) * n, g = Math.sin(D) * n; v += "L " + p.toFixed(3) + " " + g.toFixed(3) + " " } var x = { label: "Polygon Body", position: { x: f, y: o }, vertices: l.fromPath(v) }; if (s.chamfer) { var d = s.chamfer; x.vertices = l.chamfer(x.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete s.chamfer } return r.create(a.extend({}, x, s)) }, e.fromVertices = function (f, o, t, n, s, c, v, m) { var S = a.getDecomp(), D, p, g, x, d, w, y, C, P, T, E; for (D = !!(S && S.quickDecomp), n = n || {}, g = [], s = typeof s < "u" ? s : !1, c = typeof c < "u" ? c : .01, v = typeof v < "u" ? v : 10, m = typeof m < "u" ? m : .01, a.isArray(t[0]) || (t = [t]), T = 0; T < t.length; T += 1)if (w = t[T], x = l.isConvex(w), d = !x, d && !D && a.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), x || !D) x ? w = l.clockwiseSort(w) : w = l.hull(w), g.push({ position: { x: f, y: o }, vertices: w }); else { var I = w.map(function (V) { return [V.x, V.y] }); S.makeCCW(I), c !== !1 && S.removeCollinearPoints(I, c), m !== !1 && S.removeDuplicatePoints && S.removeDuplicatePoints(I, m); var B = S.quickDecomp(I); for (y = 0; y < B.length; y++) { var L = B[y], F = L.map(function (V) { return { x: V[0], y: V[1] } }); v > 0 && l.area(F) < v || g.push({ position: l.centre(F), vertices: F }) } } for (y = 0; y < g.length; y++)g[y] = r.create(a.extend(g[y], n)); if (s) { var W = 5; for (y = 0; y < g.length; y++) { var b = g[y]; for (C = y + 1; C < g.length; C++) { var G = g[C]; if (u.overlaps(b.bounds, G.bounds)) { var $ = b.vertices, q = G.vertices; for (P = 0; P < b.vertices.length; P++)for (E = 0; E < G.vertices.length; E++) { var ee = i.magnitudeSquared(i.sub($[(P + 1) % $.length], q[E])), Z = i.magnitudeSquared(i.sub($[P], q[(E + 1) % q.length])); ee < W && Z < W && ($[P].isInternal = !0, q[E].isInternal = !0) } } } } } return g.length > 1 ? (p = r.create(a.extend({ parts: g.slice(0) }, n)), r.setPosition(p, { x: f, y: o }), p) : g[0] } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(0), a = h(8); (function () { e.create = function (r) { var u = { bodies: [], collisions: [], pairs: null }; return l.extend(u, r) }, e.setBodies = function (r, u) { r.bodies = u.slice(0) }, e.clear = function (r) { r.bodies = [], r.collisions = [] }, e.collisions = function (r) { var u = r.pairs, i = r.bodies, f = i.length, o = e.canCollide, t = a.collides, n = r.collisions, s = 0, c, v; for (i.sort(e._compareBoundsX), c = 0; c < f; c++) { var m = i[c], S = m.bounds, D = m.bounds.max.x, p = m.bounds.max.y, g = m.bounds.min.y, x = m.isStatic || m.isSleeping, d = m.parts.length, w = d === 1; for (v = c + 1; v < f; v++) { var y = i[v], C = y.bounds; if (C.min.x > D) break; if (!(p < C.min.y || g > C.max.y) && !(x && (y.isStatic || y.isSleeping)) && o(m.collisionFilter, y.collisionFilter)) { var P = y.parts.length; if (w && P === 1) { var T = t(m, y, u); T && (n[s++] = T) } else for (var E = d > 1 ? 1 : 0, I = P > 1 ? 1 : 0, B = E; B < d; B++)for (var L = m.parts[B], S = L.bounds, F = I; F < P; F++) { var W = y.parts[F], C = W.bounds; if (!(S.min.x > C.max.x || S.max.x < C.min.x || S.max.y < C.min.y || S.min.y > C.max.y)) { var T = t(L, W, u); T && (n[s++] = T) } } } } } return n.length !== s && (n.length = s), n }, e.canCollide = function (r, u) { return r.group === u.group && r.group !== 0 ? r.group > 0 : (r.mask & u.category) !== 0 && (u.mask & r.category) !== 0 }, e._compareBoundsX = function (r, u) { return r.bounds.min.x - u.bounds.min.x } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(0); (function () { e.create = function (a) { var r = {}; return a || l.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), r.element = a || document.body, r.absolute = { x: 0, y: 0 }, r.position = { x: 0, y: 0 }, r.mousedownPosition = { x: 0, y: 0 }, r.mouseupPosition = { x: 0, y: 0 }, r.offset = { x: 0, y: 0 }, r.scale = { x: 1, y: 1 }, r.wheelDelta = 0, r.button = -1, r.pixelRatio = parseInt(r.element.getAttribute("data-pixel-ratio"), 10) || 1, r.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, r.mousemove = function (u) { var i = e._getRelativeMousePosition(u, r.element, r.pixelRatio), f = u.changedTouches; f && (r.button = 0, u.preventDefault()), r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.sourceEvents.mousemove = u }, r.mousedown = function (u) { var i = e._getRelativeMousePosition(u, r.element, r.pixelRatio), f = u.changedTouches; f ? (r.button = 0, u.preventDefault()) : r.button = u.button, r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mousedownPosition.x = r.position.x, r.mousedownPosition.y = r.position.y, r.sourceEvents.mousedown = u }, r.mouseup = function (u) { var i = e._getRelativeMousePosition(u, r.element, r.pixelRatio), f = u.changedTouches; f && u.preventDefault(), r.button = -1, r.absolute.x = i.x, r.absolute.y = i.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mouseupPosition.x = r.position.x, r.mouseupPosition.y = r.position.y, r.sourceEvents.mouseup = u }, r.mousewheel = function (u) { r.wheelDelta = Math.max(-1, Math.min(1, u.wheelDelta || -u.detail)), u.preventDefault(), r.sourceEvents.mousewheel = u }, e.setElement(r, r.element), r }, e.setElement = function (a, r) { a.element = r, r.addEventListener("mousemove", a.mousemove, { passive: !0 }), r.addEventListener("mousedown", a.mousedown, { passive: !0 }), r.addEventListener("mouseup", a.mouseup, { passive: !0 }), r.addEventListener("wheel", a.mousewheel, { passive: !1 }), r.addEventListener("touchmove", a.mousemove, { passive: !1 }), r.addEventListener("touchstart", a.mousedown, { passive: !1 }), r.addEventListener("touchend", a.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (a) { a.sourceEvents.mousemove = null, a.sourceEvents.mousedown = null, a.sourceEvents.mouseup = null, a.sourceEvents.mousewheel = null, a.wheelDelta = 0 }, e.setOffset = function (a, r) { a.offset.x = r.x, a.offset.y = r.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }, e.setScale = function (a, r) { a.scale.x = r.x, a.scale.y = r.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }, e._getRelativeMousePosition = function (a, r, u) { var i = r.getBoundingClientRect(), f = document.documentElement || document.body.parentNode || document.body, o = window.pageXOffset !== void 0 ? window.pageXOffset : f.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : f.scrollTop, n = a.changedTouches, s, c; return n ? (s = n[0].pageX - i.left - o, c = n[0].pageY - i.top - t) : (s = a.pageX - i.left - o, c = a.pageY - i.top - t), { x: s / (r.clientWidth / (r.width || r.clientWidth) * u), y: c / (r.clientHeight / (r.height || r.clientHeight) * u) } } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(0); (function () { e._registry = {}, e.register = function (a) { if (e.isPlugin(a) || l.warn("Plugin.register:", e.toString(a), "does not implement all required fields."), a.name in e._registry) { var r = e._registry[a.name], u = e.versionParse(a.version).number, i = e.versionParse(r.version).number; u > i ? (l.warn("Plugin.register:", e.toString(r), "was upgraded to", e.toString(a)), e._registry[a.name] = a) : u < i ? l.warn("Plugin.register:", e.toString(r), "can not be downgraded to", e.toString(a)) : a !== r && l.warn("Plugin.register:", e.toString(a), "is already registered to different plugin object") } else e._registry[a.name] = a; return a }, e.resolve = function (a) { return e._registry[e.dependencyParse(a).name] }, e.toString = function (a) { return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0") }, e.isPlugin = function (a) { return a && a.name && a.version && a.install }, e.isUsed = function (a, r) { return a.used.indexOf(r) > -1 }, e.isFor = function (a, r) { var u = a.for && e.dependencyParse(a.for); return !a.for || r.name === u.name && e.versionSatisfies(r.version, u.range) }, e.use = function (a, r) { if (a.uses = (a.uses || []).concat(r || []), a.uses.length === 0) { l.warn("Plugin.use:", e.toString(a), "does not specify any dependencies to install."); return } for (var u = e.dependencies(a), i = l.topologicalSort(u), f = [], o = 0; o < i.length; o += 1)if (i[o] !== a.name) { var t = e.resolve(i[o]); if (!t) { f.push("❌ " + i[o]); continue } e.isUsed(a, t.name) || (e.isFor(t, a) || (l.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(a) + "."), t._warned = !0), t.install ? t.install(a) : (l.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (f.push("🔶 " + e.toString(t)), delete t._warned) : f.push("✅ " + e.toString(t)), a.used.push(t.name)) } f.length > 0 && l.info(f.join("  ")) }, e.dependencies = function (a, r) { var u = e.dependencyParse(a), i = u.name; if (r = r || {}, !(i in r)) { a = e.resolve(a) || a, r[i] = l.map(a.uses || [], function (o) { e.isPlugin(o) && e.register(o); var t = e.dependencyParse(o), n = e.resolve(o); return n && !e.versionSatisfies(n.version, t.range) ? (l.warn("Plugin.dependencies:", e.toString(n), "does not satisfy", e.toString(t), "used by", e.toString(u) + "."), n._warned = !0, a._warned = !0) : n || (l.warn("Plugin.dependencies:", e.toString(o), "used by", e.toString(u), "could not be resolved."), a._warned = !0), t.name }); for (var f = 0; f < r[i].length; f += 1)e.dependencies(r[i][f], r); return r } }, e.dependencyParse = function (a) { if (l.isString(a)) { var r = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return r.test(a) || l.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."), { name: a.split("@")[0], range: a.split("@")[1] || "*" } } return { name: a.name, range: a.range || a.version } }, e.versionParse = function (a) { var r = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; r.test(a) || l.warn("Plugin.versionParse:", a, "is not a valid version or range."); var u = r.exec(a), i = Number(u[4]), f = Number(u[5]), o = Number(u[6]); return { isRange: !!(u[1] || u[2]), version: u[3], range: a, operator: u[1] || u[2] || "", major: i, minor: f, patch: o, parts: [i, f, o], prerelease: u[7], number: i * 1e8 + f * 1e4 + o } }, e.versionSatisfies = function (a, r) { r = r || "*"; var u = e.versionParse(r), i = e.versionParse(a); if (u.isRange) { if (u.operator === "*" || a === "*") return !0; if (u.operator === ">") return i.number > u.number; if (u.operator === ">=") return i.number >= u.number; if (u.operator === "~") return i.major === u.major && i.minor === u.minor && i.patch >= u.patch; if (u.operator === "^") return u.major > 0 ? i.major === u.major && i.number >= u.number : u.minor > 0 ? i.minor === u.minor && i.patch >= u.patch : i.patch === u.patch } return a === r || a === "*" } })() }, function (M, O) { var h = {}; M.exports = h, function () { h.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(7), a = h(18), r = h(13), u = h(19), i = h(5), f = h(6), o = h(10), t = h(0), n = h(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (s) { s = s || {}; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, v = t.extend(c, s); return v.world = s.world || f.create({ label: "World" }), v.pairs = s.pairs || u.create(), v.detector = s.detector || r.create(), v.detector.pairs = v.pairs, v.grid = { buckets: [] }, v.world.gravity = v.gravity, v.broadphase = v.grid, v.metrics = {}, v }, e.update = function (s, c) { var v = t.now(), m = s.world, S = s.detector, D = s.pairs, p = s.timing, g = p.timestamp, x; c > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), c = typeof c < "u" ? c : t._baseDelta, c *= p.timeScale, p.timestamp += c, p.lastDelta = c; var d = { timestamp: p.timestamp, delta: c }; i.trigger(s, "beforeUpdate", d); var w = f.allBodies(m), y = f.allConstraints(m); for (m.isModified && (r.setBodies(S, w), f.setModified(m, !1, !1, !0)), s.enableSleeping && l.update(w, c), e._bodiesApplyGravity(w, s.gravity), c > 0 && e._bodiesUpdate(w, c), i.trigger(s, "beforeSolve", d), o.preSolveAll(w), x = 0; x < s.constraintIterations; x++)o.solveAll(y, c); o.postSolveAll(w); var C = r.collisions(S); u.update(D, C, g), s.enableSleeping && l.afterCollisions(D.list), D.collisionStart.length > 0 && i.trigger(s, "collisionStart", { pairs: D.collisionStart, timestamp: p.timestamp, delta: c }); var P = t.clamp(20 / s.positionIterations, 0, 1); for (a.preSolvePosition(D.list), x = 0; x < s.positionIterations; x++)a.solvePosition(D.list, c, P); for (a.postSolvePosition(w), o.preSolveAll(w), x = 0; x < s.constraintIterations; x++)o.solveAll(y, c); for (o.postSolveAll(w), a.preSolveVelocity(D.list), x = 0; x < s.velocityIterations; x++)a.solveVelocity(D.list, c); return e._bodiesUpdateVelocities(w), D.collisionActive.length > 0 && i.trigger(s, "collisionActive", { pairs: D.collisionActive, timestamp: p.timestamp, delta: c }), D.collisionEnd.length > 0 && i.trigger(s, "collisionEnd", { pairs: D.collisionEnd, timestamp: p.timestamp, delta: c }), e._bodiesClearForces(w), i.trigger(s, "afterUpdate", d), s.timing.lastElapsed = t.now() - v, s }, e.merge = function (s, c) { if (t.extend(s, c), c.world) { s.world = c.world, e.clear(s); for (var v = f.allBodies(s.world), m = 0; m < v.length; m++) { var S = v[m]; l.set(S, !1), S.id = t.nextId() } } }, e.clear = function (s) { u.clear(s.pairs), r.clear(s.detector) }, e._bodiesClearForces = function (s) { for (var c = s.length, v = 0; v < c; v++) { var m = s[v]; m.force.x = 0, m.force.y = 0, m.torque = 0 } }, e._bodiesApplyGravity = function (s, c) { var v = typeof c.scale < "u" ? c.scale : .001, m = s.length; if (!(c.x === 0 && c.y === 0 || v === 0)) for (var S = 0; S < m; S++) { var D = s[S]; D.isStatic || D.isSleeping || (D.force.y += D.mass * c.y * v, D.force.x += D.mass * c.x * v) } }, e._bodiesUpdate = function (s, c) { for (var v = s.length, m = 0; m < v; m++) { var S = s[m]; S.isStatic || S.isSleeping || n.update(S, c) } }, e._bodiesUpdateVelocities = function (s) { for (var c = s.length, v = 0; v < c; v++)n.updateVelocities(s[v]) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(0), r = h(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (u) { var i, f, o, t = u.length; for (i = 0; i < t; i++)f = u[i], f.isActive && (o = f.contactCount, f.collision.parentA.totalContacts += o, f.collision.parentB.totalContacts += o) }, e.solvePosition = function (u, i, f) { var o, t, n, s, c, v, m, S, D = e._positionDampen * (f || 1), p = a.clamp(i / a._baseDelta, 0, 1), g = u.length; for (o = 0; o < g; o++)t = u[o], !(!t.isActive || t.isSensor) && (n = t.collision, s = n.parentA, c = n.parentB, v = n.normal, t.separation = n.depth + v.x * (c.positionImpulse.x - s.positionImpulse.x) + v.y * (c.positionImpulse.y - s.positionImpulse.y)); for (o = 0; o < g; o++)t = u[o], !(!t.isActive || t.isSensor) && (n = t.collision, s = n.parentA, c = n.parentB, v = n.normal, S = t.separation - t.slop * p, (s.isStatic || c.isStatic) && (S *= 2), s.isStatic || s.isSleeping || (m = D / s.totalContacts, s.positionImpulse.x += v.x * S * m, s.positionImpulse.y += v.y * S * m), c.isStatic || c.isSleeping || (m = D / c.totalContacts, c.positionImpulse.x -= v.x * S * m, c.positionImpulse.y -= v.y * S * m)) }, e.postSolvePosition = function (u) { for (var i = e._positionWarming, f = u.length, o = l.translate, t = r.update, n = 0; n < f; n++) { var s = u[n], c = s.positionImpulse, v = c.x, m = c.y, S = s.velocity; if (s.totalContacts = 0, v !== 0 || m !== 0) { for (var D = 0; D < s.parts.length; D++) { var p = s.parts[D]; o(p.vertices, c), t(p.bounds, p.vertices, S), p.position.x += v, p.position.y += m } s.positionPrev.x += v, s.positionPrev.y += m, v * S.x + m * S.y < 0 ? (c.x = 0, c.y = 0) : (c.x *= i, c.y *= i) } } }, e.preSolveVelocity = function (u) { var i = u.length, f, o; for (f = 0; f < i; f++) { var t = u[f]; if (!(!t.isActive || t.isSensor)) { var n = t.contacts, s = t.contactCount, c = t.collision, v = c.parentA, m = c.parentB, S = c.normal, D = c.tangent; for (o = 0; o < s; o++) { var p = n[o], g = p.vertex, x = p.normalImpulse, d = p.tangentImpulse; if (x !== 0 || d !== 0) { var w = S.x * x + D.x * d, y = S.y * x + D.y * d; v.isStatic || v.isSleeping || (v.positionPrev.x += w * v.inverseMass, v.positionPrev.y += y * v.inverseMass, v.anglePrev += v.inverseInertia * ((g.x - v.position.x) * y - (g.y - v.position.y) * w)), m.isStatic || m.isSleeping || (m.positionPrev.x -= w * m.inverseMass, m.positionPrev.y -= y * m.inverseMass, m.anglePrev -= m.inverseInertia * ((g.x - m.position.x) * y - (g.y - m.position.y) * w)) } } } } }, e.solveVelocity = function (u, i) { var f = i / a._baseDelta, o = f * f, t = o * f, n = -e._restingThresh * f, s = e._restingThreshTangent, c = e._frictionNormalMultiplier * f, v = e._frictionMaxStatic, m = u.length, S, D, p, g; for (p = 0; p < m; p++) { var x = u[p]; if (!(!x.isActive || x.isSensor)) { var d = x.collision, w = d.parentA, y = d.parentB, C = d.normal.x, P = d.normal.y, T = d.tangent.x, E = d.tangent.y, I = x.inverseMass, B = x.friction * x.frictionStatic * c, L = x.contacts, F = x.contactCount, W = 1 / F, b = w.position.x - w.positionPrev.x, G = w.position.y - w.positionPrev.y, $ = w.angle - w.anglePrev, q = y.position.x - y.positionPrev.x, ee = y.position.y - y.positionPrev.y, Z = y.angle - y.anglePrev; for (g = 0; g < F; g++) { var V = L[g], K = V.vertex, z = K.x - w.position.x, oe = K.y - w.position.y, X = K.x - y.position.x, Y = K.y - y.position.y, J = b - oe * $, Ne = G + z * $, Ge = q - Y * Z, $e = ee + X * Z, Pe = J - Ge, De = Ne - $e, ve = C * Pe + P * De, _ = T * Pe + E * De, Oe = x.separation + ve, ge = Math.min(Oe, 1); ge = Oe < 0 ? 0 : ge; var Ae = ge * B; _ < -Ae || _ > Ae ? (D = _ > 0 ? _ : -_, S = x.friction * (_ > 0 ? 1 : -1) * t, S < -D ? S = -D : S > D && (S = D)) : (S = _, D = v); var Te = z * P - oe * C, Ie = X * P - Y * C, Ee = W / (I + w.inverseInertia * Te * Te + y.inverseInertia * Ie * Ie), fe = (1 + x.restitution) * ve * Ee; if (S *= Ee, ve < n) V.normalImpulse = 0; else { var ze = V.normalImpulse; V.normalImpulse += fe, V.normalImpulse > 0 && (V.normalImpulse = 0), fe = V.normalImpulse - ze } if (_ < -s || _ > s) V.tangentImpulse = 0; else { var qe = V.tangentImpulse; V.tangentImpulse += S, V.tangentImpulse < -D && (V.tangentImpulse = -D), V.tangentImpulse > D && (V.tangentImpulse = D), S = V.tangentImpulse - qe } var ue = C * fe + T * S, he = P * fe + E * S; w.isStatic || w.isSleeping || (w.positionPrev.x += ue * w.inverseMass, w.positionPrev.y += he * w.inverseMass, w.anglePrev += (z * he - oe * ue) * w.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= ue * y.inverseMass, y.positionPrev.y -= he * y.inverseMass, y.anglePrev -= (X * he - Y * ue) * y.inverseInertia) } } } } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(9), a = h(0); (function () { e.create = function (r) { return a.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, r) }, e.update = function (r, u, i) { var f = l.update, o = l.create, t = l.setActive, n = r.table, s = r.list, c = s.length, v = c, m = r.collisionStart, S = r.collisionEnd, D = r.collisionActive, p = u.length, g = 0, x = 0, d = 0, w, y, C; for (C = 0; C < p; C++)w = u[C], y = w.pair, y ? (y.isActive && (D[d++] = y), f(y, w, i)) : (y = o(w, i), n[y.id] = y, m[g++] = y, s[v++] = y); for (v = 0, c = s.length, C = 0; C < c; C++)y = s[C], y.timeUpdated >= i ? s[v++] = y : (t(y, !1, i), y.collision.bodyA.sleepCounter > 0 && y.collision.bodyB.sleepCounter > 0 ? s[v++] = y : (S[x++] = y, delete n[y.id])); s.length !== v && (s.length = v), m.length !== g && (m.length = g), S.length !== x && (S.length = x), D.length !== d && (D.length = d) }, e.clear = function (r) { return r.table = {}, r.list.length = 0, r.collisionStart.length = 0, r.collisionActive.length = 0, r.collisionEnd.length = 0, r } })() }, function (M, O, h) { var e = M.exports = h(21); e.Axes = h(11), e.Bodies = h(12), e.Body = h(4), e.Bounds = h(1), e.Collision = h(8), e.Common = h(0), e.Composite = h(6), e.Composites = h(22), e.Constraint = h(10), e.Contact = h(16), e.Detector = h(13), e.Engine = h(17), e.Events = h(5), e.Grid = h(23), e.Mouse = h(14), e.MouseConstraint = h(24), e.Pair = h(9), e.Pairs = h(19), e.Plugin = h(15), e.Query = h(25), e.Render = h(26), e.Resolver = h(18), e.Runner = h(27), e.SAT = h(28), e.Sleeping = h(7), e.Svg = h(29), e.Vector = h(2), e.Vertices = h(3), e.World = h(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function (M, O, h) { var e = {}; M.exports = e; var l = h(15), a = h(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { l.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (r, u) { return r = r.replace(/^Matter./, ""), a.chainPathBefore(e, r, u) }, e.after = function (r, u) { return r = r.replace(/^Matter./, ""), a.chainPathAfter(e, r, u) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(6), a = h(10), r = h(0), u = h(4), i = h(12), f = r.deprecated; (function () { e.stack = function (o, t, n, s, c, v, m) { for (var S = l.create({ label: "Stack" }), D = o, p = t, g, x = 0, d = 0; d < s; d++) { for (var w = 0, y = 0; y < n; y++) { var C = m(D, p, y, d, g, x); if (C) { var P = C.bounds.max.y - C.bounds.min.y, T = C.bounds.max.x - C.bounds.min.x; P > w && (w = P), u.translate(C, { x: T * .5, y: P * .5 }), D = C.bounds.max.x + c, l.addBody(S, C), g = C, x += 1 } else D += c } p += w + v, D = o } return S }, e.chain = function (o, t, n, s, c, v) { for (var m = o.bodies, S = 1; S < m.length; S++) { var D = m[S - 1], p = m[S], g = D.bounds.max.y - D.bounds.min.y, x = D.bounds.max.x - D.bounds.min.x, d = p.bounds.max.y - p.bounds.min.y, w = p.bounds.max.x - p.bounds.min.x, y = { bodyA: D, pointA: { x: x * t, y: g * n }, bodyB: p, pointB: { x: w * s, y: d * c } }, C = r.extend(y, v); l.addConstraint(o, a.create(C)) } return o.label += " Chain", o }, e.mesh = function (o, t, n, s, c) { var v = o.bodies, m, S, D, p, g; for (m = 0; m < n; m++) { for (S = 1; S < t; S++)D = v[S - 1 + m * t], p = v[S + m * t], l.addConstraint(o, a.create(r.extend({ bodyA: D, bodyB: p }, c))); if (m > 0) for (S = 0; S < t; S++)D = v[S + (m - 1) * t], p = v[S + m * t], l.addConstraint(o, a.create(r.extend({ bodyA: D, bodyB: p }, c))), s && S > 0 && (g = v[S - 1 + (m - 1) * t], l.addConstraint(o, a.create(r.extend({ bodyA: g, bodyB: p }, c)))), s && S < t - 1 && (g = v[S + 1 + (m - 1) * t], l.addConstraint(o, a.create(r.extend({ bodyA: g, bodyB: p }, c)))) } return o.label += " Mesh", o }, e.pyramid = function (o, t, n, s, c, v, m) { return e.stack(o, t, n, s, c, v, function (S, D, p, g, x, d) { var w = Math.min(s, Math.ceil(n / 2)), y = x ? x.bounds.max.x - x.bounds.min.x : 0; if (!(g > w)) { g = w - g; var C = g, P = n - 1 - g; if (!(p < C || p > P)) { d === 1 && u.translate(x, { x: (p + (n % 2 === 1 ? 1 : -1)) * y, y: 0 }); var T = x ? p * y : 0; return m(o + T + p * c, D, p, g, x, d) } } }) }, e.newtonsCradle = function (o, t, n, s, c) { for (var v = l.create({ label: "Newtons Cradle" }), m = 0; m < n; m++) { var S = 1.9, D = i.circle(o + m * (s * S), t + c, s, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), p = a.create({ pointA: { x: o + m * (s * S), y: t }, bodyB: D }); l.addBody(v, D), l.addConstraint(v, p) } return v }, f(e, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), e.car = function (o, t, n, s, c) { var v = u.nextGroup(!0), m = 20, S = -n * .5 + m, D = n * .5 - m, p = 0, g = l.create({ label: "Car" }), x = i.rectangle(o, t, n, s, { collisionFilter: { group: v }, chamfer: { radius: s * .5 }, density: 2e-4 }), d = i.circle(o + S, t + p, c, { collisionFilter: { group: v }, friction: .8 }), w = i.circle(o + D, t + p, c, { collisionFilter: { group: v }, friction: .8 }), y = a.create({ bodyB: x, pointB: { x: S, y: p }, bodyA: d, stiffness: 1, length: 0 }), C = a.create({ bodyB: x, pointB: { x: D, y: p }, bodyA: w, stiffness: 1, length: 0 }); return l.addBody(g, x), l.addBody(g, d), l.addBody(g, w), l.addConstraint(g, y), l.addConstraint(g, C), g }, f(e, "car", "Composites.car ➤ moved to car example"), e.softBody = function (o, t, n, s, c, v, m, S, D, p) { D = r.extend({ inertia: 1 / 0 }, D), p = r.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, p); var g = e.stack(o, t, n, s, c, v, function (x, d) { return i.circle(x, d, S, D) }); return e.mesh(g, n, s, m, p), g.label = "Soft Body", g }, f(e, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(9), a = h(0), r = a.deprecated; (function () { e.create = function (u) { var i = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return a.extend(i, u) }, e.update = function (u, i, f, o) { var t, n, s, c = f.world, v = u.buckets, m, S, D = !1; for (t = 0; t < i.length; t++) { var p = i[t]; if (!(p.isSleeping && !o) && !(c.bounds && (p.bounds.max.x < c.bounds.min.x || p.bounds.min.x > c.bounds.max.x || p.bounds.max.y < c.bounds.min.y || p.bounds.min.y > c.bounds.max.y))) { var g = e._getRegion(u, p); if (!p.region || g.id !== p.region.id || o) { (!p.region || o) && (p.region = g); var x = e._regionUnion(g, p.region); for (n = x.startCol; n <= x.endCol; n++)for (s = x.startRow; s <= x.endRow; s++) { S = e._getBucketId(n, s), m = v[S]; var d = n >= g.startCol && n <= g.endCol && s >= g.startRow && s <= g.endRow, w = n >= p.region.startCol && n <= p.region.endCol && s >= p.region.startRow && s <= p.region.endRow; !d && w && w && m && e._bucketRemoveBody(u, m, p), (p.region === g || d && !w || o) && (m || (m = e._createBucket(v, S)), e._bucketAddBody(u, m, p)) } p.region = g, D = !0 } } } D && (u.pairsList = e._createActivePairsList(u)) }, r(e, "update", "Grid.update ➤ replaced by Matter.Detector"), e.clear = function (u) { u.buckets = {}, u.pairs = {}, u.pairsList = [] }, r(e, "clear", "Grid.clear ➤ replaced by Matter.Detector"), e._regionUnion = function (u, i) { var f = Math.min(u.startCol, i.startCol), o = Math.max(u.endCol, i.endCol), t = Math.min(u.startRow, i.startRow), n = Math.max(u.endRow, i.endRow); return e._createRegion(f, o, t, n) }, e._getRegion = function (u, i) { var f = i.bounds, o = Math.floor(f.min.x / u.bucketWidth), t = Math.floor(f.max.x / u.bucketWidth), n = Math.floor(f.min.y / u.bucketHeight), s = Math.floor(f.max.y / u.bucketHeight); return e._createRegion(o, t, n, s) }, e._createRegion = function (u, i, f, o) { return { id: u + "," + i + "," + f + "," + o, startCol: u, endCol: i, startRow: f, endRow: o } }, e._getBucketId = function (u, i) { return "C" + u + "R" + i }, e._createBucket = function (u, i) { var f = u[i] = []; return f }, e._bucketAddBody = function (u, i, f) { var o = u.pairs, t = l.id, n = i.length, s; for (s = 0; s < n; s++) { var c = i[s]; if (!(f.id === c.id || f.isStatic && c.isStatic)) { var v = t(f, c), m = o[v]; m ? m[2] += 1 : o[v] = [f, c, 1] } } i.push(f) }, e._bucketRemoveBody = function (u, i, f) { var o = u.pairs, t = l.id, n; i.splice(a.indexOf(i, f), 1); var s = i.length; for (n = 0; n < s; n++) { var c = o[t(f, i[n])]; c && (c[2] -= 1) } }, e._createActivePairsList = function (u) { var i, f = u.pairs, o = a.keys(f), t = o.length, n = [], s; for (s = 0; s < t; s++)i = f[o[s]], i[2] > 0 ? n.push(i) : delete f[o[s]]; return n } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(3), a = h(7), r = h(14), u = h(5), i = h(13), f = h(10), o = h(6), t = h(0), n = h(1); (function () { e.create = function (s, c) { var v = (s ? s.mouse : null) || (c ? c.mouse : null); v || (s && s.render && s.render.canvas ? v = r.create(s.render.canvas) : c && c.element ? v = r.create(c.element) : (v = r.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var m = f.create({ label: "Mouse Constraint", pointA: v.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), S = { type: "mouseConstraint", mouse: v, element: null, body: null, constraint: m, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, D = t.extend(S, c); return u.on(s, "beforeUpdate", function () { var p = o.allBodies(s.world); e.update(D, p), e._triggerEvents(D) }), D }, e.update = function (s, c) { var v = s.mouse, m = s.constraint, S = s.body; if (v.button === 0) { if (m.bodyB) a.set(m.bodyB, !1), m.pointA = v.position; else for (var D = 0; D < c.length; D++)if (S = c[D], n.contains(S.bounds, v.position) && i.canCollide(S.collisionFilter, s.collisionFilter)) for (var p = S.parts.length > 1 ? 1 : 0; p < S.parts.length; p++) { var g = S.parts[p]; if (l.contains(g.vertices, v.position)) { m.pointA = v.position, m.bodyB = s.body = S, m.pointB = { x: v.position.x - S.position.x, y: v.position.y - S.position.y }, m.angleB = S.angle, a.set(S, !1), u.trigger(s, "startdrag", { mouse: v, body: S }); break } } } else m.bodyB = s.body = null, m.pointB = null, S && u.trigger(s, "enddrag", { mouse: v, body: S }) }, e._triggerEvents = function (s) { var c = s.mouse, v = c.sourceEvents; v.mousemove && u.trigger(s, "mousemove", { mouse: c }), v.mousedown && u.trigger(s, "mousedown", { mouse: c }), v.mouseup && u.trigger(s, "mouseup", { mouse: c }), r.clearSourceEvents(c) } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(2), a = h(8), r = h(1), u = h(12), i = h(3); (function () { e.collides = function (f, o) { for (var t = [], n = o.length, s = f.bounds, c = a.collides, v = r.overlaps, m = 0; m < n; m++) { var S = o[m], D = S.parts.length, p = D === 1 ? 0 : 1; if (v(S.bounds, s)) for (var g = p; g < D; g++) { var x = S.parts[g]; if (v(x.bounds, s)) { var d = c(x, f); if (d) { t.push(d); break } } } } return t }, e.ray = function (f, o, t, n) { n = n || 1e-100; for (var s = l.angle(o, t), c = l.magnitude(l.sub(o, t)), v = (t.x + o.x) * .5, m = (t.y + o.y) * .5, S = u.rectangle(v, m, c, n, { angle: s }), D = e.collides(S, f), p = 0; p < D.length; p += 1) { var g = D[p]; g.body = g.bodyB = g.bodyA } return D }, e.region = function (f, o, t) { for (var n = [], s = 0; s < f.length; s++) { var c = f[s], v = r.overlaps(c.bounds, o); (v && !t || !v && t) && n.push(c) } return n }, e.point = function (f, o) { for (var t = [], n = 0; n < f.length; n++) { var s = f[n]; if (r.contains(s.bounds, o)) for (var c = s.parts.length === 1 ? 0 : 1; c < s.parts.length; c++) { var v = s.parts[c]; if (r.contains(v.bounds, o) && i.contains(v.vertices, o)) { t.push(s); break } } } return t } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(4), a = h(0), r = h(6), u = h(1), i = h(5), f = h(2), o = h(14); (function () { var t, n; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (p) { window.setTimeout(function () { p(a.now()) }, 1e3 / 60) }, n = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (p) { var g = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!p.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, x = a.extend(g, p); return x.canvas && (x.canvas.width = x.options.width || x.canvas.width, x.canvas.height = x.options.height || x.canvas.height), x.mouse = p.mouse, x.engine = p.engine, x.canvas = x.canvas || v(x.options.width, x.options.height), x.context = x.canvas.getContext("2d"), x.textures = {}, x.bounds = x.bounds || { min: { x: 0, y: 0 }, max: { x: x.canvas.width, y: x.canvas.height } }, x.controller = e, x.options.showBroadphase = !1, x.options.pixelRatio !== 1 && e.setPixelRatio(x, x.options.pixelRatio), a.isElement(x.element) && x.element.appendChild(x.canvas), x }, e.run = function (p) { (function g(x) { p.frameRequestId = t(g), s(p, x), e.world(p, x), p.context.setTransform(p.options.pixelRatio, 0, 0, p.options.pixelRatio, 0, 0), (p.options.showStats || p.options.showDebug) && e.stats(p, p.context, x), (p.options.showPerformance || p.options.showDebug) && e.performance(p, p.context, x), p.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (p) { n(p.frameRequestId) }, e.setPixelRatio = function (p, g) { var x = p.options, d = p.canvas; g === "auto" && (g = m(d)), x.pixelRatio = g, d.setAttribute("data-pixel-ratio", g), d.width = x.width * g, d.height = x.height * g, d.style.width = x.width + "px", d.style.height = x.height + "px" }, e.setSize = function (p, g, x) { p.options.width = g, p.options.height = x, p.bounds.max.x = p.bounds.min.x + g, p.bounds.max.y = p.bounds.min.y + x, p.options.pixelRatio !== 1 ? e.setPixelRatio(p, p.options.pixelRatio) : (p.canvas.width = g, p.canvas.height = x) }, e.lookAt = function (p, g, x, d) { d = typeof d < "u" ? d : !0, g = a.isArray(g) ? g : [g], x = x || { x: 0, y: 0 }; for (var w = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, y = 0; y < g.length; y += 1) { var C = g[y], P = C.bounds ? C.bounds.min : C.min || C.position || C, T = C.bounds ? C.bounds.max : C.max || C.position || C; P && T && (P.x < w.min.x && (w.min.x = P.x), T.x > w.max.x && (w.max.x = T.x), P.y < w.min.y && (w.min.y = P.y), T.y > w.max.y && (w.max.y = T.y)) } var E = w.max.x - w.min.x + 2 * x.x, I = w.max.y - w.min.y + 2 * x.y, B = p.canvas.height, L = p.canvas.width, F = L / B, W = E / I, b = 1, G = 1; W > F ? G = W / F : b = F / W, p.options.hasBounds = !0, p.bounds.min.x = w.min.x, p.bounds.max.x = w.min.x + E * b, p.bounds.min.y = w.min.y, p.bounds.max.y = w.min.y + I * G, d && (p.bounds.min.x += E * .5 - E * b * .5, p.bounds.max.x += E * .5 - E * b * .5, p.bounds.min.y += I * .5 - I * G * .5, p.bounds.max.y += I * .5 - I * G * .5), p.bounds.min.x -= x.x, p.bounds.max.x -= x.x, p.bounds.min.y -= x.y, p.bounds.max.y -= x.y, p.mouse && (o.setScale(p.mouse, { x: (p.bounds.max.x - p.bounds.min.x) / p.canvas.width, y: (p.bounds.max.y - p.bounds.min.y) / p.canvas.height }), o.setOffset(p.mouse, p.bounds.min)) }, e.startViewTransform = function (p) { var g = p.bounds.max.x - p.bounds.min.x, x = p.bounds.max.y - p.bounds.min.y, d = g / p.options.width, w = x / p.options.height; p.context.setTransform(p.options.pixelRatio / d, 0, 0, p.options.pixelRatio / w, 0, 0), p.context.translate(-p.bounds.min.x, -p.bounds.min.y) }, e.endViewTransform = function (p) { p.context.setTransform(p.options.pixelRatio, 0, 0, p.options.pixelRatio, 0, 0) }, e.world = function (p, g) { var x = a.now(), d = p.engine, w = d.world, y = p.canvas, C = p.context, P = p.options, T = p.timing, E = r.allBodies(w), I = r.allConstraints(w), B = P.wireframes ? P.wireframeBackground : P.background, L = [], F = [], W, b = { timestamp: d.timing.timestamp }; if (i.trigger(p, "beforeRender", b), p.currentBackground !== B && D(p, B), C.globalCompositeOperation = "source-in", C.fillStyle = "transparent", C.fillRect(0, 0, y.width, y.height), C.globalCompositeOperation = "source-over", P.hasBounds) { for (W = 0; W < E.length; W++) { var G = E[W]; u.overlaps(G.bounds, p.bounds) && L.push(G) } for (W = 0; W < I.length; W++) { var $ = I[W], q = $.bodyA, ee = $.bodyB, Z = $.pointA, V = $.pointB; q && (Z = f.add(q.position, $.pointA)), ee && (V = f.add(ee.position, $.pointB)), !(!Z || !V) && (u.contains(p.bounds, Z) || u.contains(p.bounds, V)) && F.push($) } e.startViewTransform(p), p.mouse && (o.setScale(p.mouse, { x: (p.bounds.max.x - p.bounds.min.x) / p.options.width, y: (p.bounds.max.y - p.bounds.min.y) / p.options.height }), o.setOffset(p.mouse, p.bounds.min)) } else F = I, L = E, p.options.pixelRatio !== 1 && p.context.setTransform(p.options.pixelRatio, 0, 0, p.options.pixelRatio, 0, 0); !P.wireframes || d.enableSleeping && P.showSleeping ? e.bodies(p, L, C) : (P.showConvexHulls && e.bodyConvexHulls(p, L, C), e.bodyWireframes(p, L, C)), P.showBounds && e.bodyBounds(p, L, C), (P.showAxes || P.showAngleIndicator) && e.bodyAxes(p, L, C), P.showPositions && e.bodyPositions(p, L, C), P.showVelocity && e.bodyVelocity(p, L, C), P.showIds && e.bodyIds(p, L, C), P.showSeparations && e.separations(p, d.pairs.list, C), P.showCollisions && e.collisions(p, d.pairs.list, C), P.showVertexNumbers && e.vertexNumbers(p, L, C), P.showMousePosition && e.mousePosition(p, p.mouse, C), e.constraints(F, C), P.hasBounds && e.endViewTransform(p), i.trigger(p, "afterRender", b), T.lastElapsed = a.now() - x }, e.stats = function (p, g, x) { for (var d = p.engine, w = d.world, y = r.allBodies(w), C = 0, P = 55, T = 44, E = 0, I = 0, B = 0; B < y.length; B += 1)C += y[B].parts.length; var L = { Part: C, Body: y.length, Cons: r.allConstraints(w).length, Comp: r.allComposites(w).length, Pair: d.pairs.list.length }; g.fillStyle = "#0e0f19", g.fillRect(E, I, P * 5.5, T), g.font = "12px Arial", g.textBaseline = "top", g.textAlign = "right"; for (var F in L) { var W = L[F]; g.fillStyle = "#aaa", g.fillText(F, E + P, I + 8), g.fillStyle = "#eee", g.fillText(W, E + P, I + 26), E += P } }, e.performance = function (p, g) { var x = p.engine, d = p.timing, w = d.deltaHistory, y = d.elapsedHistory, C = d.timestampElapsedHistory, P = d.engineDeltaHistory, T = d.engineUpdatesHistory, E = d.engineElapsedHistory, I = x.timing.lastUpdatesPerFrame, B = x.timing.lastDelta, L = c(w), F = c(y), W = c(P), b = c(T), G = c(E), $ = c(C), q = $ / L || 0, ee = Math.round(L / B), Z = 1e3 / L || 0, V = 4, K = 12, z = 60, oe = 34, X = 10, Y = 69; g.fillStyle = "#0e0f19", g.fillRect(0, 50, K * 5 + z * 6 + 22, oe), e.status(g, X, Y, z, V, w.length, Math.round(Z) + " fps", Z / e._goodFps, function (J) { return w[J] / L - 1 }), e.status(g, X + K + z, Y, z, V, P.length, B.toFixed(2) + " dt", e._goodDelta / B, function (J) { return P[J] / W - 1 }), e.status(g, X + (K + z) * 2, Y, z, V, T.length, I + " upf", Math.pow(a.clamp(b / ee || 1, 0, 1), 4), function (J) { return T[J] / b - 1 }), e.status(g, X + (K + z) * 3, Y, z, V, E.length, G.toFixed(2) + " ut", 1 - I * G / e._goodFps, function (J) { return E[J] / G - 1 }), e.status(g, X + (K + z) * 4, Y, z, V, y.length, F.toFixed(2) + " rt", 1 - F / e._goodFps, function (J) { return y[J] / F - 1 }), e.status(g, X + (K + z) * 5, Y, z, V, C.length, q.toFixed(2) + " x", q * q * q, function (J) { return (C[J] / w[J] / q || 0) - 1 }) }, e.status = function (p, g, x, d, w, y, C, P, T) { p.strokeStyle = "#888", p.fillStyle = "#444", p.lineWidth = 1, p.fillRect(g, x + 7, d, 1), p.beginPath(), p.moveTo(g, x + 7 - w * a.clamp(.4 * T(0), -2, 2)); for (var E = 0; E < d; E += 1)p.lineTo(g + E, x + 7 - (E < y ? w * a.clamp(.4 * T(E), -2, 2) : 0)); p.stroke(), p.fillStyle = "hsl(" + a.clamp(25 + 95 * P, 0, 120) + ",100%,60%)", p.fillRect(g, x - 7, 4, 4), p.font = "12px Arial", p.textBaseline = "middle", p.textAlign = "right", p.fillStyle = "#eee", p.fillText(C, g + d, x - 5) }, e.constraints = function (p, g) { for (var x = g, d = 0; d < p.length; d++) { var w = p[d]; if (!(!w.render.visible || !w.pointA || !w.pointB)) { var y = w.bodyA, C = w.bodyB, P, T; if (y ? P = f.add(y.position, w.pointA) : P = w.pointA, w.render.type === "pin") x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.closePath(); else { if (C ? T = f.add(C.position, w.pointB) : T = w.pointB, x.beginPath(), x.moveTo(P.x, P.y), w.render.type === "spring") for (var E = f.sub(T, P), I = f.perp(f.normalise(E)), B = Math.ceil(a.clamp(w.length / 5, 12, 20)), L, F = 1; F < B; F += 1)L = F % 2 === 0 ? 1 : -1, x.lineTo(P.x + E.x * (F / B) + I.x * L * 4, P.y + E.y * (F / B) + I.y * L * 4); x.lineTo(T.x, T.y) } w.render.lineWidth && (x.lineWidth = w.render.lineWidth, x.strokeStyle = w.render.strokeStyle, x.stroke()), w.render.anchors && (x.fillStyle = w.render.strokeStyle, x.beginPath(), x.arc(P.x, P.y, 3, 0, 2 * Math.PI), x.arc(T.x, T.y, 3, 0, 2 * Math.PI), x.closePath(), x.fill()) } } }, e.bodies = function (p, g, x) { var d = x; p.engine; var w = p.options, y = w.showInternalEdges || !w.wireframes, C, P, T, E; for (T = 0; T < g.length; T++)if (C = g[T], !!C.render.visible) { for (E = C.parts.length > 1 ? 1 : 0; E < C.parts.length; E++)if (P = C.parts[E], !!P.render.visible) { if (w.showSleeping && C.isSleeping ? d.globalAlpha = .5 * P.render.opacity : P.render.opacity !== 1 && (d.globalAlpha = P.render.opacity), P.render.sprite && P.render.sprite.texture && !w.wireframes) { var I = P.render.sprite, B = S(p, I.texture); d.translate(P.position.x, P.position.y), d.rotate(P.angle), d.drawImage(B, B.width * -I.xOffset * I.xScale, B.height * -I.yOffset * I.yScale, B.width * I.xScale, B.height * I.yScale), d.rotate(-P.angle), d.translate(-P.position.x, -P.position.y) } else { if (P.circleRadius) d.beginPath(), d.arc(P.position.x, P.position.y, P.circleRadius, 0, 2 * Math.PI); else { d.beginPath(), d.moveTo(P.vertices[0].x, P.vertices[0].y); for (var L = 1; L < P.vertices.length; L++)!P.vertices[L - 1].isInternal || y ? d.lineTo(P.vertices[L].x, P.vertices[L].y) : d.moveTo(P.vertices[L].x, P.vertices[L].y), P.vertices[L].isInternal && !y && d.moveTo(P.vertices[(L + 1) % P.vertices.length].x, P.vertices[(L + 1) % P.vertices.length].y); d.lineTo(P.vertices[0].x, P.vertices[0].y), d.closePath() } w.wireframes ? (d.lineWidth = 1, d.strokeStyle = p.options.wireframeStrokeStyle, d.stroke()) : (d.fillStyle = P.render.fillStyle, P.render.lineWidth && (d.lineWidth = P.render.lineWidth, d.strokeStyle = P.render.strokeStyle, d.stroke()), d.fill()) } d.globalAlpha = 1 } } }, e.bodyWireframes = function (p, g, x) { var d = x, w = p.options.showInternalEdges, y, C, P, T, E; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (E = y.parts.length > 1 ? 1 : 0; E < y.parts.length; E++) { for (C = y.parts[E], d.moveTo(C.vertices[0].x, C.vertices[0].y), T = 1; T < C.vertices.length; T++)!C.vertices[T - 1].isInternal || w ? d.lineTo(C.vertices[T].x, C.vertices[T].y) : d.moveTo(C.vertices[T].x, C.vertices[T].y), C.vertices[T].isInternal && !w && d.moveTo(C.vertices[(T + 1) % C.vertices.length].x, C.vertices[(T + 1) % C.vertices.length].y); d.lineTo(C.vertices[0].x, C.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = p.options.wireframeStrokeStyle, d.stroke() }, e.bodyConvexHulls = function (p, g, x) { var d = x, w, y, C; for (d.beginPath(), y = 0; y < g.length; y++)if (w = g[y], !(!w.render.visible || w.parts.length === 1)) { for (d.moveTo(w.vertices[0].x, w.vertices[0].y), C = 1; C < w.vertices.length; C++)d.lineTo(w.vertices[C].x, w.vertices[C].y); d.lineTo(w.vertices[0].x, w.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = "rgba(255,255,255,0.2)", d.stroke() }, e.vertexNumbers = function (p, g, x) { var d = x, w, y, C; for (w = 0; w < g.length; w++) { var P = g[w].parts; for (C = P.length > 1 ? 1 : 0; C < P.length; C++) { var T = P[C]; for (y = 0; y < T.vertices.length; y++)d.fillStyle = "rgba(255,255,255,0.2)", d.fillText(w + "_" + y, T.position.x + (T.vertices[y].x - T.position.x) * .8, T.position.y + (T.vertices[y].y - T.position.y) * .8) } } }, e.mousePosition = function (p, g, x) { var d = x; d.fillStyle = "rgba(255,255,255,0.8)", d.fillText(g.position.x + "  " + g.position.y, g.position.x + 5, g.position.y - 5) }, e.bodyBounds = function (p, g, x) { var d = x; p.engine; var w = p.options; d.beginPath(); for (var y = 0; y < g.length; y++) { var C = g[y]; if (C.render.visible) for (var P = g[y].parts, T = P.length > 1 ? 1 : 0; T < P.length; T++) { var E = P[T]; d.rect(E.bounds.min.x, E.bounds.min.y, E.bounds.max.x - E.bounds.min.x, E.bounds.max.y - E.bounds.min.y) } } w.wireframes ? d.strokeStyle = "rgba(255,255,255,0.08)" : d.strokeStyle = "rgba(0,0,0,0.1)", d.lineWidth = 1, d.stroke() }, e.bodyAxes = function (p, g, x) { var d = x; p.engine; var w = p.options, y, C, P, T; for (d.beginPath(), C = 0; C < g.length; C++) { var E = g[C], I = E.parts; if (E.render.visible) if (w.showAxes) for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (y = I[P], T = 0; T < y.axes.length; T++) { var B = y.axes[T]; d.moveTo(y.position.x, y.position.y), d.lineTo(y.position.x + B.x * 20, y.position.y + B.y * 20) } else for (P = I.length > 1 ? 1 : 0; P < I.length; P++)for (y = I[P], T = 0; T < y.axes.length; T++)d.moveTo(y.position.x, y.position.y), d.lineTo((y.vertices[0].x + y.vertices[y.vertices.length - 1].x) / 2, (y.vertices[0].y + y.vertices[y.vertices.length - 1].y) / 2) } w.wireframes ? (d.strokeStyle = "indianred", d.lineWidth = 1) : (d.strokeStyle = "rgba(255, 255, 255, 0.4)", d.globalCompositeOperation = "overlay", d.lineWidth = 2), d.stroke(), d.globalCompositeOperation = "source-over" }, e.bodyPositions = function (p, g, x) { var d = x; p.engine; var w = p.options, y, C, P, T; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.render.visible) for (T = 0; T < y.parts.length; T++)C = y.parts[T], d.arc(C.position.x, C.position.y, 3, 0, 2 * Math.PI, !1), d.closePath(); for (w.wireframes ? d.fillStyle = "indianred" : d.fillStyle = "rgba(0,0,0,0.5)", d.fill(), d.beginPath(), P = 0; P < g.length; P++)y = g[P], y.render.visible && (d.arc(y.positionPrev.x, y.positionPrev.y, 2, 0, 2 * Math.PI, !1), d.closePath()); d.fillStyle = "rgba(255,165,0,0.8)", d.fill() }, e.bodyVelocity = function (p, g, x) { var d = x; d.beginPath(); for (var w = 0; w < g.length; w++) { var y = g[w]; if (y.render.visible) { var C = l.getVelocity(y); d.moveTo(y.position.x, y.position.y), d.lineTo(y.position.x + C.x, y.position.y + C.y) } } d.lineWidth = 3, d.strokeStyle = "cornflowerblue", d.stroke() }, e.bodyIds = function (p, g, x) { var d = x, w, y; for (w = 0; w < g.length; w++)if (g[w].render.visible) { var C = g[w].parts; for (y = C.length > 1 ? 1 : 0; y < C.length; y++) { var P = C[y]; d.font = "12px Arial", d.fillStyle = "rgba(255,255,255,0.5)", d.fillText(P.id, P.position.x + 10, P.position.y - 10) } } }, e.collisions = function (p, g, x) { var d = x, w = p.options, y, C, P, T; for (d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive) for (C = y.collision, T = 0; T < y.contactCount; T++) { var E = y.contacts[T], I = E.vertex; d.rect(I.x - 1.5, I.y - 1.5, 3.5, 3.5) } for (w.wireframes ? d.fillStyle = "rgba(255,255,255,0.7)" : d.fillStyle = "orange", d.fill(), d.beginPath(), P = 0; P < g.length; P++)if (y = g[P], !!y.isActive && (C = y.collision, y.contactCount > 0)) { var B = y.contacts[0].vertex.x, L = y.contacts[0].vertex.y; y.contactCount === 2 && (B = (y.contacts[0].vertex.x + y.contacts[1].vertex.x) / 2, L = (y.contacts[0].vertex.y + y.contacts[1].vertex.y) / 2), C.bodyB === C.supports[0].body || C.bodyA.isStatic === !0 ? d.moveTo(B - C.normal.x * 8, L - C.normal.y * 8) : d.moveTo(B + C.normal.x * 8, L + C.normal.y * 8), d.lineTo(B, L) } w.wireframes ? d.strokeStyle = "rgba(255,165,0,0.7)" : d.strokeStyle = "orange", d.lineWidth = 1, d.stroke() }, e.separations = function (p, g, x) { var d = x, w = p.options, y, C, P, T, E; for (d.beginPath(), E = 0; E < g.length; E++)if (y = g[E], !!y.isActive) { C = y.collision, P = C.bodyA, T = C.bodyB; var I = 1; !T.isStatic && !P.isStatic && (I = .5), T.isStatic && (I = 0), d.moveTo(T.position.x, T.position.y), d.lineTo(T.position.x - C.penetration.x * I, T.position.y - C.penetration.y * I), I = 1, !T.isStatic && !P.isStatic && (I = .5), P.isStatic && (I = 0), d.moveTo(P.position.x, P.position.y), d.lineTo(P.position.x + C.penetration.x * I, P.position.y + C.penetration.y * I) } w.wireframes ? d.strokeStyle = "rgba(255,165,0,0.5)" : d.strokeStyle = "orange", d.stroke() }, e.inspector = function (p, g) { p.engine; var x = p.selected, d = p.render, w = d.options, y; if (w.hasBounds) { var C = d.bounds.max.x - d.bounds.min.x, P = d.bounds.max.y - d.bounds.min.y, T = C / d.options.width, E = P / d.options.height; g.scale(1 / T, 1 / E), g.translate(-d.bounds.min.x, -d.bounds.min.y) } for (var I = 0; I < x.length; I++) { var B = x[I].data; switch (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.9)", g.setLineDash([1, 2]), B.type) { case "body": y = B.bounds, g.beginPath(), g.rect(Math.floor(y.min.x - 3), Math.floor(y.min.y - 3), Math.floor(y.max.x - y.min.x + 6), Math.floor(y.max.y - y.min.y + 6)), g.closePath(), g.stroke(); break; case "constraint": var L = B.pointA; B.bodyA && (L = B.pointB), g.beginPath(), g.arc(L.x, L.y, 10, 0, 2 * Math.PI), g.closePath(), g.stroke(); break }g.setLineDash([]), g.translate(-.5, -.5) } p.selectStart !== null && (g.translate(.5, .5), g.lineWidth = 1, g.strokeStyle = "rgba(255,165,0,0.6)", g.fillStyle = "rgba(255,165,0,0.1)", y = p.selectBounds, g.beginPath(), g.rect(Math.floor(y.min.x), Math.floor(y.min.y), Math.floor(y.max.x - y.min.x), Math.floor(y.max.y - y.min.y)), g.closePath(), g.stroke(), g.fill(), g.translate(-.5, -.5)), w.hasBounds && g.setTransform(1, 0, 0, 1, 0, 0) }; var s = function (p, g) { var x = p.engine, d = p.timing, w = d.historySize, y = x.timing.timestamp; d.delta = g - d.lastTime || e._goodDelta, d.lastTime = g, d.timestampElapsed = y - d.lastTimestamp || 0, d.lastTimestamp = y, d.deltaHistory.unshift(d.delta), d.deltaHistory.length = Math.min(d.deltaHistory.length, w), d.engineDeltaHistory.unshift(x.timing.lastDelta), d.engineDeltaHistory.length = Math.min(d.engineDeltaHistory.length, w), d.timestampElapsedHistory.unshift(d.timestampElapsed), d.timestampElapsedHistory.length = Math.min(d.timestampElapsedHistory.length, w), d.engineUpdatesHistory.unshift(x.timing.lastUpdatesPerFrame), d.engineUpdatesHistory.length = Math.min(d.engineUpdatesHistory.length, w), d.engineElapsedHistory.unshift(x.timing.lastElapsed), d.engineElapsedHistory.length = Math.min(d.engineElapsedHistory.length, w), d.elapsedHistory.unshift(d.lastElapsed), d.elapsedHistory.length = Math.min(d.elapsedHistory.length, w) }, c = function (p) { for (var g = 0, x = 0; x < p.length; x += 1)g += p[x]; return g / p.length || 0 }, v = function (p, g) { var x = document.createElement("canvas"); return x.width = p, x.height = g, x.oncontextmenu = function () { return !1 }, x.onselectstart = function () { return !1 }, x }, m = function (p) { var g = p.getContext("2d"), x = window.devicePixelRatio || 1, d = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1; return x / d }, S = function (p, g) { var x = p.textures[g]; return x || (x = p.textures[g] = new Image, x.src = g, x) }, D = function (p, g) { var x = g; /(jpg|gif|png)$/.test(g) && (x = "url(" + g + ")"), p.canvas.style.background = x, p.canvas.style.backgroundSize = "contain", p.currentBackground = g } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(5), a = h(17), r = h(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (i) { var f = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, o = r.extend(f, i); return o.fps = 0, o }, e.run = function (i, f) { return i.timeBuffer = e._frameDeltaFallback, function o(t) { i.frameRequestId = e._onNextFrame(i, o), t && i.enabled && e.tick(i, f, t) }(), i }, e.tick = function (i, f, o) { var t = r.now(), n = i.delta, s = 0, c = o - i.timeLastTick; if ((!c || !i.timeLastTick || c > Math.max(e._maxFrameDelta, i.maxFrameTime)) && (c = i.frameDelta || e._frameDeltaFallback), i.frameDeltaSmoothing) { i.frameDeltaHistory.push(c), i.frameDeltaHistory = i.frameDeltaHistory.slice(-i.frameDeltaHistorySize); var v = i.frameDeltaHistory.slice(0).sort(), m = i.frameDeltaHistory.slice(v.length * e._smoothingLowerBound, v.length * e._smoothingUpperBound), S = u(m); c = S || c } i.frameDeltaSnapping && (c = 1e3 / Math.round(1e3 / c)), i.frameDelta = c, i.timeLastTick = o, i.timeBuffer += i.frameDelta, i.timeBuffer = r.clamp(i.timeBuffer, 0, i.frameDelta + n * e._timeBufferMargin), i.lastUpdatesDeferred = 0; var D = i.maxUpdates || Math.ceil(i.maxFrameTime / n), p = { timestamp: f.timing.timestamp }; l.trigger(i, "beforeTick", p), l.trigger(i, "tick", p); for (var g = r.now(); n > 0 && i.timeBuffer >= n * e._timeBufferMargin;) { l.trigger(i, "beforeUpdate", p), a.update(f, n), l.trigger(i, "afterUpdate", p), i.timeBuffer -= n, s += 1; var x = r.now() - t, d = r.now() - g, w = x + e._elapsedNextEstimate * d / s; if (s >= D || w > i.maxFrameTime) { i.lastUpdatesDeferred = Math.round(Math.max(0, i.timeBuffer / n - e._timeBufferMargin)); break } } f.timing.lastUpdatesPerFrame = s, l.trigger(i, "afterTick", p), i.frameDeltaHistory.length >= 100 && (i.lastUpdatesDeferred && Math.round(i.frameDelta / n) > D ? r.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : i.lastUpdatesDeferred && r.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof i.isFixed < "u" && r.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (i.deltaMin || i.deltaMax) && r.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), i.fps !== 0 && r.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (i) { e._cancelNextFrame(i) }, e._onNextFrame = function (i, f) { if (typeof window < "u" && window.requestAnimationFrame) i.frameRequestId = window.requestAnimationFrame(f); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return i.frameRequestId }, e._cancelNextFrame = function (i) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(i.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var u = function (i) { for (var f = 0, o = i.length, t = 0; t < o; t += 1)f += i[t]; return f / o || 0 } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(8), a = h(0), r = a.deprecated; (function () { e.collides = function (u, i) { return l.collides(u, i) }, r(e, "collides", "SAT.collides ➤ replaced by Collision.collides") })() }, function (M, O, h) { var e = {}; M.exports = e, h(1); var l = h(0); (function () { e.pathToVertices = function (a, r) { typeof window < "u" && !("SVGPathSeg" in window) && l.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var u, i, f, o, t, n, s, c, v, m, S = [], D, p, g = 0, x = 0, d = 0; r = r || 15; var w = function (C, P, T) { var E = T % 2 === 1 && T > 1; if (!v || C != v.x || P != v.y) { v && E ? (D = v.x, p = v.y) : (D = 0, p = 0); var I = { x: D + C, y: p + P }; (E || !v) && (v = I), S.push(I), x = D + C, d = p + P } }, y = function (C) { var P = C.pathSegTypeAsLetter.toUpperCase(); if (P !== "Z") { switch (P) { case "M": case "L": case "T": case "C": case "S": case "Q": x = C.x, d = C.y; break; case "H": x = C.x; break; case "V": d = C.y; break }w(x, d, C.pathSegType) } }; for (e._svgPathToAbsolute(a), f = a.getTotalLength(), n = [], u = 0; u < a.pathSegList.numberOfItems; u += 1)n.push(a.pathSegList.getItem(u)); for (s = n.concat(); g < f;) { if (m = a.getPathSegAtLength(g), t = n[m], t != c) { for (; s.length && s[0] != t;)y(s.shift()); c = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": o = a.getPointAtLength(g), w(o.x, o.y, 0); break }g += r } for (u = 0, i = s.length; u < i; ++u)y(s[u]); return S }, e._svgPathToAbsolute = function (a) { for (var r, u, i, f, o, t, n = a.pathSegList, s = 0, c = 0, v = n.numberOfItems, m = 0; m < v; ++m) { var S = n.getItem(m), D = S.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(D)) "x" in S && (s = S.x), "y" in S && (c = S.y); else switch ("x1" in S && (i = s + S.x1), "x2" in S && (o = s + S.x2), "y1" in S && (f = c + S.y1), "y2" in S && (t = c + S.y2), "x" in S && (s += S.x), "y" in S && (c += S.y), D) { case "m": n.replaceItem(a.createSVGPathSegMovetoAbs(s, c), m); break; case "l": n.replaceItem(a.createSVGPathSegLinetoAbs(s, c), m); break; case "h": n.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(s), m); break; case "v": n.replaceItem(a.createSVGPathSegLinetoVerticalAbs(c), m); break; case "c": n.replaceItem(a.createSVGPathSegCurvetoCubicAbs(s, c, i, f, o, t), m); break; case "s": n.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(s, c, o, t), m); break; case "q": n.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(s, c, i, f), m); break; case "t": n.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(s, c), m); break; case "a": n.replaceItem(a.createSVGPathSegArcAbs(s, c, S.r1, S.r2, S.angle, S.largeArcFlag, S.sweepFlag), m); break; case "z": case "Z": s = r, c = u; break }(D == "M" || D == "m") && (r = s, u = c) } } })() }, function (M, O, h) { var e = {}; M.exports = e; var l = h(6); h(0), function () { e.create = l.create, e.add = l.add, e.remove = l.remove, e.clear = l.clear, e.addComposite = l.addComposite, e.addBody = l.addBody, e.addConstraint = l.addConstraint }() }]) }) })(Mt); const j = rt(te); class wt { constructor(A) { R(this, "widthCanvas", document.body.clientWidth); R(this, "heightCanvas"); R(this, "DOM"); R(this, "dataImgs", []); R(this, "MatterJS"); R(this, "sizeCustom"); this.DOM = { el: A }, this.MatterJS = { Engine: void 0, Render: void 0 }, this.sizeCustom = { mobile: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 171 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(17) }, tablet: { radius: N(5), scaleRatio: N(5) / 133, scaleCircleMain: 190 / 50, xLeftWall: 0 - N(9), xRightWall: window.innerWidth + N(9), yMainCircle: N(72.2) + N(19) }, desktop: { radius: N(13.3), scaleRatio: N(13.3) / 133, scaleCircleMain: 293 / 133, xLeftWall: 0, xRightWall: window.innerWidth, yMainCircle: N(51.2) + N(29.3) } }, this.heightCanvas = this.DOM.el.clientHeight, A == null || A.querySelectorAll(".home-bubble-item").forEach(M => { var h; const O = (h = M.querySelector("img")) == null ? void 0 : h.getAttribute("src"); O && this.dataImgs.push(O), M.style.pointerEvents = "none", M.style.opacity = "0" }) } render() { var h, e, l, a; this.init(); const A = j.Runner.create(), M = (e = (h = this.MatterJS).Engine) == null ? void 0 : e.call(h), O = (a = (l = this.MatterJS).Render) == null ? void 0 : a.call(l); ae.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !M || !O || (j.Render.run(O), j.Runner.run(A, M)) } }) } init() { const A = this.sizeCustom[se].radius, M = this.sizeCustom[se].scaleRatio, O = this.sizeCustom[se].scaleCircleMain, h = this.sizeCustom[se].xLeftWall, e = this.sizeCustom[se].xRightWall, l = this.sizeCustom[se].yMainCircle, a = j.Engine.create(), r = j.Render.create({ element: this.DOM.el, engine: a, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), u = Math.floor(window.innerWidth / (A * 2)), f = (window.innerWidth - u * A * 2) / (u - 1); let o = 0; for (let S = 0; S < Math.round(this.dataImgs.length / u) && this.dataImgs[o]; S++) { for (let D = 0; D < u && this.dataImgs[o]; D++) { const p = D * A * 2 + f * D, g = -S * A * 2 - A * 2 - f * S, x = te.Bodies.circle(p, g, A, { friction: .001, frictionAir: .01, restitution: .8, timeScale: 1.05, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[o], xScale: M, yScale: M } } }); if (o++, j.Composite.add(a.world, x), o >= this.dataImgs.length) break } if (o >= this.dataImgs.length) break } const t = te.Bodies.circle(this.DOM.el.clientWidth / 2, l, A * O, { render: { fillStyle: "transparent" }, isStatic: !0 }), n = te.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight, this.DOM.el.clientWidth * 10, 1, { isStatic: !0, render: { fillStyle: "transparent" } }), s = te.Bodies.rectangle(h, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }), c = te.Bodies.rectangle(e, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }); j.Composite.add(a.world, [n, s, c, t]); const v = j.Mouse.create(r.canvas), m = j.MouseConstraint.create(a, { mouse: v, constraint: { stiffness: .2, render: { visible: !1 } } }); j.Composite.add(a.world, m), m.mouse.element.removeEventListener("touchstart", m.mouse.mousedown), m.mouse.element.removeEventListener("touchmove", m.mouse.mousemove), m.mouse.element.removeEventListener("touchend", m.mouse.mouseup), m.mouse.element.addEventListener("touchstart", m.mouse.mousedown, { passive: !0 }), m.mouse.element.addEventListener("touchmove", S => { m.body && m.mouse.mousemove(S) }), m.mouse.element.addEventListener("touchend", S => { m.body && m.mouse.mouseup(S) }), this.MatterJS.Render = () => r, this.MatterJS.Engine = () => a } } class Ct { constructor(A) { R(this, "DOM"); this.DOM = { el: A }, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(de, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelectorAll(".home-hero-brands-wrap"), M = this.DOM.el.querySelector(".home-bubble"), O = this.DOM.el.querySelector(".home-book-img-inner"); A.length && A.forEach(h => { new Se({ wrap: h, listSplide: h.querySelectorAll(".home-hero-brands") }) }), new St(this.DOM.el), M && new wt(M).render(), O && new Ce({ el: O, offset: 30, direction: -1 }), this.heroVideoAction(), this.handleParallaxTitle(), this.initMotion() } clear() { this.initParticles() } initMotion() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.countText(this.DOM.el), Q.fadeWrap(this.DOM.el) } heroVideoAction() { const A = this.DOM.el.querySelector(".home-hero-img-btn"), M = this.DOM.el.querySelector(".home-hero-poup-video"), O = this.DOM.el.querySelector(".home-hero--poup-ic"), h = this.DOM.el.querySelector(".home-hero-poup-video-content"); A.addEventListener("click", () => { M.classList.add("is-show") }), O.addEventListener("click", () => e()), at({ element: h, action: () => e() }); const e = () => { M.classList.remove("is-show") } } handleParallaxTitle() { const A = this.DOM.el.querySelector(".home-feature-top-inner"), M = this.DOM.el.querySelector(".home-bubble"); if (!A || !M) return; const O = H.fromTo(A, { y: A.clientHeight / 2 }, { y: `-${window.innerHeight / 2 - A.clientHeight / 2}px`, ease: "none", duration: 3 }); ae.create({ trigger: M, start: () => "bottom bottom", end: "bottom top", animation: O, scrub: !0 }) } } class Pt { constructor(A) { R(this, "DOM"); R(this, "pricing"); R(this, "pricingBase"); R(this, "pricingAgent"); R(this, "planCurrent"); R(this, "planOptions", { month: { planUser: 35, basePrice: 75, valSaleUp: 0, type: "month" }, year: { planUser: 35, basePrice: 75, valSaleUp: 10, type: "year" } }); this.DOM = { el: A }, this.planCurrent = this.planOptions.month, U.emit(re), this.initParticles = this.initParticles.bind(this), U.on(de, this.initParticles), ie(this.clear.bind(this)) } initParticles() { const A = this.DOM.el.querySelector(".home-book-img-inner"); A && new Ce({ el: A, offset: 30, direction: -1 }); const M = this.DOM.el.querySelectorAll(".pricing-testimonials-brands"); M.length && M.forEach(O => { new Se({ wrap: O, listSplide: this.DOM.el.querySelectorAll(".pricing-testimonials-brands") }) }), new Se({ wrap: this.DOM.el.querySelector(".book-brands-wrap"), listSplide: this.DOM.el.querySelectorAll(".home-hero-brands") }), this.initMotions(), this.handleInitPricing(), this.handleLoadMorePrice() } initMotions() { Q.maskText(this.DOM.el), Q.fadeText(this.DOM.el), Q.fadeWrap(this.DOM.el) } handleLoadMorePrice() { if (!this.DOM.el) return; const A = this.DOM.el.querySelectorAll("#tablePricing .pricing_table_row"); let M = 10; for (let h = 0; h <= M; h++)A[h].classList.add("show_row"); const O = this; this.DOM.el.querySelector("#loadMoreTable").addEventListener("click", function () { var e; let h = M + 11; for (let l = M; l < h && l < A.length; l++)A[l].classList.add("show_row"); if (ae.refresh(), h > 11) { H.killTweensOf(O.DOM.el.querySelectorAll(".pricing_table_row_border")); const l = (e = O.DOM.el.querySelector(".pricing_table_body")) == null ? void 0 : e.querySelectorAll(".pricing_table_row_border"); l == null || l.forEach((a, r) => { h - r < 12 && new Ue(a, { type: "fade_tran", start: "top 70%", delay: .1 }) }) } M = h, M >= A.length && (this.style.display = "none") }) } handleSelectTypePlan() { const A = this.DOM.el.querySelector(".pricing-hero-bg-wrap"), M = this.DOM.el.querySelector(".pricing-hero-bg"), O = this.DOM.el.querySelectorAll(".js-text-timer"); A && this.DOM.el.querySelectorAll(".pricing-hero-tab-item").forEach(h => { h.addEventListener("click", () => { var t, n, s, c, v; const e = h.getAttribute("data-plan-pricing"); if (!this.pricing || e === ((t = this.planCurrent) == null ? void 0 : t.type)) return; const l = A.getBoundingClientRect().x, a = h.getBoundingClientRect().x, r = h.getBoundingClientRect().width, u = this.planOptions[e]; this.planCurrent = u, O.forEach((m, S, D) => { const p = m.querySelectorAll(".txt.txt-18"); e === "month" ? H.to(p, { y: 0, ease: "power3", duration: 1.2, delay: S * .3 + 1 }) : H.fromTo(p, { y: "0%" }, { y: "-100%", ease: "power3", duration: 1.2, delay: (D.length - S) * .3 + 1 }) }); const i = e === "year", f = (i ? 12 * (100 - u.valSaleUp) / 100 : 1) * u.planUser, o = (i ? 12 * (100 - u.valSaleUp) / 100 : 1) * u.basePrice; !this.pricingAgent || !this.pricingBase || ((n = this.pricingAgent.textSplit) == null || n.revert(), (s = this.pricingBase.textSplit) == null || s.revert(), this.pricingBase.DOM.el.innerHTML = `${o}`, this.pricingAgent.DOM.el.innerHTML = `${f}`, this.pricingAgent.init(), this.pricingBase.init(), (c = this.pricingAgent) == null || c.animIn(), (v = this.pricingBase) == null || v.animIn(.1), H.to(M, { x: -(l - a), duration: .5, width: r, ease: "power3.out" }), this.pricing.handleCalcPricing({ ...u, isReinit: !0 })) }) }) } handleInitPricing() { var u; const A = (u = this.DOM.el.querySelector(".txt-168.txt-bold")) == null ? void 0 : u.querySelector(".js-text-counter"), M = this.DOM.el.querySelector(".text-pricing-agent"), O = this.DOM.el.querySelector(".text-pricing-base"), h = document.querySelector(".fs-rangeslider_input__custom"), e = !0, l = new pe(A, h, e), a = new pe(O, void 0, e), r = new pe(M, void 0, e); this.pricingAgent = r, this.pricingBase = a, this.pricing = l, this.handleSelectTypePlan(), this.handleActionPlanPricing() } handleActionPlanPricing() { setTimeout(() => { var A, M, O, h; this.pricing && this.pricing.handleSlide({ type: ((A = this.planCurrent) == null ? void 0 : A.type) || "month", planUser: ((M = this.planCurrent) == null ? void 0 : M.planUser) || 35, valSaleUp: ((O = this.planCurrent) == null ? void 0 : O.valSaleUp) || 0, basePrice: ((h = this.planCurrent) == null ? void 0 : h.basePrice) || 75 }) }, 1e3) } clear() { this.initParticles() } } H.registerPlugin(ae); class Dt { constructor() { this.init(), this.bindEvents() } init() { const M = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", M), M) return; const O = document.querySelector("div[data-page]"); if (!O) return; const h = O.getAttribute("data-page") || "home", e = { home: () => { new Ct(O) }, about: () => { new yt(O) }, pricing: () => { new Pt(O) } }; e[h] && e[h](), Ve.init(), Q.init(), new gt, new vt } bindEvents() { U.on(ot, this.init.bind(this)), ke.simple(), ke.simpleLoaded() } } new Dt;
