var nt = Object.defineProperty; var st = (R, M, x) => M in R ? nt(R, M, { enumerable: !0, configurable: !0, writable: !0, value: x }) : R[M] = x; var F = (R, M, x) => (st(R, typeof M != "symbol" ? M + "" : M, x), x); import { b, P as Q, d as J, u as Z, e as k, f as Ne, S as se, g as U, i as rt, s as He, L as ot, h as at, A as lt, j as ct, D as ft, k as ut, l as ht, R as be, U as We, m as Ce, n as ze, a as G, F as gt, T as pt, c as Me, o as dt, p as fe, M as Oe, q as vt, r as we, t as mt, _ as xt, v as yt } from "./global.js";/*!
 * ScrollToPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Y, $e, oe, ne, ce, Xe, Ye, xe, Ke = function () { return typeof window < "u" }, Qe = function () { return Y || Ke() && (Y = window.gsap) && Y.registerPlugin && Y }, Je = function (M) { return typeof M == "string" }, Ve = function (M) { return typeof M == "function" }, he = function (M, x) { var T = x === "x" ? "Width" : "Height", u = "scroll" + T, e = "client" + T; return M === oe || M === ne || M === ce ? Math.max(ne[u], ce[u]) - (oe["inner" + T] || ne[e] || ce[e]) : M[u] - M["offset" + T] }, ge = function (M, x) { var T = "scroll" + (x === "x" ? "Left" : "Top"); return M === oe && (M.pageXOffset != null ? T = "page" + x.toUpperCase() + "Offset" : M = ne[T] != null ? ne : ce), function () { return M[T] } }, St = function (M, x, T, u) { if (Ve(M) && (M = M(x, T, u)), typeof M != "object") return Je(M) && M !== "max" && M.charAt(1) !== "=" ? { x: M, y: M } : { y: M }; if (M.nodeType) return { y: M, x: M }; var e = {}, a; for (a in M) e[a] = a !== "onAutoKill" && Ve(M[a]) ? M[a](x, T, u) : M[a]; return e }, Ze = function (M, x) { if (M = Xe(M)[0], !M || !M.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || { x: 0, y: 0 }; var T = M.getBoundingClientRect(), u = !x || x === oe || x === ce, e = u ? { top: ne.clientTop - (oe.pageYOffset || ne.scrollTop || ce.scrollTop || 0), left: ne.clientLeft - (oe.pageXOffset || ne.scrollLeft || ce.scrollLeft || 0) } : x.getBoundingClientRect(), a = { x: T.left - e.left, y: T.top - e.top }; return !u && x && (a.x += ge(x, "x")(), a.y += ge(x, "y")()), a }, Ue = function (M, x, T, u, e) { return !isNaN(M) && typeof M != "object" ? parseFloat(M) - e : Je(M) && M.charAt(1) === "=" ? parseFloat(M.substr(2)) * (M.charAt(0) === "-" ? -1 : 1) + u - e : M === "max" ? he(x, T) - e : Math.min(he(x, T), Ze(M, x)[T] - e) }, Ge = function () { Y = Qe(), Ke() && Y && typeof document < "u" && document.body && (oe = window, ce = document.body, ne = document.documentElement, Xe = Y.utils.toArray, Y.config({ autoKillThreshold: 7 }), Ye = Y.config(), $e = 1) }, pe = { version: "3.12.5", name: "scrollTo", rawVars: 1, register: function (M) { Y = M, Ge() }, init: function (M, x, T, u, e) { $e || Ge(); var a = this, l = Y.getProperty(M, "scrollSnapType"); a.isWin = M === oe, a.target = M, a.tween = T, x = St(x, u, M, e), a.vars = x, a.autoKill = !!x.autoKill, a.getX = ge(M, "x"), a.getY = ge(M, "y"), a.x = a.xPrev = a.getX(), a.y = a.yPrev = a.getY(), xe || (xe = Y.core.globals().ScrollTrigger), Y.getProperty(M, "scrollBehavior") === "smooth" && Y.set(M, { scrollBehavior: "auto" }), l && l !== "none" && (a.snap = 1, a.snapInline = M.style.scrollSnapType, M.style.scrollSnapType = "none"), x.x != null ? (a.add(a, "x", a.x, Ue(x.x, M, "x", a.x, x.offsetX || 0), u, e), a._props.push("scrollTo_x")) : a.skipX = 1, x.y != null ? (a.add(a, "y", a.y, Ue(x.y, M, "y", a.y, x.offsetY || 0), u, e), a._props.push("scrollTo_y")) : a.skipY = 1 }, render: function (M, x) { for (var T = x._pt, u = x.target, e = x.tween, a = x.autoKill, l = x.xPrev, r = x.yPrev, h = x.isWin, n = x.snap, f = x.snapInline, o, t, s, i, c; T;)T.r(M, T.d), T = T._next; o = h || !x.skipX ? x.getX() : l, t = h || !x.skipY ? x.getY() : r, s = t - r, i = o - l, c = Ye.autoKillThreshold, x.x < 0 && (x.x = 0), x.y < 0 && (x.y = 0), a && (!x.skipX && (i > c || i < -c) && o < he(u, "x") && (x.skipX = 1), !x.skipY && (s > c || s < -c) && t < he(u, "y") && (x.skipY = 1), x.skipX && x.skipY && (e.kill(), x.vars.onAutoKill && x.vars.onAutoKill.apply(e, x.vars.onAutoKillParams || []))), h ? oe.scrollTo(x.skipX ? o : x.x, x.skipY ? t : x.y) : (x.skipY || (u.scrollTop = x.y), x.skipX || (u.scrollLeft = x.x)), n && (M === 1 || M === 0) && (t = u.scrollTop, o = u.scrollLeft, f ? u.style.scrollSnapType = f : u.style.removeProperty("scroll-snap-type"), u.scrollTop = t + 1, u.scrollLeft = o + 1, u.scrollTop = t, u.scrollLeft = o), x.xPrev = x.x, x.yPrev = x.y, xe && xe.update() }, kill: function (M) { var x = M === "scrollTo", T = this._props.indexOf(M); return (x || M === "scrollTo_x") && (this.skipX = 1), (x || M === "scrollTo_y") && (this.skipY = 1), T > -1 && this._props.splice(T, 1), !this._props.length } }; pe.max = he; pe.getOffset = Ze; pe.buildGetter = ge; Qe() && Y.registerPlugin(pe); const Te = (R, M, x, T, u) => parseFloat(((R - M) * (u - T) / (x - M) + T).toFixed(3)), Pe = R => { const M = parseFloat(getComputedStyle(document.documentElement).fontSize); return R / M }; class Mt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)), this.handleAppendComponent() } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } handleAppendComponent() { const M = this.DOM.el.querySelector(".blog-quote"), x = this.DOM.el.querySelector("#content_blog"), T = "{{quote}}", u = x.textContent; u != null && u.includes(T) || (M.style.display = "none") } } const wt = "_parallax_79i64_1", Pt = "_wrapper_79i64_5", Dt = "_inner_79i64_12", De = { parallax: wt, wrapper: Pt, inner: Dt }; class Ae { constructor({ el: M, offset: x, scale: T, direction: u, ...e }) { F(this, "DOM"); F(this, "offset"); F(this, "scale"); F(this, "direction"); F(this, "options"); this.DOM = { el: M }, this.offset = x || 0, this.scale = T || 1.1, this.direction = u || -1, this.options = e, this.init() } init() { const M = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const x = document.createElement("div"); x.style.scale = `${this.scale}`, x.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, x.classList.add(De.inner), M.classList.add(De.parallax), this.DOM.el.classList.add(De.wrapper), x.appendChild(M), this.DOM.el.appendChild(x), this.DOM.elInner = this.DOM.el; const { removeEvent: T } = Ne({ el: this.DOM.el, animIn: () => { this.animIn(), T() } }); Z(() => { T() }) } animIn() { var u; if (!this.DOM.elInner) return; const M = 100 + this.offset * 2, x = this.offset * M / 100 * this.direction, T = { trigger: this.DOM.el, start: "top bottom+=5%", end: "bottom top", scrub: 1 }; se.create({ trigger: (u = this.DOM.el) == null ? void 0 : u.parentElement, start: "top-=100% bottom", once: !0, onEnter: () => { se.refresh() } }), U.timeline({ scrollTrigger: T }).to(this.DOM.elInner, { y: `${x}%` }) } } class Ct { constructor() { F(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.DOM.el && (this.hander(), this.movingImageFooter(), this.initMotion()) } initMotion() { this.DOM.el && (k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el)) } hander() { var x; const M = (x = this.DOM.el) == null ? void 0 : x.querySelector(".footer-bottom-inner-back"); U.registerPlugin(pe), M == null || M.addEventListener("click", () => { U.to(window, { scrollTo: 0, duration: 1.2, ease: "power3.inOut" }) }) } movingImageFooter() { var a, l, r, h, n; const M = (a = this.DOM.el) == null ? void 0 : a.querySelector(".footer-middle-inner-img"), x = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-list-imgs"); new Ae({ el: x, offset: 25, direction: 1, scale: 1.3 }); const T = (r = this.DOM.el) == null ? void 0 : r.querySelectorAll(".footer-middle-list-imgs-item"), u = U.quickTo(M, "x", { duration: .9, ease: "power3.out" }), e = f => { T == null || T.forEach((o, t) => { t === f ? U.to(o, { opacity: 1, ease: "power3.out", duration: .6, willChange: "opacity" }) : U.to(o, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; e(1), M.style.willChange = "transform", (h = this.DOM.el) == null || h.addEventListener("mousemove", f => { if (!this.DOM.el) return; const o = f.pageX, t = Te(o, 0, window.innerWidth, -1, 1), s = Math.floor(Te(o, 0, window.innerWidth, 0, (T == null ? void 0 : T.length) || 3)), i = (this.DOM.el.clientWidth - M.clientWidth) / 2; u(t * i), e(s) }), (n = this.DOM.el) == null || n.addEventListener("mouseleave", () => { u(0), e(1) }) } } class Ot { constructor() { F(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show(), this.handleDropdownHoverLink(), this.handleDropdownToggle() } show() { let M = 0; window.addEventListener("scroll", () => { var r; if (!this.DOM.el) return; const x = window.pageYOffset || document.documentElement.scrollTop || 0, T = ((r = this.DOM.footer) == null ? void 0 : r.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, u = x > this.DOM.el.clientHeight, a = M < x && x > this.DOM.el.clientHeight * 2 || T, l = M > x && !T; a ? this.DOM.el.classList.add("hidden") : l && (this.DOM.el.classList.remove("hidden"), this.DOM.el.classList.toggle("scrollDown", u)), M = x }) } handleDropdownToggle() { if (!this.DOM.el) return; this.DOM.el.querySelectorAll(".header-nav-item").forEach(x => { const T = x.querySelector(".header-nav-item-ic"); T && (x.addEventListener("mouseenter", function () { U.to(T, { ease: "power3.out", duration: .3, rotate: 180 }) }), x.addEventListener("mouseleave", function () { U.to(T, { ease: "power3.out", duration: .3, rotate: 0 }) })) }) } handleDropdownHoverLink() { if (!this.DOM.el) return; const M = this.DOM.el.querySelectorAll(".header-dropdown-link-txt"); M.length && M.forEach(x => { x.addEventListener("mouseenter", function () { M.forEach(T => T.style.color = "rgba(255, 255, 255, 0.56)"), this.style.color = "#fff" }), x.addEventListener("mouseleave", function () { M.forEach(T => T.style.color = "#fff") }) }) } } const Tt = ({ el: R, isGsap: M = !0, isDebug: x, inScreen: T, onEnterBack: u, outScreen: e, threshold: a = 0, onToggle: l, onToggleOb: r, start: h, end: n }) => { let f = !1, o = null, t; return !rt() || M ? He(() => { o = se.create({ trigger: R, start: h || `top+=${a * 100}% bottom`, end: n || "bottom top", markers: x, onToggle: c => { f = c.isActive, l && l(c), f ? T && T() : e && e() }, onEnterBack: u, invalidateOnRefresh: !0 }) }) : He(() => { t = new IntersectionObserver(c => { f = c[0].isIntersecting, r && r(f), f ? T && T() : e && e() }, { threshold: a }), t.observe(R) }), { isInViewPointer: () => f, removeOb: () => { t && (t.unobserve(R), t.disconnect()), f = !1, o == null || o.kill(), o = null } } }; class At { constructor() { F(this, "DOM"); F(this, "isReady"); F(this, "inited"); F(this, "windowIsBlur"); F(this, "isSimpleLoader"); F(this, "minProgress"); F(this, "processing"); F(this, "registerCount"); F(this, "lowNet"); F(this, "strokeDashoffset"); F(this, "obServerAPI"); F(this, "idAnimationLoop"); F(this, "runAnimation"); F(this, "delayPageEnter"); F(this, "delaLoadingOut"); this.registerLoader = this.registerLoader.bind(this), this.unRegisterLoader = this.unRegisterLoader.bind(this), this.init() } init() { this.DOM = { main: document.querySelector(".page-loading") }, document.body.classList.add("js-ready", "is-loading"), b.emit(ot), this.inited = !!this.DOM.main, this.isReady = !1, this.windowIsBlur = !1, this.isSimpleLoader = !1, this.minProgress = 98, this.delayPageEnter = 1.2, this.delaLoadingOut = .3, this.processing = { delta: 0, percentStuck: 0, runWidth: 0 }, this.registerCount = 0, this.lowNet = 0, this.strokeDashoffset = 829, this.hideLoading = this.hideLoading.bind(this), at(() => (b.on(be, this.registerLoader), b.on(We, this.unRegisterLoader), window.addEventListener("DOMContentLoaded", this.hideLoading), () => { b.off(be, this.registerLoader), b.off(We, this.unRegisterLoader), window.removeEventListener("DOMContentLoaded", this.hideLoading) })) } simpleLoaded() { var M; (M = this.DOM.main) == null || M.classList.add("is-simple"), this.isSimpleLoader = !0, this.pageLoaded() } simple() { this.obServerAPI = Tt({ el: document.body }), this.isSimpleLoader = !0, this.isReady = !0, b.emit(lt), document.body.classList.add("is-ready") } hideLoading() { b.emit(ct) } hide() { ft(() => { this.DOM.main && (this.DOM.main.style.visibility = "hidden") }) } pageLoaded() { this.idAnimationLoop && cancelAnimationFrame(this.idAnimationLoop), document.body.classList.remove("is-loading"), document.body.classList.remove("is-simple"), b.emit(J), b.emit(ut), console.log("this.isSimpleLoader", this.isSimpleLoader), this.isSimpleLoader && (console.log("run_______"), this.DOM.main && U.to(this.DOM.main, { opacity: 0, duration: this.delayPageEnter, ease: "power3.inOut", onComplete: () => { setTimeout(() => this.hide(), 100), b.emit(Q), b.emit(ht) } })) } registerLoader() { this.registerCount++ } unRegisterLoader() { this.registerCount-- } } const qe = new At; class It { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el), this.handleStackCard() } clear() { this.initParticles() } handleStackCard() { var n; const M = this.DOM.el.querySelector(".about-vision-sticky-inner"), T = this.DOM.el.querySelector(".about-vision-sticky-left").querySelectorAll(".about-sticky-left-card"), u = this.DOM.el.querySelector(".about-vision-sticky-right-inner"), e = (n = this.DOM.el.querySelector(".about-vision-sticky-right-inner")) == null ? void 0 : n.querySelectorAll(".about-sticky-right-img"), a = Pe((window.innerHeight - u.clientHeight) / 2); this.DOM.listImagesDesk = e; const l = () => { let f = null; console.log("preId", f); const o = U.timeline({ scrollTrigger: { trigger: ".about-vision-sticky", start: "top top", end() { return `bottom+=${window.innerHeight - u.clientHeight} bottom` }, scrub: 1, onUpdate: i => { const { progress: c } = i, p = Math.min(T.length - 1, Math.floor(ze(c, 0, 1, 0, T.length + 1 - .01))); s(p), f = p } } }); (i => { const c = Pe((u.clientHeight - G(3.2) * 2) / T.length); T.forEach(p => { o.to(p, { height: `${c}rem`, ease: "none", overwrite: "auto" }) }) })(); const s = i => { !Ce || !(e != null && e.length) || e.forEach((c, p) => { p === i ? (U.killTweensOf(c), U.to(c, { opacity: 1, ease: "power3", duration: .8 })) : U.to(c, { opacity: 0, ease: "power3", duration: .8 }) }) }; s(0), M.style.top = `${a}rem` }, r = () => { this.DOM.el.querySelectorAll(".about-sticky-left-card").forEach(o => { const t = o.querySelector(".about-sticky-left-card-inner-title"), s = (t == null ? void 0 : t.clientHeight) || 0, i = { root: null, rootMargin: "0px", threshold: 1 }, c = Pe(s) + 3.2 * 2; i.threshold = 0, h.call(this, i, c).observe(o) }) }; function h(f, o) { const t = new IntersectionObserver(s => { s.forEach(i => { if (i.isIntersecting) { const c = i.target; U.timeline({ scrollTrigger: { trigger: c, markers: !1, start: () => `top top+=${c.clientHeight + G(3.2) > window.innerHeight ? "0" : G(16)}`, end: () => `+=${G(16)}`, scrub: 1 } }).to(c, { height: `${o}rem`, ease: "none", onComplete: () => { se.refresh() } }), t.unobserve(c) } }) }, f); return t } Ce ? l() : (r(), this.handleReplaceUrlImg()) } handleReplaceUrlImg() { var T; const M = this.DOM.el.querySelectorAll(".about-img-mb"), x = (T = this.DOM.el.querySelector(".about-vision-sticky-right-inner")) == null ? void 0 : T.querySelectorAll(".about-sticky-right-img"); M.forEach((u, e) => { var h, n; const a = u.querySelector("img"); if (!x.length || !a) return; const l = (h = x[e].querySelector("img")) == null ? void 0 : h.getAttribute("src"), r = (n = x[e].querySelector("img")) == null ? void 0 : n.getAttribute("srcset"); l && r && (a.setAttribute("src", l), a.setAttribute("srcset", r)) }) } } class Lt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { this.initMotion(), this.handleDrawLine(), this.handleAction() } handleDrawLine() { const M = this.DOM.el.querySelectorAll(".changelog-item"); se.refresh(), console.log("listBlog_______", M), M.forEach((x, T) => { const u = x.querySelector(".line-draws"); if (u && (u.style.willChange = "transform", se.create({ trigger: x, start: () => `top ${T === 0 ? "bottom" : "center"}`, scrub: 1, end: "bottom center", onUpdate: ({ progress: e }) => { u.style.transform = `scaleY(${e})` } }), T > 3)) { const e = x.querySelectorAll(".js-fade"), a = x.querySelectorAll(".js-text-mask"); setTimeout(() => { e.forEach((l, r) => { new gt(l, { delay: r / 10 }) }), a.forEach((l, r) => { new pt(l, { delay: .05 }) }) }, 100) } }) } handleAction() { const M = this.DOM.el.querySelector(".changelog-more"); M == null || M.addEventListener("click", () => { console.log("run_________"), setTimeout(() => { this.handleDrawLine() }, 300) }), this.handleSubmit() } handleSubmit() { const M = this.DOM.el.querySelectorAll(".changelog-detail-right-btn-wrap"), x = this.DOM.el.querySelector('input[name="type"]'), T = this.DOM.el.querySelector('input[name="link"]'); M.forEach(u => { u.addEventListener("click", () => { var a; const e = (a = u.querySelector("[data-type-access]")) == null ? void 0 : a.getAttribute("data-type-access"); x.value = e || "", T.value = location.href, u.classList.add("active") }) }) } initMotion() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Et { constructor(M) { F(this, "DOM"); this.DOM = { wrapper: M.querySelector(".home-feature-cards"), listCards: M.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((M, x, T) => { if (!Ce) return; const u = T[0].clientHeight, e = (window.innerHeight - u) / 2, a = T.length * G(8), l = Te(x, 0, T.length - 1, .8125, 1); M.style.top = `${e + a}px`, M.style.transform = `translateY(-${(T.length - x) * G(8)}px)`, U.timeline({ scrollTrigger: { trigger: M, start: () => "top center", end: `+=${(T.length - x) * u} `, scrub: 1 } }).to(M, { scale: l, transformOrigin: "top center", ease: "none" }, 0) }) } } var le = {}, Bt = { get exports() { return le }, set exports(R) { le = R } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (R, M) { (function (T, u) { R.exports = u() })(Me, function () { return function (x) { var T = {}; function u(e) { if (T[e]) return T[e].exports; var a = T[e] = { i: e, l: !1, exports: {} }; return x[e].call(a.exports, a, a.exports, u), a.l = !0, a.exports } return u.m = x, u.c = T, u.d = function (e, a, l) { u.o(e, a) || Object.defineProperty(e, a, { enumerable: !0, get: l }) }, u.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, u.t = function (e, a) { if (a & 1 && (e = u(e)), a & 8 || a & 4 && typeof e == "object" && e && e.__esModule) return e; var l = Object.create(null); if (u.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: e }), a & 2 && typeof e != "string") for (var r in e) u.d(l, r, function (h) { return e[h] }.bind(null, r)); return l }, u.n = function (e) { var a = e && e.__esModule ? function () { return e.default } : function () { return e }; return u.d(a, "a", a), a }, u.o = function (e, a) { return Object.prototype.hasOwnProperty.call(e, a) }, u.p = "", u(u.s = 20) }([function (x, T) { var u = {}; x.exports = u, function () { u._baseDelta = 1e3 / 60, u._nextId = 0, u._seed = 0, u._nowStartTime = +new Date, u._warnedOnce = {}, u._decomp = null, u.extend = function (a, l) { var r, h; typeof l == "boolean" ? (r = 2, h = l) : (r = 1, h = !0); for (var n = r; n < arguments.length; n++) { var f = arguments[n]; if (f) for (var o in f) h && f[o] && f[o].constructor === Object && (!a[o] || a[o].constructor === Object) ? (a[o] = a[o] || {}, u.extend(a[o], h, f[o])) : a[o] = f[o] } return a }, u.clone = function (a, l) { return u.extend({}, l, a) }, u.keys = function (a) { if (Object.keys) return Object.keys(a); var l = []; for (var r in a) l.push(r); return l }, u.values = function (a) { var l = []; if (Object.keys) { for (var r = Object.keys(a), h = 0; h < r.length; h++)l.push(a[r[h]]); return l } for (var n in a) l.push(a[n]); return l }, u.get = function (a, l, r, h) { l = l.split(".").slice(r, h); for (var n = 0; n < l.length; n += 1)a = a[l[n]]; return a }, u.set = function (a, l, r, h, n) { var f = l.split(".").slice(h, n); return u.get(a, l, 0, -1)[f[f.length - 1]] = r, r }, u.shuffle = function (a) { for (var l = a.length - 1; l > 0; l--) { var r = Math.floor(u.random() * (l + 1)), h = a[l]; a[l] = a[r], a[r] = h } return a }, u.choose = function (a) { return a[Math.floor(u.random() * a.length)] }, u.isElement = function (a) { return typeof HTMLElement < "u" ? a instanceof HTMLElement : !!(a && a.nodeType && a.nodeName) }, u.isArray = function (a) { return Object.prototype.toString.call(a) === "[object Array]" }, u.isFunction = function (a) { return typeof a == "function" }, u.isPlainObject = function (a) { return typeof a == "object" && a.constructor === Object }, u.isString = function (a) { return toString.call(a) === "[object String]" }, u.clamp = function (a, l, r) { return a < l ? l : a > r ? r : a }, u.sign = function (a) { return a < 0 ? -1 : 1 }, u.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - u._nowStartTime }, u.random = function (a, l) { return a = typeof a < "u" ? a : 0, l = typeof l < "u" ? l : 1, a + e() * (l - a) }; var e = function () { return u._seed = (u._seed * 9301 + 49297) % 233280, u._seed / 233280 }; u.colorToNumber = function (a) { return a = a.replace("#", ""), a.length == 3 && (a = a.charAt(0) + a.charAt(0) + a.charAt(1) + a.charAt(1) + a.charAt(2) + a.charAt(2)), parseInt(a, 16) }, u.logLevel = 1, u.log = function () { console && u.logLevel > 0 && u.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, u.info = function () { console && u.logLevel > 0 && u.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, u.warn = function () { console && u.logLevel > 0 && u.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, u.warnOnce = function () { var a = Array.prototype.slice.call(arguments).join(" "); u._warnedOnce[a] || (u.warn(a), u._warnedOnce[a] = !0) }, u.deprecated = function (a, l, r) { a[l] = u.chain(function () { u.warnOnce("🔅 deprecated 🔅", r) }, a[l]) }, u.nextId = function () { return u._nextId++ }, u.indexOf = function (a, l) { if (a.indexOf) return a.indexOf(l); for (var r = 0; r < a.length; r++)if (a[r] === l) return r; return -1 }, u.map = function (a, l) { if (a.map) return a.map(l); for (var r = [], h = 0; h < a.length; h += 1)r.push(l(a[h])); return r }, u.topologicalSort = function (a) { var l = [], r = [], h = []; for (var n in a) !r[n] && !h[n] && u._topologicalSort(n, r, h, a, l); return l }, u._topologicalSort = function (a, l, r, h, n) { var f = h[a] || []; r[a] = !0; for (var o = 0; o < f.length; o += 1) { var t = f[o]; r[t] || l[t] || u._topologicalSort(t, l, r, h, n) } r[a] = !1, l[a] = !0, n.push(a) }, u.chain = function () { for (var a = [], l = 0; l < arguments.length; l += 1) { var r = arguments[l]; r._chained ? a.push.apply(a, r._chained) : a.push(r) } var h = function () { for (var n, f = new Array(arguments.length), o = 0, t = arguments.length; o < t; o++)f[o] = arguments[o]; for (o = 0; o < a.length; o += 1) { var s = a[o].apply(n, f); typeof s < "u" && (n = s) } return n }; return h._chained = a, h }, u.chainPathBefore = function (a, l, r) { return u.set(a, l, u.chain(r, u.get(a, l))) }, u.chainPathAfter = function (a, l, r) { return u.set(a, l, u.chain(u.get(a, l), r)) }, u.setDecomp = function (a) { u._decomp = a }, u.getDecomp = function () { var a = u._decomp; try { !a && typeof window < "u" && (a = window.decomp), !a && typeof Me < "u" && (a = Me.decomp) } catch { a = null } return a } }() }, function (x, T) { var u = {}; x.exports = u, function () { u.create = function (e) { var a = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && u.update(a, e), a }, u.update = function (e, a, l) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var r = 0; r < a.length; r++) { var h = a[r]; h.x > e.max.x && (e.max.x = h.x), h.x < e.min.x && (e.min.x = h.x), h.y > e.max.y && (e.max.y = h.y), h.y < e.min.y && (e.min.y = h.y) } l && (l.x > 0 ? e.max.x += l.x : e.min.x += l.x, l.y > 0 ? e.max.y += l.y : e.min.y += l.y) }, u.contains = function (e, a) { return a.x >= e.min.x && a.x <= e.max.x && a.y >= e.min.y && a.y <= e.max.y }, u.overlaps = function (e, a) { return e.min.x <= a.max.x && e.max.x >= a.min.x && e.max.y >= a.min.y && e.min.y <= a.max.y }, u.translate = function (e, a) { e.min.x += a.x, e.max.x += a.x, e.min.y += a.y, e.max.y += a.y }, u.shift = function (e, a) { var l = e.max.x - e.min.x, r = e.max.y - e.min.y; e.min.x = a.x, e.max.x = a.x + l, e.min.y = a.y, e.max.y = a.y + r } }() }, function (x, T) { var u = {}; x.exports = u, function () { u.create = function (e, a) { return { x: e || 0, y: a || 0 } }, u.clone = function (e) { return { x: e.x, y: e.y } }, u.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, u.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, u.rotate = function (e, a, l) { var r = Math.cos(a), h = Math.sin(a); l || (l = {}); var n = e.x * r - e.y * h; return l.y = e.x * h + e.y * r, l.x = n, l }, u.rotateAbout = function (e, a, l, r) { var h = Math.cos(a), n = Math.sin(a); r || (r = {}); var f = l.x + ((e.x - l.x) * h - (e.y - l.y) * n); return r.y = l.y + ((e.x - l.x) * n + (e.y - l.y) * h), r.x = f, r }, u.normalise = function (e) { var a = u.magnitude(e); return a === 0 ? { x: 0, y: 0 } : { x: e.x / a, y: e.y / a } }, u.dot = function (e, a) { return e.x * a.x + e.y * a.y }, u.cross = function (e, a) { return e.x * a.y - e.y * a.x }, u.cross3 = function (e, a, l) { return (a.x - e.x) * (l.y - e.y) - (a.y - e.y) * (l.x - e.x) }, u.add = function (e, a, l) { return l || (l = {}), l.x = e.x + a.x, l.y = e.y + a.y, l }, u.sub = function (e, a, l) { return l || (l = {}), l.x = e.x - a.x, l.y = e.y - a.y, l }, u.mult = function (e, a) { return { x: e.x * a, y: e.y * a } }, u.div = function (e, a) { return { x: e.x / a, y: e.y / a } }, u.perp = function (e, a) { return a = a === !0 ? -1 : 1, { x: a * -e.y, y: a * e.x } }, u.neg = function (e) { return { x: -e.x, y: -e.y } }, u.angle = function (e, a) { return Math.atan2(a.y - e.y, a.x - e.x) }, u._temp = [u.create(), u.create(), u.create(), u.create(), u.create(), u.create()] }() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(2), l = u(0); (function () { e.create = function (r, h) { for (var n = [], f = 0; f < r.length; f++) { var o = r[f], t = { x: o.x, y: o.y, index: f, body: h, isInternal: !1 }; n.push(t) } return n }, e.fromPath = function (r, h) { var n = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, f = []; return r.replace(n, function (o, t, s) { f.push({ x: parseFloat(t), y: parseFloat(s) }) }), e.create(f, h) }, e.centre = function (r) { for (var h = e.area(r, !0), n = { x: 0, y: 0 }, f, o, t, s = 0; s < r.length; s++)t = (s + 1) % r.length, f = a.cross(r[s], r[t]), o = a.mult(a.add(r[s], r[t]), f), n = a.add(n, o); return a.div(n, 6 * h) }, e.mean = function (r) { for (var h = { x: 0, y: 0 }, n = 0; n < r.length; n++)h.x += r[n].x, h.y += r[n].y; return a.div(h, r.length) }, e.area = function (r, h) { for (var n = 0, f = r.length - 1, o = 0; o < r.length; o++)n += (r[f].x - r[o].x) * (r[f].y + r[o].y), f = o; return h ? n / 2 : Math.abs(n) / 2 }, e.inertia = function (r, h) { for (var n = 0, f = 0, o = r, t, s, i = 0; i < o.length; i++)s = (i + 1) % o.length, t = Math.abs(a.cross(o[s], o[i])), n += t * (a.dot(o[s], o[s]) + a.dot(o[s], o[i]) + a.dot(o[i], o[i])), f += t; return h / 6 * (n / f) }, e.translate = function (r, h, n) { n = typeof n < "u" ? n : 1; var f = r.length, o = h.x * n, t = h.y * n, s; for (s = 0; s < f; s++)r[s].x += o, r[s].y += t; return r }, e.rotate = function (r, h, n) { if (h !== 0) { var f = Math.cos(h), o = Math.sin(h), t = n.x, s = n.y, i = r.length, c, p, y, w; for (w = 0; w < i; w++)c = r[w], p = c.x - t, y = c.y - s, c.x = t + (p * f - y * o), c.y = s + (p * o + y * f); return r } }, e.contains = function (r, h) { for (var n = h.x, f = h.y, o = r.length, t = r[o - 1], s, i = 0; i < o; i++) { if (s = r[i], (n - t.x) * (s.y - t.y) + (f - t.y) * (t.x - s.x) > 0) return !1; t = s } return !0 }, e.scale = function (r, h, n, f) { if (h === 1 && n === 1) return r; f = f || e.centre(r); for (var o, t, s = 0; s < r.length; s++)o = r[s], t = a.sub(o, f), r[s].x = f.x + t.x * h, r[s].y = f.y + t.y * n; return r }, e.chamfer = function (r, h, n, f, o) { typeof h == "number" ? h = [h] : h = h || [8], n = typeof n < "u" ? n : -1, f = f || 2, o = o || 14; for (var t = [], s = 0; s < r.length; s++) { var i = r[s - 1 >= 0 ? s - 1 : r.length - 1], c = r[s], p = r[(s + 1) % r.length], y = h[s < h.length ? s : h.length - 1]; if (y === 0) { t.push(c); continue } var w = a.normalise({ x: c.y - i.y, y: i.x - c.x }), O = a.normalise({ x: p.y - c.y, y: c.x - p.x }), g = Math.sqrt(2 * Math.pow(y, 2)), v = a.mult(l.clone(w), y), m = a.normalise(a.mult(a.add(w, O), .5)), d = a.sub(c, a.mult(m, g)), P = n; n === -1 && (P = Math.pow(y, .32) * 1.75), P = l.clamp(P, f, o), P % 2 === 1 && (P += 1); for (var S = Math.acos(a.dot(w, O)), D = S / P, C = 0; C < P; C++)t.push(a.add(a.rotate(v, D * C), d)) } return t }, e.clockwiseSort = function (r) { var h = e.mean(r); return r.sort(function (n, f) { return a.angle(h, n) - a.angle(h, f) }), r }, e.isConvex = function (r) { var h = 0, n = r.length, f, o, t, s; if (n < 3) return null; for (f = 0; f < n; f++)if (o = (f + 1) % n, t = (f + 2) % n, s = (r[o].x - r[f].x) * (r[t].y - r[o].y), s -= (r[o].y - r[f].y) * (r[t].x - r[o].x), s < 0 ? h |= 1 : s > 0 && (h |= 2), h === 3) return !1; return h !== 0 ? !0 : null }, e.hull = function (r) { var h = [], n = [], f, o; for (r = r.slice(0), r.sort(function (t, s) { var i = t.x - s.x; return i !== 0 ? i : t.y - s.y }), o = 0; o < r.length; o += 1) { for (f = r[o]; n.length >= 2 && a.cross3(n[n.length - 2], n[n.length - 1], f) <= 0;)n.pop(); n.push(f) } for (o = r.length - 1; o >= 0; o -= 1) { for (f = r[o]; h.length >= 2 && a.cross3(h[h.length - 2], h[h.length - 1], f) <= 0;)h.pop(); h.push(f) } return h.pop(), n.pop(), h.concat(n) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(2), r = u(7), h = u(0), n = u(1), f = u(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var s = { id: h.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: a.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, i = h.extend(s, t); return o(i, t), i }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var o = function (t, s) { s = s || {}, e.set(t, { bounds: t.bounds || n.create(t.vertices), positionPrev: t.positionPrev || l.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), a.rotate(t.vertices, t.angle, t.position), f.rotate(t.axes, t.angle), n.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: s.axes || t.axes, area: s.area || t.area, mass: s.mass || t.mass, inertia: s.inertia || t.inertia }); var i = t.isStatic ? "#14151f" : h.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), c = t.isStatic ? "#555" : "#ccc", p = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || i, t.render.strokeStyle = t.render.strokeStyle || c, t.render.lineWidth = t.render.lineWidth || p, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, s, i) { var c; typeof s == "string" && (c = s, s = {}, s[c] = i); for (c in s) if (Object.prototype.hasOwnProperty.call(s, c)) switch (i = s[c], c) { case "isStatic": e.setStatic(t, i); break; case "isSleeping": r.set(t, i); break; case "mass": e.setMass(t, i); break; case "density": e.setDensity(t, i); break; case "inertia": e.setInertia(t, i); break; case "vertices": e.setVertices(t, i); break; case "position": e.setPosition(t, i); break; case "angle": e.setAngle(t, i); break; case "velocity": e.setVelocity(t, i); break; case "angularVelocity": e.setAngularVelocity(t, i); break; case "speed": e.setSpeed(t, i); break; case "angularSpeed": e.setAngularSpeed(t, i); break; case "parts": e.setParts(t, i); break; case "centre": e.setCentre(t, i); break; default: t[c] = i } }, e.setStatic = function (t, s) { for (var i = 0; i < t.parts.length; i++) { var c = t.parts[i]; s ? (c.isStatic || (c._original = { restitution: c.restitution, friction: c.friction, mass: c.mass, inertia: c.inertia, density: c.density, inverseMass: c.inverseMass, inverseInertia: c.inverseInertia }), c.restitution = 0, c.friction = 1, c.mass = c.inertia = c.density = 1 / 0, c.inverseMass = c.inverseInertia = 0, c.positionPrev.x = c.position.x, c.positionPrev.y = c.position.y, c.anglePrev = c.angle, c.angularVelocity = 0, c.speed = 0, c.angularSpeed = 0, c.motion = 0) : c._original && (c.restitution = c._original.restitution, c.friction = c._original.friction, c.mass = c._original.mass, c.inertia = c._original.inertia, c.density = c._original.density, c.inverseMass = c._original.inverseMass, c.inverseInertia = c._original.inverseInertia, c._original = null), c.isStatic = s } }, e.setMass = function (t, s) { var i = t.inertia / (t.mass / 6); t.inertia = i * (s / 6), t.inverseInertia = 1 / t.inertia, t.mass = s, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, s) { e.setMass(t, s * t.area), t.density = s }, e.setInertia = function (t, s) { t.inertia = s, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, s) { s[0].body === t ? t.vertices = s : t.vertices = a.create(s, t), t.axes = f.fromVertices(t.vertices), t.area = a.area(t.vertices), e.setMass(t, t.density * t.area); var i = a.centre(t.vertices); a.translate(t.vertices, i, -1), e.setInertia(t, e._inertiaScale * a.inertia(t.vertices, t.mass)), a.translate(t.vertices, t.position), n.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, s, i) { var c; for (s = s.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, c = 0; c < s.length; c++) { var p = s[c]; p !== t && (p.parent = t, t.parts.push(p)) } if (t.parts.length !== 1) { if (i = typeof i < "u" ? i : !0, i) { var y = []; for (c = 0; c < s.length; c++)y = y.concat(s[c].vertices); a.clockwiseSort(y); var w = a.hull(y), O = a.centre(w); e.setVertices(t, w), a.translate(t.vertices, O) } var g = e._totalProperties(t); t.area = g.area, t.parent = t, t.position.x = g.centre.x, t.position.y = g.centre.y, t.positionPrev.x = g.centre.x, t.positionPrev.y = g.centre.y, e.setMass(t, g.mass), e.setInertia(t, g.inertia), e.setPosition(t, g.centre) } }, e.setCentre = function (t, s, i) { i ? (t.positionPrev.x += s.x, t.positionPrev.y += s.y, t.position.x += s.x, t.position.y += s.y) : (t.positionPrev.x = s.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = s.y - (t.position.y - t.positionPrev.y), t.position.x = s.x, t.position.y = s.y) }, e.setPosition = function (t, s, i) { var c = l.sub(s, t.position); i ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = c.x, t.velocity.y = c.y, t.speed = l.magnitude(c)) : (t.positionPrev.x += c.x, t.positionPrev.y += c.y); for (var p = 0; p < t.parts.length; p++) { var y = t.parts[p]; y.position.x += c.x, y.position.y += c.y, a.translate(y.vertices, c), n.update(y.bounds, y.vertices, t.velocity) } }, e.setAngle = function (t, s, i) { var c = s - t.angle; i ? (t.anglePrev = t.angle, t.angularVelocity = c, t.angularSpeed = Math.abs(c)) : t.anglePrev += c; for (var p = 0; p < t.parts.length; p++) { var y = t.parts[p]; y.angle += c, a.rotate(y.vertices, c, t.position), f.rotate(y.axes, c), n.update(y.bounds, y.vertices, t.velocity), p > 0 && l.rotateAbout(y.position, c, t.position, y.position) } }, e.setVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - s.x * i, t.positionPrev.y = t.position.y - s.y * i, t.velocity.x = (t.position.x - t.positionPrev.x) / i, t.velocity.y = (t.position.y - t.positionPrev.y) / i, t.speed = l.magnitude(t.velocity) }, e.getVelocity = function (t) { var s = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * s, y: (t.position.y - t.positionPrev.y) * s } }, e.getSpeed = function (t) { return l.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, s) { e.setVelocity(t, l.mult(l.normalise(e.getVelocity(t)), s)) }, e.setAngularVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - s * i, t.angularVelocity = (t.angle - t.anglePrev) / i, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, s) { e.setAngularVelocity(t, h.sign(e.getAngularVelocity(t)) * s) }, e.translate = function (t, s, i) { e.setPosition(t, l.add(t.position, s), i) }, e.rotate = function (t, s, i, c) { if (!i) e.setAngle(t, t.angle + s, c); else { var p = Math.cos(s), y = Math.sin(s), w = t.position.x - i.x, O = t.position.y - i.y; e.setPosition(t, { x: i.x + (w * p - O * y), y: i.y + (w * y + O * p) }, c), e.setAngle(t, t.angle + s, c) } }, e.scale = function (t, s, i, c) { var p = 0, y = 0; c = c || t.position; for (var w = 0; w < t.parts.length; w++) { var O = t.parts[w]; a.scale(O.vertices, s, i, c), O.axes = f.fromVertices(O.vertices), O.area = a.area(O.vertices), e.setMass(O, t.density * O.area), a.translate(O.vertices, { x: -O.position.x, y: -O.position.y }), e.setInertia(O, e._inertiaScale * a.inertia(O.vertices, O.mass)), a.translate(O.vertices, { x: O.position.x, y: O.position.y }), w > 0 && (p += O.area, y += O.inertia), O.position.x = c.x + (O.position.x - c.x) * s, O.position.y = c.y + (O.position.y - c.y) * i, n.update(O.bounds, O.vertices, t.velocity) } t.parts.length > 1 && (t.area = p, t.isStatic || (e.setMass(t, t.density * p), e.setInertia(t, y))), t.circleRadius && (s === i ? t.circleRadius *= s : t.circleRadius = null) }, e.update = function (t, s) { s = (typeof s < "u" ? s : 1e3 / 60) * t.timeScale; var i = s * s, c = e._timeCorrection ? s / (t.deltaTime || s) : 1, p = 1 - t.frictionAir * (s / h._baseDelta), y = (t.position.x - t.positionPrev.x) * c, w = (t.position.y - t.positionPrev.y) * c; t.velocity.x = y * p + t.force.x / t.mass * i, t.velocity.y = w * p + t.force.y / t.mass * i, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = s, t.angularVelocity = (t.angle - t.anglePrev) * p * c + t.torque / t.inertia * i, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var O = 0; O < t.parts.length; O++) { var g = t.parts[O]; a.translate(g.vertices, t.velocity), O > 0 && (g.position.x += t.velocity.x, g.position.y += t.velocity.y), t.angularVelocity !== 0 && (a.rotate(g.vertices, t.angularVelocity, t.position), f.rotate(g.axes, t.angularVelocity), O > 0 && l.rotateAbout(g.position, t.angularVelocity, t.position, g.position)), n.update(g.bounds, g.vertices, t.velocity) } }, e.updateVelocities = function (t) { var s = e._baseDelta / t.deltaTime, i = t.velocity; i.x = (t.position.x - t.positionPrev.x) * s, i.y = (t.position.y - t.positionPrev.y) * s, t.speed = Math.sqrt(i.x * i.x + i.y * i.y), t.angularVelocity = (t.angle - t.anglePrev) * s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, s, i) { var c = { x: s.x - t.position.x, y: s.y - t.position.y }; t.force.x += i.x, t.force.y += i.y, t.torque += c.x * i.y - c.y * i.x }, e._totalProperties = function (t) { for (var s = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { var c = t.parts[i], p = c.mass !== 1 / 0 ? c.mass : 1; s.mass += p, s.area += c.area, s.inertia += c.inertia, s.centre = l.add(s.centre, l.mult(c.position, p)) } return s.centre = l.div(s.centre, s.mass), s } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(0); (function () { e.on = function (l, r, h) { for (var n = r.split(" "), f, o = 0; o < n.length; o++)f = n[o], l.events = l.events || {}, l.events[f] = l.events[f] || [], l.events[f].push(h); return h }, e.off = function (l, r, h) { if (!r) { l.events = {}; return } typeof r == "function" && (h = r, r = a.keys(l.events).join(" ")); for (var n = r.split(" "), f = 0; f < n.length; f++) { var o = l.events[n[f]], t = []; if (h && o) for (var s = 0; s < o.length; s++)o[s] !== h && t.push(o[s]); l.events[n[f]] = t } }, e.trigger = function (l, r, h) { var n, f, o, t, s = l.events; if (s && a.keys(s).length > 0) { h || (h = {}), n = r.split(" "); for (var i = 0; i < n.length; i++)if (f = n[i], o = s[f], o) { t = a.clone(h, !1), t.name = f, t.source = l; for (var c = 0; c < o.length; c++)o[c].apply(l, [t]) } } } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(5), l = u(0), r = u(1), h = u(4); (function () { e.create = function (n) { return l.extend({ id: l.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, n) }, e.setModified = function (n, f, o, t) { if (n.isModified = f, f && n.cache && (n.cache.allBodies = null, n.cache.allConstraints = null, n.cache.allComposites = null), o && n.parent && e.setModified(n.parent, f, o, t), t) for (var s = 0; s < n.composites.length; s++) { var i = n.composites[s]; e.setModified(i, f, o, t) } }, e.add = function (n, f) { var o = [].concat(f); a.trigger(n, "beforeAdd", { object: f }); for (var t = 0; t < o.length; t++) { var s = o[t]; switch (s.type) { case "body": if (s.parent !== s) { l.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(n, s); break; case "constraint": e.addConstraint(n, s); break; case "composite": e.addComposite(n, s); break; case "mouseConstraint": e.addConstraint(n, s.constraint); break } } return a.trigger(n, "afterAdd", { object: f }), n }, e.remove = function (n, f, o) { var t = [].concat(f); a.trigger(n, "beforeRemove", { object: f }); for (var s = 0; s < t.length; s++) { var i = t[s]; switch (i.type) { case "body": e.removeBody(n, i, o); break; case "constraint": e.removeConstraint(n, i, o); break; case "composite": e.removeComposite(n, i, o); break; case "mouseConstraint": e.removeConstraint(n, i.constraint); break } } return a.trigger(n, "afterRemove", { object: f }), n }, e.addComposite = function (n, f) { return n.composites.push(f), f.parent = n, e.setModified(n, !0, !0, !1), n }, e.removeComposite = function (n, f, o) { var t = l.indexOf(n.composites, f); if (t !== -1) { var s = e.allBodies(f); e.removeCompositeAt(n, t); for (var i = 0; i < s.length; i++)s[i].sleepCounter = 0 } if (o) for (var i = 0; i < n.composites.length; i++)e.removeComposite(n.composites[i], f, !0); return n }, e.removeCompositeAt = function (n, f) { return n.composites.splice(f, 1), e.setModified(n, !0, !0, !1), n }, e.addBody = function (n, f) { return n.bodies.push(f), e.setModified(n, !0, !0, !1), n }, e.removeBody = function (n, f, o) { var t = l.indexOf(n.bodies, f); if (t !== -1 && (e.removeBodyAt(n, t), f.sleepCounter = 0), o) for (var s = 0; s < n.composites.length; s++)e.removeBody(n.composites[s], f, !0); return n }, e.removeBodyAt = function (n, f) { return n.bodies.splice(f, 1), e.setModified(n, !0, !0, !1), n }, e.addConstraint = function (n, f) { return n.constraints.push(f), e.setModified(n, !0, !0, !1), n }, e.removeConstraint = function (n, f, o) { var t = l.indexOf(n.constraints, f); if (t !== -1 && e.removeConstraintAt(n, t), o) for (var s = 0; s < n.composites.length; s++)e.removeConstraint(n.composites[s], f, !0); return n }, e.removeConstraintAt = function (n, f) { return n.constraints.splice(f, 1), e.setModified(n, !0, !0, !1), n }, e.clear = function (n, f, o) { if (o) for (var t = 0; t < n.composites.length; t++)e.clear(n.composites[t], f, !0); return f ? n.bodies = n.bodies.filter(function (s) { return s.isStatic }) : n.bodies.length = 0, n.constraints.length = 0, n.composites.length = 0, e.setModified(n, !0, !0, !1), n }, e.allBodies = function (n) { if (n.cache && n.cache.allBodies) return n.cache.allBodies; for (var f = [].concat(n.bodies), o = 0; o < n.composites.length; o++)f = f.concat(e.allBodies(n.composites[o])); return n.cache && (n.cache.allBodies = f), f }, e.allConstraints = function (n) { if (n.cache && n.cache.allConstraints) return n.cache.allConstraints; for (var f = [].concat(n.constraints), o = 0; o < n.composites.length; o++)f = f.concat(e.allConstraints(n.composites[o])); return n.cache && (n.cache.allConstraints = f), f }, e.allComposites = function (n) { if (n.cache && n.cache.allComposites) return n.cache.allComposites; for (var f = [].concat(n.composites), o = 0; o < n.composites.length; o++)f = f.concat(e.allComposites(n.composites[o])); return n.cache && (n.cache.allComposites = f), f }, e.get = function (n, f, o) { var t, s; switch (o) { case "body": t = e.allBodies(n); break; case "constraint": t = e.allConstraints(n); break; case "composite": t = e.allComposites(n).concat(n); break }return t ? (s = t.filter(function (i) { return i.id.toString() === f.toString() }), s.length === 0 ? null : s[0]) : null }, e.move = function (n, f, o) { return e.remove(n, f), e.add(o, f), n }, e.rebase = function (n) { for (var f = e.allBodies(n).concat(e.allConstraints(n)).concat(e.allComposites(n)), o = 0; o < f.length; o++)f[o].id = l.nextId(); return n }, e.translate = function (n, f, o) { for (var t = o ? e.allBodies(n) : n.bodies, s = 0; s < t.length; s++)h.translate(t[s], f); return n }, e.rotate = function (n, f, o, t) { for (var s = Math.cos(f), i = Math.sin(f), c = t ? e.allBodies(n) : n.bodies, p = 0; p < c.length; p++) { var y = c[p], w = y.position.x - o.x, O = y.position.y - o.y; h.setPosition(y, { x: o.x + (w * s - O * i), y: o.y + (w * i + O * s) }), h.rotate(y, f) } return n }, e.scale = function (n, f, o, t, s) { for (var i = s ? e.allBodies(n) : n.bodies, c = 0; c < i.length; c++) { var p = i[c], y = p.position.x - t.x, w = p.position.y - t.y; h.setPosition(p, { x: t.x + y * f, y: t.y + w * o }), h.scale(p, f, o) } return n }, e.bounds = function (n) { for (var f = e.allBodies(n), o = [], t = 0; t < f.length; t += 1) { var s = f[t]; o.push(s.bounds.min, s.bounds.max) } return r.create(o) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(4), l = u(5), r = u(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (h, n) { for (var f = n / r._baseDelta, o = e._motionSleepThreshold, t = 0; t < h.length; t++) { var s = h[t], i = a.getSpeed(s), c = a.getAngularSpeed(s), p = i * i + c * c; if (s.force.x !== 0 || s.force.y !== 0) { e.set(s, !1); continue } var y = Math.min(s.motion, p), w = Math.max(s.motion, p); s.motion = e._minBias * y + (1 - e._minBias) * w, s.sleepThreshold > 0 && s.motion < o ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold / f && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1) } }, e.afterCollisions = function (h) { for (var n = e._motionSleepThreshold, f = 0; f < h.length; f++) { var o = h[f]; if (o.isActive) { var t = o.collision, s = t.bodyA.parent, i = t.bodyB.parent; if (!(s.isSleeping && i.isSleeping || s.isStatic || i.isStatic) && (s.isSleeping || i.isSleeping)) { var c = s.isSleeping && !s.isStatic ? s : i, p = c === s ? i : s; !c.isStatic && p.motion > n && e.set(c, !1) } } } }, e.set = function (h, n) { var f = h.isSleeping; n ? (h.isSleeping = !0, h.sleepCounter = h.sleepThreshold, h.positionImpulse.x = 0, h.positionImpulse.y = 0, h.positionPrev.x = h.position.x, h.positionPrev.y = h.position.y, h.anglePrev = h.angle, h.speed = 0, h.angularSpeed = 0, h.motion = 0, f || l.trigger(h, "sleepStart")) : (h.isSleeping = !1, h.sleepCounter = 0, f && l.trigger(h, "sleepEnd")) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(9); (function () { var r = [], h = { overlap: 0, axis: null }, n = { overlap: 0, axis: null }; e.create = function (f, o) { return { pair: null, collided: !1, bodyA: f, bodyB: o, parentA: f.parent, parentB: o.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (f, o, t) { if (e._overlapAxes(h, f.vertices, o.vertices, f.axes), h.overlap <= 0 || (e._overlapAxes(n, o.vertices, f.vertices, o.axes), n.overlap <= 0)) return null; var s = t && t.table[l.id(f, o)], i; s ? i = s.collision : (i = e.create(f, o), i.collided = !0, i.bodyA = f.id < o.id ? f : o, i.bodyB = f.id < o.id ? o : f, i.parentA = i.bodyA.parent, i.parentB = i.bodyB.parent), f = i.bodyA, o = i.bodyB; var c; h.overlap < n.overlap ? c = h : c = n; var p = i.normal, y = i.tangent, w = i.penetration, O = i.supports, g = c.overlap, v = c.axis, m = v.x, d = v.y, P = o.position.x - f.position.x, S = o.position.y - f.position.y; m * P + d * S >= 0 && (m = -m, d = -d), p.x = m, p.y = d, y.x = -d, y.y = m, w.x = m * g, w.y = d * g, i.depth = g; var D = e._findSupports(f, o, p, 1), C = 0; if (a.contains(f.vertices, D[0]) && (O[C++] = D[0]), a.contains(f.vertices, D[1]) && (O[C++] = D[1]), C < 2) { var A = e._findSupports(o, f, p, -1); a.contains(o.vertices, A[0]) && (O[C++] = A[0]), C < 2 && a.contains(o.vertices, A[1]) && (O[C++] = A[1]) } return C === 0 && (O[C++] = D[0]), i.supportCount = C, i }, e._overlapAxes = function (f, o, t, s) { var i = o.length, c = t.length, p = o[0].x, y = o[0].y, w = t[0].x, O = t[0].y, g = s.length, v = Number.MAX_VALUE, m = 0, d, P, S, D, C, A; for (C = 0; C < g; C++) { var L = s[C], I = L.x, B = L.y, E = p * I + y * B, H = w * I + O * B, V = E, q = H; for (A = 1; A < i; A += 1)D = o[A].x * I + o[A].y * B, D > V ? V = D : D < E && (E = D); for (A = 1; A < c; A += 1)D = t[A].x * I + t[A].y * B, D > q ? q = D : D < H && (H = D); if (P = V - H, S = q - E, d = P < S ? P : S, d < v && (v = d, m = C, d <= 0)) break } f.axis = s[m], f.overlap = v }, e._findSupports = function (f, o, t, s) { var i = o.vertices, c = i.length, p = f.position.x, y = f.position.y, w = t.x * s, O = t.y * s, g = i[0], v = g, m = w * (p - v.x) + O * (y - v.y), d, P, S; for (S = 1; S < c; S += 1)v = i[S], P = w * (p - v.x) + O * (y - v.y), P < m && (m = P, g = v); return d = i[(c + g.index - 1) % c], m = w * (p - d.x) + O * (y - d.y), v = i[(g.index + 1) % c], w * (p - v.x) + O * (y - v.y) < m ? (r[0] = g, r[1] = v, r) : (r[0] = g, r[1] = d, r) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(16); (function () { e.create = function (l, r) { var h = l.bodyA, n = l.bodyB, f = { id: e.id(h, n), bodyA: h, bodyB: n, collision: l, contacts: [a.create(), a.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: h.isSensor || n.isSensor, timeCreated: r, timeUpdated: r, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(f, l, r), f }, e.update = function (l, r, h) { var n = r.supports, f = r.supportCount, o = l.contacts, t = r.parentA, s = r.parentB; l.isActive = !0, l.timeUpdated = h, l.collision = r, l.separation = r.depth, l.inverseMass = t.inverseMass + s.inverseMass, l.friction = t.friction < s.friction ? t.friction : s.friction, l.frictionStatic = t.frictionStatic > s.frictionStatic ? t.frictionStatic : s.frictionStatic, l.restitution = t.restitution > s.restitution ? t.restitution : s.restitution, l.slop = t.slop > s.slop ? t.slop : s.slop, l.contactCount = f, r.pair = l; var i = n[0], c = o[0], p = n[1], y = o[1]; (y.vertex === i || c.vertex === p) && (o[1] = c, o[0] = c = y, y = o[1]), c.vertex = i, y.vertex = p }, e.setActive = function (l, r, h) { r ? (l.isActive = !0, l.timeUpdated = h) : (l.isActive = !1, l.contactCount = 0) }, e.id = function (l, r) { return l.id < r.id ? l.id.toString(36) + ":" + r.id.toString(36) : r.id.toString(36) + ":" + l.id.toString(36) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(2), r = u(7), h = u(1), n = u(11), f = u(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (o) { var t = o; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var s = t.bodyA ? l.add(t.bodyA.position, t.pointA) : t.pointA, i = t.bodyB ? l.add(t.bodyB.position, t.pointB) : t.pointB, c = l.magnitude(l.sub(s, i)); t.length = typeof t.length < "u" ? t.length : c, t.id = t.id || f.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var p = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (p.type = "pin", p.anchors = !1) : t.stiffness < .9 && (p.type = "spring"), t.render = f.extend(p, t.render), t }, e.preSolveAll = function (o) { for (var t = 0; t < o.length; t += 1) { var s = o[t], i = s.constraintImpulse; s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0 || (s.position.x += i.x, s.position.y += i.y, s.angle += i.angle) } }, e.solveAll = function (o, t) { for (var s = f.clamp(t / f._baseDelta, 0, 1), i = 0; i < o.length; i += 1) { var c = o[i], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, y = !c.bodyB || c.bodyB && c.bodyB.isStatic; (p || y) && e.solve(o[i], s) } for (i = 0; i < o.length; i += 1)c = o[i], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, y = !c.bodyB || c.bodyB && c.bodyB.isStatic, !p && !y && e.solve(o[i], s) }, e.solve = function (o, t) { var s = o.bodyA, i = o.bodyB, c = o.pointA, p = o.pointB; if (!(!s && !i)) { s && !s.isStatic && (l.rotate(c, s.angle - o.angleA, c), o.angleA = s.angle), i && !i.isStatic && (l.rotate(p, i.angle - o.angleB, p), o.angleB = i.angle); var y = c, w = p; if (s && (y = l.add(s.position, c)), i && (w = l.add(i.position, p)), !(!y || !w)) { var O = l.sub(y, w), g = l.magnitude(O); g < e._minLength && (g = e._minLength); var v = (g - o.length) / g, m = o.stiffness >= 1 || o.length === 0, d = m ? o.stiffness * t : o.stiffness * t * t, P = o.damping * t, S = l.mult(O, v * d), D = (s ? s.inverseMass : 0) + (i ? i.inverseMass : 0), C = (s ? s.inverseInertia : 0) + (i ? i.inverseInertia : 0), A = D + C, L, I, B, E, H; if (P > 0) { var V = l.create(); B = l.div(O, g), H = l.sub(i && l.sub(i.position, i.positionPrev) || V, s && l.sub(s.position, s.positionPrev) || V), E = l.dot(B, H) } s && !s.isStatic && (I = s.inverseMass / D, s.constraintImpulse.x -= S.x * I, s.constraintImpulse.y -= S.y * I, s.position.x -= S.x * I, s.position.y -= S.y * I, P > 0 && (s.positionPrev.x -= P * B.x * E * I, s.positionPrev.y -= P * B.y * E * I), L = l.cross(c, S) / A * e._torqueDampen * s.inverseInertia * (1 - o.angularStiffness), s.constraintImpulse.angle -= L, s.angle -= L), i && !i.isStatic && (I = i.inverseMass / D, i.constraintImpulse.x += S.x * I, i.constraintImpulse.y += S.y * I, i.position.x += S.x * I, i.position.y += S.y * I, P > 0 && (i.positionPrev.x += P * B.x * E * I, i.positionPrev.y += P * B.y * E * I), L = l.cross(p, S) / A * e._torqueDampen * i.inverseInertia * (1 - o.angularStiffness), i.constraintImpulse.angle += L, i.angle += L) } } }, e.postSolveAll = function (o) { for (var t = 0; t < o.length; t++) { var s = o[t], i = s.constraintImpulse; if (!(s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0)) { r.set(s, !1); for (var c = 0; c < s.parts.length; c++) { var p = s.parts[c]; a.translate(p.vertices, i), c > 0 && (p.position.x += i.x, p.position.y += i.y), i.angle !== 0 && (a.rotate(p.vertices, i.angle, s.position), n.rotate(p.axes, i.angle), c > 0 && l.rotateAbout(p.position, i.angle, s.position, p.position)), h.update(p.bounds, p.vertices, s.velocity) } i.angle *= e._warming, i.x *= e._warming, i.y *= e._warming } } }, e.pointAWorld = function (o) { return { x: (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), y: (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0) } }, e.pointBWorld = function (o) { return { x: (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), y: (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0) } }, e.currentLength = function (o) { var t = (o.bodyA ? o.bodyA.position.x : 0) + (o.pointA ? o.pointA.x : 0), s = (o.bodyA ? o.bodyA.position.y : 0) + (o.pointA ? o.pointA.y : 0), i = (o.bodyB ? o.bodyB.position.x : 0) + (o.pointB ? o.pointB.x : 0), c = (o.bodyB ? o.bodyB.position.y : 0) + (o.pointB ? o.pointB.y : 0), p = t - i, y = s - c; return Math.sqrt(p * p + y * y) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(2), l = u(0); (function () { e.fromVertices = function (r) { for (var h = {}, n = 0; n < r.length; n++) { var f = (n + 1) % r.length, o = a.normalise({ x: r[f].y - r[n].y, y: r[n].x - r[f].x }), t = o.y === 0 ? 1 / 0 : o.x / o.y; t = t.toFixed(3).toString(), h[t] = o } return l.values(h) }, e.rotate = function (r, h) { if (h !== 0) for (var n = Math.cos(h), f = Math.sin(h), o = 0; o < r.length; o++) { var t = r[o], s; s = t.x * n - t.y * f, t.y = t.x * f + t.y * n, t.x = s } } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(0), r = u(4), h = u(1), n = u(2); (function () { e.rectangle = function (f, o, t, s, i) { i = i || {}; var c = { label: "Rectangle Body", position: { x: f, y: o }, vertices: a.fromPath("L 0 0 L " + t + " 0 L " + t + " " + s + " L 0 " + s) }; if (i.chamfer) { var p = i.chamfer; c.vertices = a.chamfer(c.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete i.chamfer } return r.create(l.extend({}, c, i)) }, e.trapezoid = function (f, o, t, s, i, c) { c = c || {}, i >= 1 && l.warn("Bodies.trapezoid: slope parameter must be < 1."), i *= .5; var p = (1 - i * 2) * t, y = t * i, w = y + p, O = w + y, g; i < .5 ? g = "L 0 0 L " + y + " " + -s + " L " + w + " " + -s + " L " + O + " 0" : g = "L 0 0 L " + w + " " + -s + " L " + O + " 0"; var v = { label: "Trapezoid Body", position: { x: f, y: o }, vertices: a.fromPath(g) }; if (c.chamfer) { var m = c.chamfer; v.vertices = a.chamfer(v.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete c.chamfer } return r.create(l.extend({}, v, c)) }, e.circle = function (f, o, t, s, i) { s = s || {}; var c = { label: "Circle Body", circleRadius: t }; i = i || 25; var p = Math.ceil(Math.max(10, Math.min(i, t))); return p % 2 === 1 && (p += 1), e.polygon(f, o, p, t, l.extend({}, c, s)) }, e.polygon = function (f, o, t, s, i) { if (i = i || {}, t < 3) return e.circle(f, o, s, i); for (var c = 2 * Math.PI / t, p = "", y = c * .5, w = 0; w < t; w += 1) { var O = y + w * c, g = Math.cos(O) * s, v = Math.sin(O) * s; p += "L " + g.toFixed(3) + " " + v.toFixed(3) + " " } var m = { label: "Polygon Body", position: { x: f, y: o }, vertices: a.fromPath(p) }; if (i.chamfer) { var d = i.chamfer; m.vertices = a.chamfer(m.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete i.chamfer } return r.create(l.extend({}, m, i)) }, e.fromVertices = function (f, o, t, s, i, c, p, y) { var w = l.getDecomp(), O, g, v, m, d, P, S, D, C, A, L; for (O = !!(w && w.quickDecomp), s = s || {}, v = [], i = typeof i < "u" ? i : !1, c = typeof c < "u" ? c : .01, p = typeof p < "u" ? p : 10, y = typeof y < "u" ? y : .01, l.isArray(t[0]) || (t = [t]), A = 0; A < t.length; A += 1)if (P = t[A], m = a.isConvex(P), d = !m, d && !O && l.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), m || !O) m ? P = a.clockwiseSort(P) : P = a.hull(P), v.push({ position: { x: f, y: o }, vertices: P }); else { var I = P.map(function (W) { return [W.x, W.y] }); w.makeCCW(I), c !== !1 && w.removeCollinearPoints(I, c), y !== !1 && w.removeDuplicatePoints && w.removeDuplicatePoints(I, y); var B = w.quickDecomp(I); for (S = 0; S < B.length; S++) { var E = B[S], H = E.map(function (W) { return { x: W[0], y: W[1] } }); p > 0 && a.area(H) < p || v.push({ position: a.centre(H), vertices: H }) } } for (S = 0; S < v.length; S++)v[S] = r.create(l.extend(v[S], s)); if (i) { var V = 5; for (S = 0; S < v.length; S++) { var q = v[S]; for (D = S + 1; D < v.length; D++) { var N = v[D]; if (h.overlaps(q.bounds, N.bounds)) { var z = q.vertices, X = N.vertices; for (C = 0; C < q.vertices.length; C++)for (L = 0; L < N.vertices.length; L++) { var ae = n.magnitudeSquared(n.sub(z[(C + 1) % z.length], X[L])), j = n.magnitudeSquared(n.sub(z[C], X[(L + 1) % X.length])); ae < V && j < V && (z[C].isInternal = !0, X[L].isInternal = !0) } } } } } return v.length > 1 ? (g = r.create(l.extend({ parts: v.slice(0) }, s)), r.setPosition(g, { x: f, y: o }), g) : v[0] } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(0), l = u(8); (function () { e.create = function (r) { var h = { bodies: [], collisions: [], pairs: null }; return a.extend(h, r) }, e.setBodies = function (r, h) { r.bodies = h.slice(0) }, e.clear = function (r) { r.bodies = [], r.collisions = [] }, e.collisions = function (r) { var h = r.pairs, n = r.bodies, f = n.length, o = e.canCollide, t = l.collides, s = r.collisions, i = 0, c, p; for (n.sort(e._compareBoundsX), c = 0; c < f; c++) { var y = n[c], w = y.bounds, O = y.bounds.max.x, g = y.bounds.max.y, v = y.bounds.min.y, m = y.isStatic || y.isSleeping, d = y.parts.length, P = d === 1; for (p = c + 1; p < f; p++) { var S = n[p], D = S.bounds; if (D.min.x > O) break; if (!(g < D.min.y || v > D.max.y) && !(m && (S.isStatic || S.isSleeping)) && o(y.collisionFilter, S.collisionFilter)) { var C = S.parts.length; if (P && C === 1) { var A = t(y, S, h); A && (s[i++] = A) } else for (var L = d > 1 ? 1 : 0, I = C > 1 ? 1 : 0, B = L; B < d; B++)for (var E = y.parts[B], w = E.bounds, H = I; H < C; H++) { var V = S.parts[H], D = V.bounds; if (!(w.min.x > D.max.x || w.max.x < D.min.x || w.max.y < D.min.y || w.min.y > D.max.y)) { var A = t(E, V, h); A && (s[i++] = A) } } } } } return s.length !== i && (s.length = i), s }, e.canCollide = function (r, h) { return r.group === h.group && r.group !== 0 ? r.group > 0 : (r.mask & h.category) !== 0 && (h.mask & r.category) !== 0 }, e._compareBoundsX = function (r, h) { return r.bounds.min.x - h.bounds.min.x } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(0); (function () { e.create = function (l) { var r = {}; return l || a.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), r.element = l || document.body, r.absolute = { x: 0, y: 0 }, r.position = { x: 0, y: 0 }, r.mousedownPosition = { x: 0, y: 0 }, r.mouseupPosition = { x: 0, y: 0 }, r.offset = { x: 0, y: 0 }, r.scale = { x: 1, y: 1 }, r.wheelDelta = 0, r.button = -1, r.pixelRatio = parseInt(r.element.getAttribute("data-pixel-ratio"), 10) || 1, r.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, r.mousemove = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), f = h.changedTouches; f && (r.button = 0, h.preventDefault()), r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.sourceEvents.mousemove = h }, r.mousedown = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), f = h.changedTouches; f ? (r.button = 0, h.preventDefault()) : r.button = h.button, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mousedownPosition.x = r.position.x, r.mousedownPosition.y = r.position.y, r.sourceEvents.mousedown = h }, r.mouseup = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), f = h.changedTouches; f && h.preventDefault(), r.button = -1, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mouseupPosition.x = r.position.x, r.mouseupPosition.y = r.position.y, r.sourceEvents.mouseup = h }, r.mousewheel = function (h) { r.wheelDelta = Math.max(-1, Math.min(1, h.wheelDelta || -h.detail)), h.preventDefault(), r.sourceEvents.mousewheel = h }, e.setElement(r, r.element), r }, e.setElement = function (l, r) { l.element = r, r.addEventListener("mousemove", l.mousemove, { passive: !0 }), r.addEventListener("mousedown", l.mousedown, { passive: !0 }), r.addEventListener("mouseup", l.mouseup, { passive: !0 }), r.addEventListener("wheel", l.mousewheel, { passive: !1 }), r.addEventListener("touchmove", l.mousemove, { passive: !1 }), r.addEventListener("touchstart", l.mousedown, { passive: !1 }), r.addEventListener("touchend", l.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (l) { l.sourceEvents.mousemove = null, l.sourceEvents.mousedown = null, l.sourceEvents.mouseup = null, l.sourceEvents.mousewheel = null, l.wheelDelta = 0 }, e.setOffset = function (l, r) { l.offset.x = r.x, l.offset.y = r.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y }, e.setScale = function (l, r) { l.scale.x = r.x, l.scale.y = r.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y }, e._getRelativeMousePosition = function (l, r, h) { var n = r.getBoundingClientRect(), f = document.documentElement || document.body.parentNode || document.body, o = window.pageXOffset !== void 0 ? window.pageXOffset : f.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : f.scrollTop, s = l.changedTouches, i, c; return s ? (i = s[0].pageX - n.left - o, c = s[0].pageY - n.top - t) : (i = l.pageX - n.left - o, c = l.pageY - n.top - t), { x: i / (r.clientWidth / (r.width || r.clientWidth) * h), y: c / (r.clientHeight / (r.height || r.clientHeight) * h) } } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(0); (function () { e._registry = {}, e.register = function (l) { if (e.isPlugin(l) || a.warn("Plugin.register:", e.toString(l), "does not implement all required fields."), l.name in e._registry) { var r = e._registry[l.name], h = e.versionParse(l.version).number, n = e.versionParse(r.version).number; h > n ? (a.warn("Plugin.register:", e.toString(r), "was upgraded to", e.toString(l)), e._registry[l.name] = l) : h < n ? a.warn("Plugin.register:", e.toString(r), "can not be downgraded to", e.toString(l)) : l !== r && a.warn("Plugin.register:", e.toString(l), "is already registered to different plugin object") } else e._registry[l.name] = l; return l }, e.resolve = function (l) { return e._registry[e.dependencyParse(l).name] }, e.toString = function (l) { return typeof l == "string" ? l : (l.name || "anonymous") + "@" + (l.version || l.range || "0.0.0") }, e.isPlugin = function (l) { return l && l.name && l.version && l.install }, e.isUsed = function (l, r) { return l.used.indexOf(r) > -1 }, e.isFor = function (l, r) { var h = l.for && e.dependencyParse(l.for); return !l.for || r.name === h.name && e.versionSatisfies(r.version, h.range) }, e.use = function (l, r) { if (l.uses = (l.uses || []).concat(r || []), l.uses.length === 0) { a.warn("Plugin.use:", e.toString(l), "does not specify any dependencies to install."); return } for (var h = e.dependencies(l), n = a.topologicalSort(h), f = [], o = 0; o < n.length; o += 1)if (n[o] !== l.name) { var t = e.resolve(n[o]); if (!t) { f.push("❌ " + n[o]); continue } e.isUsed(l, t.name) || (e.isFor(t, l) || (a.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(l) + "."), t._warned = !0), t.install ? t.install(l) : (a.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (f.push("🔶 " + e.toString(t)), delete t._warned) : f.push("✅ " + e.toString(t)), l.used.push(t.name)) } f.length > 0 && a.info(f.join("  ")) }, e.dependencies = function (l, r) { var h = e.dependencyParse(l), n = h.name; if (r = r || {}, !(n in r)) { l = e.resolve(l) || l, r[n] = a.map(l.uses || [], function (o) { e.isPlugin(o) && e.register(o); var t = e.dependencyParse(o), s = e.resolve(o); return s && !e.versionSatisfies(s.version, t.range) ? (a.warn("Plugin.dependencies:", e.toString(s), "does not satisfy", e.toString(t), "used by", e.toString(h) + "."), s._warned = !0, l._warned = !0) : s || (a.warn("Plugin.dependencies:", e.toString(o), "used by", e.toString(h), "could not be resolved."), l._warned = !0), t.name }); for (var f = 0; f < r[n].length; f += 1)e.dependencies(r[n][f], r); return r } }, e.dependencyParse = function (l) { if (a.isString(l)) { var r = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return r.test(l) || a.warn("Plugin.dependencyParse:", l, "is not a valid dependency string."), { name: l.split("@")[0], range: l.split("@")[1] || "*" } } return { name: l.name, range: l.range || l.version } }, e.versionParse = function (l) { var r = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; r.test(l) || a.warn("Plugin.versionParse:", l, "is not a valid version or range."); var h = r.exec(l), n = Number(h[4]), f = Number(h[5]), o = Number(h[6]); return { isRange: !!(h[1] || h[2]), version: h[3], range: l, operator: h[1] || h[2] || "", major: n, minor: f, patch: o, parts: [n, f, o], prerelease: h[7], number: n * 1e8 + f * 1e4 + o } }, e.versionSatisfies = function (l, r) { r = r || "*"; var h = e.versionParse(r), n = e.versionParse(l); if (h.isRange) { if (h.operator === "*" || l === "*") return !0; if (h.operator === ">") return n.number > h.number; if (h.operator === ">=") return n.number >= h.number; if (h.operator === "~") return n.major === h.major && n.minor === h.minor && n.patch >= h.patch; if (h.operator === "^") return h.major > 0 ? n.major === h.major && n.number >= h.number : h.minor > 0 ? n.minor === h.minor && n.patch >= h.patch : n.patch === h.patch } return l === r || l === "*" } })() }, function (x, T) { var u = {}; x.exports = u, function () { u.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(7), l = u(18), r = u(13), h = u(19), n = u(5), f = u(6), o = u(10), t = u(0), s = u(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (i) { i = i || {}; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, p = t.extend(c, i); return p.world = i.world || f.create({ label: "World" }), p.pairs = i.pairs || h.create(), p.detector = i.detector || r.create(), p.detector.pairs = p.pairs, p.grid = { buckets: [] }, p.world.gravity = p.gravity, p.broadphase = p.grid, p.metrics = {}, p }, e.update = function (i, c) { var p = t.now(), y = i.world, w = i.detector, O = i.pairs, g = i.timing, v = g.timestamp, m; c > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), c = typeof c < "u" ? c : t._baseDelta, c *= g.timeScale, g.timestamp += c, g.lastDelta = c; var d = { timestamp: g.timestamp, delta: c }; n.trigger(i, "beforeUpdate", d); var P = f.allBodies(y), S = f.allConstraints(y); for (y.isModified && (r.setBodies(w, P), f.setModified(y, !1, !1, !0)), i.enableSleeping && a.update(P, c), e._bodiesApplyGravity(P, i.gravity), c > 0 && e._bodiesUpdate(P, c), n.trigger(i, "beforeSolve", d), o.preSolveAll(P), m = 0; m < i.constraintIterations; m++)o.solveAll(S, c); o.postSolveAll(P); var D = r.collisions(w); h.update(O, D, v), i.enableSleeping && a.afterCollisions(O.list), O.collisionStart.length > 0 && n.trigger(i, "collisionStart", { pairs: O.collisionStart, timestamp: g.timestamp, delta: c }); var C = t.clamp(20 / i.positionIterations, 0, 1); for (l.preSolvePosition(O.list), m = 0; m < i.positionIterations; m++)l.solvePosition(O.list, c, C); for (l.postSolvePosition(P), o.preSolveAll(P), m = 0; m < i.constraintIterations; m++)o.solveAll(S, c); for (o.postSolveAll(P), l.preSolveVelocity(O.list), m = 0; m < i.velocityIterations; m++)l.solveVelocity(O.list, c); return e._bodiesUpdateVelocities(P), O.collisionActive.length > 0 && n.trigger(i, "collisionActive", { pairs: O.collisionActive, timestamp: g.timestamp, delta: c }), O.collisionEnd.length > 0 && n.trigger(i, "collisionEnd", { pairs: O.collisionEnd, timestamp: g.timestamp, delta: c }), e._bodiesClearForces(P), n.trigger(i, "afterUpdate", d), i.timing.lastElapsed = t.now() - p, i }, e.merge = function (i, c) { if (t.extend(i, c), c.world) { i.world = c.world, e.clear(i); for (var p = f.allBodies(i.world), y = 0; y < p.length; y++) { var w = p[y]; a.set(w, !1), w.id = t.nextId() } } }, e.clear = function (i) { h.clear(i.pairs), r.clear(i.detector) }, e._bodiesClearForces = function (i) { for (var c = i.length, p = 0; p < c; p++) { var y = i[p]; y.force.x = 0, y.force.y = 0, y.torque = 0 } }, e._bodiesApplyGravity = function (i, c) { var p = typeof c.scale < "u" ? c.scale : .001, y = i.length; if (!(c.x === 0 && c.y === 0 || p === 0)) for (var w = 0; w < y; w++) { var O = i[w]; O.isStatic || O.isSleeping || (O.force.y += O.mass * c.y * p, O.force.x += O.mass * c.x * p) } }, e._bodiesUpdate = function (i, c) { for (var p = i.length, y = 0; y < p; y++) { var w = i[y]; w.isStatic || w.isSleeping || s.update(w, c) } }, e._bodiesUpdateVelocities = function (i) { for (var c = i.length, p = 0; p < c; p++)s.updateVelocities(i[p]) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(0), r = u(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (h) { var n, f, o, t = h.length; for (n = 0; n < t; n++)f = h[n], f.isActive && (o = f.contactCount, f.collision.parentA.totalContacts += o, f.collision.parentB.totalContacts += o) }, e.solvePosition = function (h, n, f) { var o, t, s, i, c, p, y, w, O = e._positionDampen * (f || 1), g = l.clamp(n / l._baseDelta, 0, 1), v = h.length; for (o = 0; o < v; o++)t = h[o], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, c = s.parentB, p = s.normal, t.separation = s.depth + p.x * (c.positionImpulse.x - i.positionImpulse.x) + p.y * (c.positionImpulse.y - i.positionImpulse.y)); for (o = 0; o < v; o++)t = h[o], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, c = s.parentB, p = s.normal, w = t.separation - t.slop * g, (i.isStatic || c.isStatic) && (w *= 2), i.isStatic || i.isSleeping || (y = O / i.totalContacts, i.positionImpulse.x += p.x * w * y, i.positionImpulse.y += p.y * w * y), c.isStatic || c.isSleeping || (y = O / c.totalContacts, c.positionImpulse.x -= p.x * w * y, c.positionImpulse.y -= p.y * w * y)) }, e.postSolvePosition = function (h) { for (var n = e._positionWarming, f = h.length, o = a.translate, t = r.update, s = 0; s < f; s++) { var i = h[s], c = i.positionImpulse, p = c.x, y = c.y, w = i.velocity; if (i.totalContacts = 0, p !== 0 || y !== 0) { for (var O = 0; O < i.parts.length; O++) { var g = i.parts[O]; o(g.vertices, c), t(g.bounds, g.vertices, w), g.position.x += p, g.position.y += y } i.positionPrev.x += p, i.positionPrev.y += y, p * w.x + y * w.y < 0 ? (c.x = 0, c.y = 0) : (c.x *= n, c.y *= n) } } }, e.preSolveVelocity = function (h) { var n = h.length, f, o; for (f = 0; f < n; f++) { var t = h[f]; if (!(!t.isActive || t.isSensor)) { var s = t.contacts, i = t.contactCount, c = t.collision, p = c.parentA, y = c.parentB, w = c.normal, O = c.tangent; for (o = 0; o < i; o++) { var g = s[o], v = g.vertex, m = g.normalImpulse, d = g.tangentImpulse; if (m !== 0 || d !== 0) { var P = w.x * m + O.x * d, S = w.y * m + O.y * d; p.isStatic || p.isSleeping || (p.positionPrev.x += P * p.inverseMass, p.positionPrev.y += S * p.inverseMass, p.anglePrev += p.inverseInertia * ((v.x - p.position.x) * S - (v.y - p.position.y) * P)), y.isStatic || y.isSleeping || (y.positionPrev.x -= P * y.inverseMass, y.positionPrev.y -= S * y.inverseMass, y.anglePrev -= y.inverseInertia * ((v.x - y.position.x) * S - (v.y - y.position.y) * P)) } } } } }, e.solveVelocity = function (h, n) { var f = n / l._baseDelta, o = f * f, t = o * f, s = -e._restingThresh * f, i = e._restingThreshTangent, c = e._frictionNormalMultiplier * f, p = e._frictionMaxStatic, y = h.length, w, O, g, v; for (g = 0; g < y; g++) { var m = h[g]; if (!(!m.isActive || m.isSensor)) { var d = m.collision, P = d.parentA, S = d.parentB, D = d.normal.x, C = d.normal.y, A = d.tangent.x, L = d.tangent.y, I = m.inverseMass, B = m.friction * m.frictionStatic * c, E = m.contacts, H = m.contactCount, V = 1 / H, q = P.position.x - P.positionPrev.x, N = P.position.y - P.positionPrev.y, z = P.angle - P.anglePrev, X = S.position.x - S.positionPrev.x, ae = S.position.y - S.positionPrev.y, j = S.angle - S.anglePrev; for (v = 0; v < H; v++) { var W = E[v], _ = W.vertex, $ = _.x - P.position.x, ue = _.y - P.position.y, ee = _.x - S.position.x, te = _.y - S.position.y, K = q - ue * z, je = N + $ * z, _e = X - te * j, et = ae + ee * j, Ie = K - _e, Le = je - et, ye = D * Ie + C * Le, re = A * Ie + L * Le, Ee = m.separation + ye, Se = Math.min(Ee, 1); Se = Ee < 0 ? 0 : Se; var Be = Se * B; re < -Be || re > Be ? (O = re > 0 ? re : -re, w = m.friction * (re > 0 ? 1 : -1) * t, w < -O ? w = -O : w > O && (w = O)) : (w = re, O = p); var Re = $ * C - ue * D, ke = ee * C - te * D, Fe = V / (I + P.inverseInertia * Re * Re + S.inverseInertia * ke * ke), de = (1 + m.restitution) * ye * Fe; if (w *= Fe, ye < s) W.normalImpulse = 0; else { var tt = W.normalImpulse; W.normalImpulse += de, W.normalImpulse > 0 && (W.normalImpulse = 0), de = W.normalImpulse - tt } if (re < -i || re > i) W.tangentImpulse = 0; else { var it = W.tangentImpulse; W.tangentImpulse += w, W.tangentImpulse < -O && (W.tangentImpulse = -O), W.tangentImpulse > O && (W.tangentImpulse = O), w = W.tangentImpulse - it } var ve = D * de + A * w, me = C * de + L * w; P.isStatic || P.isSleeping || (P.positionPrev.x += ve * P.inverseMass, P.positionPrev.y += me * P.inverseMass, P.anglePrev += ($ * me - ue * ve) * P.inverseInertia), S.isStatic || S.isSleeping || (S.positionPrev.x -= ve * S.inverseMass, S.positionPrev.y -= me * S.inverseMass, S.anglePrev -= (ee * me - te * ve) * S.inverseInertia) } } } } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(9), l = u(0); (function () { e.create = function (r) { return l.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, r) }, e.update = function (r, h, n) { var f = a.update, o = a.create, t = a.setActive, s = r.table, i = r.list, c = i.length, p = c, y = r.collisionStart, w = r.collisionEnd, O = r.collisionActive, g = h.length, v = 0, m = 0, d = 0, P, S, D; for (D = 0; D < g; D++)P = h[D], S = P.pair, S ? (S.isActive && (O[d++] = S), f(S, P, n)) : (S = o(P, n), s[S.id] = S, y[v++] = S, i[p++] = S); for (p = 0, c = i.length, D = 0; D < c; D++)S = i[D], S.timeUpdated >= n ? i[p++] = S : (t(S, !1, n), S.collision.bodyA.sleepCounter > 0 && S.collision.bodyB.sleepCounter > 0 ? i[p++] = S : (w[m++] = S, delete s[S.id])); i.length !== p && (i.length = p), y.length !== v && (y.length = v), w.length !== m && (w.length = m), O.length !== d && (O.length = d) }, e.clear = function (r) { return r.table = {}, r.list.length = 0, r.collisionStart.length = 0, r.collisionActive.length = 0, r.collisionEnd.length = 0, r } })() }, function (x, T, u) { var e = x.exports = u(21); e.Axes = u(11), e.Bodies = u(12), e.Body = u(4), e.Bounds = u(1), e.Collision = u(8), e.Common = u(0), e.Composite = u(6), e.Composites = u(22), e.Constraint = u(10), e.Contact = u(16), e.Detector = u(13), e.Engine = u(17), e.Events = u(5), e.Grid = u(23), e.Mouse = u(14), e.MouseConstraint = u(24), e.Pair = u(9), e.Pairs = u(19), e.Plugin = u(15), e.Query = u(25), e.Render = u(26), e.Resolver = u(18), e.Runner = u(27), e.SAT = u(28), e.Sleeping = u(7), e.Svg = u(29), e.Vector = u(2), e.Vertices = u(3), e.World = u(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function (x, T, u) { var e = {}; x.exports = e; var a = u(15), l = u(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { a.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (r, h) { return r = r.replace(/^Matter./, ""), l.chainPathBefore(e, r, h) }, e.after = function (r, h) { return r = r.replace(/^Matter./, ""), l.chainPathAfter(e, r, h) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(6), l = u(10), r = u(0), h = u(4), n = u(12), f = r.deprecated; (function () { e.stack = function (o, t, s, i, c, p, y) { for (var w = a.create({ label: "Stack" }), O = o, g = t, v, m = 0, d = 0; d < i; d++) { for (var P = 0, S = 0; S < s; S++) { var D = y(O, g, S, d, v, m); if (D) { var C = D.bounds.max.y - D.bounds.min.y, A = D.bounds.max.x - D.bounds.min.x; C > P && (P = C), h.translate(D, { x: A * .5, y: C * .5 }), O = D.bounds.max.x + c, a.addBody(w, D), v = D, m += 1 } else O += c } g += P + p, O = o } return w }, e.chain = function (o, t, s, i, c, p) { for (var y = o.bodies, w = 1; w < y.length; w++) { var O = y[w - 1], g = y[w], v = O.bounds.max.y - O.bounds.min.y, m = O.bounds.max.x - O.bounds.min.x, d = g.bounds.max.y - g.bounds.min.y, P = g.bounds.max.x - g.bounds.min.x, S = { bodyA: O, pointA: { x: m * t, y: v * s }, bodyB: g, pointB: { x: P * i, y: d * c } }, D = r.extend(S, p); a.addConstraint(o, l.create(D)) } return o.label += " Chain", o }, e.mesh = function (o, t, s, i, c) { var p = o.bodies, y, w, O, g, v; for (y = 0; y < s; y++) { for (w = 1; w < t; w++)O = p[w - 1 + y * t], g = p[w + y * t], a.addConstraint(o, l.create(r.extend({ bodyA: O, bodyB: g }, c))); if (y > 0) for (w = 0; w < t; w++)O = p[w + (y - 1) * t], g = p[w + y * t], a.addConstraint(o, l.create(r.extend({ bodyA: O, bodyB: g }, c))), i && w > 0 && (v = p[w - 1 + (y - 1) * t], a.addConstraint(o, l.create(r.extend({ bodyA: v, bodyB: g }, c)))), i && w < t - 1 && (v = p[w + 1 + (y - 1) * t], a.addConstraint(o, l.create(r.extend({ bodyA: v, bodyB: g }, c)))) } return o.label += " Mesh", o }, e.pyramid = function (o, t, s, i, c, p, y) { return e.stack(o, t, s, i, c, p, function (w, O, g, v, m, d) { var P = Math.min(i, Math.ceil(s / 2)), S = m ? m.bounds.max.x - m.bounds.min.x : 0; if (!(v > P)) { v = P - v; var D = v, C = s - 1 - v; if (!(g < D || g > C)) { d === 1 && h.translate(m, { x: (g + (s % 2 === 1 ? 1 : -1)) * S, y: 0 }); var A = m ? g * S : 0; return y(o + A + g * c, O, g, v, m, d) } } }) }, e.newtonsCradle = function (o, t, s, i, c) { for (var p = a.create({ label: "Newtons Cradle" }), y = 0; y < s; y++) { var w = 1.9, O = n.circle(o + y * (i * w), t + c, i, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), g = l.create({ pointA: { x: o + y * (i * w), y: t }, bodyB: O }); a.addBody(p, O), a.addConstraint(p, g) } return p }, f(e, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), e.car = function (o, t, s, i, c) { var p = h.nextGroup(!0), y = 20, w = -s * .5 + y, O = s * .5 - y, g = 0, v = a.create({ label: "Car" }), m = n.rectangle(o, t, s, i, { collisionFilter: { group: p }, chamfer: { radius: i * .5 }, density: 2e-4 }), d = n.circle(o + w, t + g, c, { collisionFilter: { group: p }, friction: .8 }), P = n.circle(o + O, t + g, c, { collisionFilter: { group: p }, friction: .8 }), S = l.create({ bodyB: m, pointB: { x: w, y: g }, bodyA: d, stiffness: 1, length: 0 }), D = l.create({ bodyB: m, pointB: { x: O, y: g }, bodyA: P, stiffness: 1, length: 0 }); return a.addBody(v, m), a.addBody(v, d), a.addBody(v, P), a.addConstraint(v, S), a.addConstraint(v, D), v }, f(e, "car", "Composites.car ➤ moved to car example"), e.softBody = function (o, t, s, i, c, p, y, w, O, g) { O = r.extend({ inertia: 1 / 0 }, O), g = r.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, g); var v = e.stack(o, t, s, i, c, p, function (m, d) { return n.circle(m, d, w, O) }); return e.mesh(v, s, i, y, g), v.label = "Soft Body", v }, f(e, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(9), l = u(0), r = l.deprecated; (function () { e.create = function (h) { var n = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return l.extend(n, h) }, e.update = function (h, n, f, o) { var t, s, i, c = f.world, p = h.buckets, y, w, O = !1; for (t = 0; t < n.length; t++) { var g = n[t]; if (!(g.isSleeping && !o) && !(c.bounds && (g.bounds.max.x < c.bounds.min.x || g.bounds.min.x > c.bounds.max.x || g.bounds.max.y < c.bounds.min.y || g.bounds.min.y > c.bounds.max.y))) { var v = e._getRegion(h, g); if (!g.region || v.id !== g.region.id || o) { (!g.region || o) && (g.region = v); var m = e._regionUnion(v, g.region); for (s = m.startCol; s <= m.endCol; s++)for (i = m.startRow; i <= m.endRow; i++) { w = e._getBucketId(s, i), y = p[w]; var d = s >= v.startCol && s <= v.endCol && i >= v.startRow && i <= v.endRow, P = s >= g.region.startCol && s <= g.region.endCol && i >= g.region.startRow && i <= g.region.endRow; !d && P && P && y && e._bucketRemoveBody(h, y, g), (g.region === v || d && !P || o) && (y || (y = e._createBucket(p, w)), e._bucketAddBody(h, y, g)) } g.region = v, O = !0 } } } O && (h.pairsList = e._createActivePairsList(h)) }, r(e, "update", "Grid.update ➤ replaced by Matter.Detector"), e.clear = function (h) { h.buckets = {}, h.pairs = {}, h.pairsList = [] }, r(e, "clear", "Grid.clear ➤ replaced by Matter.Detector"), e._regionUnion = function (h, n) { var f = Math.min(h.startCol, n.startCol), o = Math.max(h.endCol, n.endCol), t = Math.min(h.startRow, n.startRow), s = Math.max(h.endRow, n.endRow); return e._createRegion(f, o, t, s) }, e._getRegion = function (h, n) { var f = n.bounds, o = Math.floor(f.min.x / h.bucketWidth), t = Math.floor(f.max.x / h.bucketWidth), s = Math.floor(f.min.y / h.bucketHeight), i = Math.floor(f.max.y / h.bucketHeight); return e._createRegion(o, t, s, i) }, e._createRegion = function (h, n, f, o) { return { id: h + "," + n + "," + f + "," + o, startCol: h, endCol: n, startRow: f, endRow: o } }, e._getBucketId = function (h, n) { return "C" + h + "R" + n }, e._createBucket = function (h, n) { var f = h[n] = []; return f }, e._bucketAddBody = function (h, n, f) { var o = h.pairs, t = a.id, s = n.length, i; for (i = 0; i < s; i++) { var c = n[i]; if (!(f.id === c.id || f.isStatic && c.isStatic)) { var p = t(f, c), y = o[p]; y ? y[2] += 1 : o[p] = [f, c, 1] } } n.push(f) }, e._bucketRemoveBody = function (h, n, f) { var o = h.pairs, t = a.id, s; n.splice(l.indexOf(n, f), 1); var i = n.length; for (s = 0; s < i; s++) { var c = o[t(f, n[s])]; c && (c[2] -= 1) } }, e._createActivePairsList = function (h) { var n, f = h.pairs, o = l.keys(f), t = o.length, s = [], i; for (i = 0; i < t; i++)n = f[o[i]], n[2] > 0 ? s.push(n) : delete f[o[i]]; return s } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(3), l = u(7), r = u(14), h = u(5), n = u(13), f = u(10), o = u(6), t = u(0), s = u(1); (function () { e.create = function (i, c) { var p = (i ? i.mouse : null) || (c ? c.mouse : null); p || (i && i.render && i.render.canvas ? p = r.create(i.render.canvas) : c && c.element ? p = r.create(c.element) : (p = r.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var y = f.create({ label: "Mouse Constraint", pointA: p.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), w = { type: "mouseConstraint", mouse: p, element: null, body: null, constraint: y, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, O = t.extend(w, c); return h.on(i, "beforeUpdate", function () { var g = o.allBodies(i.world); e.update(O, g), e._triggerEvents(O) }), O }, e.update = function (i, c) { var p = i.mouse, y = i.constraint, w = i.body; if (p.button === 0) { if (y.bodyB) l.set(y.bodyB, !1), y.pointA = p.position; else for (var O = 0; O < c.length; O++)if (w = c[O], s.contains(w.bounds, p.position) && n.canCollide(w.collisionFilter, i.collisionFilter)) for (var g = w.parts.length > 1 ? 1 : 0; g < w.parts.length; g++) { var v = w.parts[g]; if (a.contains(v.vertices, p.position)) { y.pointA = p.position, y.bodyB = i.body = w, y.pointB = { x: p.position.x - w.position.x, y: p.position.y - w.position.y }, y.angleB = w.angle, l.set(w, !1), h.trigger(i, "startdrag", { mouse: p, body: w }); break } } } else y.bodyB = i.body = null, y.pointB = null, w && h.trigger(i, "enddrag", { mouse: p, body: w }) }, e._triggerEvents = function (i) { var c = i.mouse, p = c.sourceEvents; p.mousemove && h.trigger(i, "mousemove", { mouse: c }), p.mousedown && h.trigger(i, "mousedown", { mouse: c }), p.mouseup && h.trigger(i, "mouseup", { mouse: c }), r.clearSourceEvents(c) } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(2), l = u(8), r = u(1), h = u(12), n = u(3); (function () { e.collides = function (f, o) { for (var t = [], s = o.length, i = f.bounds, c = l.collides, p = r.overlaps, y = 0; y < s; y++) { var w = o[y], O = w.parts.length, g = O === 1 ? 0 : 1; if (p(w.bounds, i)) for (var v = g; v < O; v++) { var m = w.parts[v]; if (p(m.bounds, i)) { var d = c(m, f); if (d) { t.push(d); break } } } } return t }, e.ray = function (f, o, t, s) { s = s || 1e-100; for (var i = a.angle(o, t), c = a.magnitude(a.sub(o, t)), p = (t.x + o.x) * .5, y = (t.y + o.y) * .5, w = h.rectangle(p, y, c, s, { angle: i }), O = e.collides(w, f), g = 0; g < O.length; g += 1) { var v = O[g]; v.body = v.bodyB = v.bodyA } return O }, e.region = function (f, o, t) { for (var s = [], i = 0; i < f.length; i++) { var c = f[i], p = r.overlaps(c.bounds, o); (p && !t || !p && t) && s.push(c) } return s }, e.point = function (f, o) { for (var t = [], s = 0; s < f.length; s++) { var i = f[s]; if (r.contains(i.bounds, o)) for (var c = i.parts.length === 1 ? 0 : 1; c < i.parts.length; c++) { var p = i.parts[c]; if (r.contains(p.bounds, o) && n.contains(p.vertices, o)) { t.push(i); break } } } return t } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(4), l = u(0), r = u(6), h = u(1), n = u(5), f = u(2), o = u(14); (function () { var t, s; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (g) { window.setTimeout(function () { g(l.now()) }, 1e3 / 60) }, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (g) { var v = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!g.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, m = l.extend(v, g); return m.canvas && (m.canvas.width = m.options.width || m.canvas.width, m.canvas.height = m.options.height || m.canvas.height), m.mouse = g.mouse, m.engine = g.engine, m.canvas = m.canvas || p(m.options.width, m.options.height), m.context = m.canvas.getContext("2d"), m.textures = {}, m.bounds = m.bounds || { min: { x: 0, y: 0 }, max: { x: m.canvas.width, y: m.canvas.height } }, m.controller = e, m.options.showBroadphase = !1, m.options.pixelRatio !== 1 && e.setPixelRatio(m, m.options.pixelRatio), l.isElement(m.element) && m.element.appendChild(m.canvas), m }, e.run = function (g) { (function v(m) { g.frameRequestId = t(v), i(g, m), e.world(g, m), g.context.setTransform(g.options.pixelRatio, 0, 0, g.options.pixelRatio, 0, 0), (g.options.showStats || g.options.showDebug) && e.stats(g, g.context, m), (g.options.showPerformance || g.options.showDebug) && e.performance(g, g.context, m), g.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (g) { s(g.frameRequestId) }, e.setPixelRatio = function (g, v) { var m = g.options, d = g.canvas; v === "auto" && (v = y(d)), m.pixelRatio = v, d.setAttribute("data-pixel-ratio", v), d.width = m.width * v, d.height = m.height * v, d.style.width = m.width + "px", d.style.height = m.height + "px" }, e.setSize = function (g, v, m) { g.options.width = v, g.options.height = m, g.bounds.max.x = g.bounds.min.x + v, g.bounds.max.y = g.bounds.min.y + m, g.options.pixelRatio !== 1 ? e.setPixelRatio(g, g.options.pixelRatio) : (g.canvas.width = v, g.canvas.height = m) }, e.lookAt = function (g, v, m, d) { d = typeof d < "u" ? d : !0, v = l.isArray(v) ? v : [v], m = m || { x: 0, y: 0 }; for (var P = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, S = 0; S < v.length; S += 1) { var D = v[S], C = D.bounds ? D.bounds.min : D.min || D.position || D, A = D.bounds ? D.bounds.max : D.max || D.position || D; C && A && (C.x < P.min.x && (P.min.x = C.x), A.x > P.max.x && (P.max.x = A.x), C.y < P.min.y && (P.min.y = C.y), A.y > P.max.y && (P.max.y = A.y)) } var L = P.max.x - P.min.x + 2 * m.x, I = P.max.y - P.min.y + 2 * m.y, B = g.canvas.height, E = g.canvas.width, H = E / B, V = L / I, q = 1, N = 1; V > H ? N = V / H : q = H / V, g.options.hasBounds = !0, g.bounds.min.x = P.min.x, g.bounds.max.x = P.min.x + L * q, g.bounds.min.y = P.min.y, g.bounds.max.y = P.min.y + I * N, d && (g.bounds.min.x += L * .5 - L * q * .5, g.bounds.max.x += L * .5 - L * q * .5, g.bounds.min.y += I * .5 - I * N * .5, g.bounds.max.y += I * .5 - I * N * .5), g.bounds.min.x -= m.x, g.bounds.max.x -= m.x, g.bounds.min.y -= m.y, g.bounds.max.y -= m.y, g.mouse && (o.setScale(g.mouse, { x: (g.bounds.max.x - g.bounds.min.x) / g.canvas.width, y: (g.bounds.max.y - g.bounds.min.y) / g.canvas.height }), o.setOffset(g.mouse, g.bounds.min)) }, e.startViewTransform = function (g) { var v = g.bounds.max.x - g.bounds.min.x, m = g.bounds.max.y - g.bounds.min.y, d = v / g.options.width, P = m / g.options.height; g.context.setTransform(g.options.pixelRatio / d, 0, 0, g.options.pixelRatio / P, 0, 0), g.context.translate(-g.bounds.min.x, -g.bounds.min.y) }, e.endViewTransform = function (g) { g.context.setTransform(g.options.pixelRatio, 0, 0, g.options.pixelRatio, 0, 0) }, e.world = function (g, v) { var m = l.now(), d = g.engine, P = d.world, S = g.canvas, D = g.context, C = g.options, A = g.timing, L = r.allBodies(P), I = r.allConstraints(P), B = C.wireframes ? C.wireframeBackground : C.background, E = [], H = [], V, q = { timestamp: d.timing.timestamp }; if (n.trigger(g, "beforeRender", q), g.currentBackground !== B && O(g, B), D.globalCompositeOperation = "source-in", D.fillStyle = "transparent", D.fillRect(0, 0, S.width, S.height), D.globalCompositeOperation = "source-over", C.hasBounds) { for (V = 0; V < L.length; V++) { var N = L[V]; h.overlaps(N.bounds, g.bounds) && E.push(N) } for (V = 0; V < I.length; V++) { var z = I[V], X = z.bodyA, ae = z.bodyB, j = z.pointA, W = z.pointB; X && (j = f.add(X.position, z.pointA)), ae && (W = f.add(ae.position, z.pointB)), !(!j || !W) && (h.contains(g.bounds, j) || h.contains(g.bounds, W)) && H.push(z) } e.startViewTransform(g), g.mouse && (o.setScale(g.mouse, { x: (g.bounds.max.x - g.bounds.min.x) / g.options.width, y: (g.bounds.max.y - g.bounds.min.y) / g.options.height }), o.setOffset(g.mouse, g.bounds.min)) } else H = I, E = L, g.options.pixelRatio !== 1 && g.context.setTransform(g.options.pixelRatio, 0, 0, g.options.pixelRatio, 0, 0); !C.wireframes || d.enableSleeping && C.showSleeping ? e.bodies(g, E, D) : (C.showConvexHulls && e.bodyConvexHulls(g, E, D), e.bodyWireframes(g, E, D)), C.showBounds && e.bodyBounds(g, E, D), (C.showAxes || C.showAngleIndicator) && e.bodyAxes(g, E, D), C.showPositions && e.bodyPositions(g, E, D), C.showVelocity && e.bodyVelocity(g, E, D), C.showIds && e.bodyIds(g, E, D), C.showSeparations && e.separations(g, d.pairs.list, D), C.showCollisions && e.collisions(g, d.pairs.list, D), C.showVertexNumbers && e.vertexNumbers(g, E, D), C.showMousePosition && e.mousePosition(g, g.mouse, D), e.constraints(H, D), C.hasBounds && e.endViewTransform(g), n.trigger(g, "afterRender", q), A.lastElapsed = l.now() - m }, e.stats = function (g, v, m) { for (var d = g.engine, P = d.world, S = r.allBodies(P), D = 0, C = 55, A = 44, L = 0, I = 0, B = 0; B < S.length; B += 1)D += S[B].parts.length; var E = { Part: D, Body: S.length, Cons: r.allConstraints(P).length, Comp: r.allComposites(P).length, Pair: d.pairs.list.length }; v.fillStyle = "#0e0f19", v.fillRect(L, I, C * 5.5, A), v.font = "12px Arial", v.textBaseline = "top", v.textAlign = "right"; for (var H in E) { var V = E[H]; v.fillStyle = "#aaa", v.fillText(H, L + C, I + 8), v.fillStyle = "#eee", v.fillText(V, L + C, I + 26), L += C } }, e.performance = function (g, v) { var m = g.engine, d = g.timing, P = d.deltaHistory, S = d.elapsedHistory, D = d.timestampElapsedHistory, C = d.engineDeltaHistory, A = d.engineUpdatesHistory, L = d.engineElapsedHistory, I = m.timing.lastUpdatesPerFrame, B = m.timing.lastDelta, E = c(P), H = c(S), V = c(C), q = c(A), N = c(L), z = c(D), X = z / E || 0, ae = Math.round(E / B), j = 1e3 / E || 0, W = 4, _ = 12, $ = 60, ue = 34, ee = 10, te = 69; v.fillStyle = "#0e0f19", v.fillRect(0, 50, _ * 5 + $ * 6 + 22, ue), e.status(v, ee, te, $, W, P.length, Math.round(j) + " fps", j / e._goodFps, function (K) { return P[K] / E - 1 }), e.status(v, ee + _ + $, te, $, W, C.length, B.toFixed(2) + " dt", e._goodDelta / B, function (K) { return C[K] / V - 1 }), e.status(v, ee + (_ + $) * 2, te, $, W, A.length, I + " upf", Math.pow(l.clamp(q / ae || 1, 0, 1), 4), function (K) { return A[K] / q - 1 }), e.status(v, ee + (_ + $) * 3, te, $, W, L.length, N.toFixed(2) + " ut", 1 - I * N / e._goodFps, function (K) { return L[K] / N - 1 }), e.status(v, ee + (_ + $) * 4, te, $, W, S.length, H.toFixed(2) + " rt", 1 - H / e._goodFps, function (K) { return S[K] / H - 1 }), e.status(v, ee + (_ + $) * 5, te, $, W, D.length, X.toFixed(2) + " x", X * X * X, function (K) { return (D[K] / P[K] / X || 0) - 1 }) }, e.status = function (g, v, m, d, P, S, D, C, A) { g.strokeStyle = "#888", g.fillStyle = "#444", g.lineWidth = 1, g.fillRect(v, m + 7, d, 1), g.beginPath(), g.moveTo(v, m + 7 - P * l.clamp(.4 * A(0), -2, 2)); for (var L = 0; L < d; L += 1)g.lineTo(v + L, m + 7 - (L < S ? P * l.clamp(.4 * A(L), -2, 2) : 0)); g.stroke(), g.fillStyle = "hsl(" + l.clamp(25 + 95 * C, 0, 120) + ",100%,60%)", g.fillRect(v, m - 7, 4, 4), g.font = "12px Arial", g.textBaseline = "middle", g.textAlign = "right", g.fillStyle = "#eee", g.fillText(D, v + d, m - 5) }, e.constraints = function (g, v) { for (var m = v, d = 0; d < g.length; d++) { var P = g[d]; if (!(!P.render.visible || !P.pointA || !P.pointB)) { var S = P.bodyA, D = P.bodyB, C, A; if (S ? C = f.add(S.position, P.pointA) : C = P.pointA, P.render.type === "pin") m.beginPath(), m.arc(C.x, C.y, 3, 0, 2 * Math.PI), m.closePath(); else { if (D ? A = f.add(D.position, P.pointB) : A = P.pointB, m.beginPath(), m.moveTo(C.x, C.y), P.render.type === "spring") for (var L = f.sub(A, C), I = f.perp(f.normalise(L)), B = Math.ceil(l.clamp(P.length / 5, 12, 20)), E, H = 1; H < B; H += 1)E = H % 2 === 0 ? 1 : -1, m.lineTo(C.x + L.x * (H / B) + I.x * E * 4, C.y + L.y * (H / B) + I.y * E * 4); m.lineTo(A.x, A.y) } P.render.lineWidth && (m.lineWidth = P.render.lineWidth, m.strokeStyle = P.render.strokeStyle, m.stroke()), P.render.anchors && (m.fillStyle = P.render.strokeStyle, m.beginPath(), m.arc(C.x, C.y, 3, 0, 2 * Math.PI), m.arc(A.x, A.y, 3, 0, 2 * Math.PI), m.closePath(), m.fill()) } } }, e.bodies = function (g, v, m) { var d = m; g.engine; var P = g.options, S = P.showInternalEdges || !P.wireframes, D, C, A, L; for (A = 0; A < v.length; A++)if (D = v[A], !!D.render.visible) { for (L = D.parts.length > 1 ? 1 : 0; L < D.parts.length; L++)if (C = D.parts[L], !!C.render.visible) { if (P.showSleeping && D.isSleeping ? d.globalAlpha = .5 * C.render.opacity : C.render.opacity !== 1 && (d.globalAlpha = C.render.opacity), C.render.sprite && C.render.sprite.texture && !P.wireframes) { var I = C.render.sprite, B = w(g, I.texture); d.translate(C.position.x, C.position.y), d.rotate(C.angle), d.drawImage(B, B.width * -I.xOffset * I.xScale, B.height * -I.yOffset * I.yScale, B.width * I.xScale, B.height * I.yScale), d.rotate(-C.angle), d.translate(-C.position.x, -C.position.y) } else { if (C.circleRadius) d.beginPath(), d.arc(C.position.x, C.position.y, C.circleRadius, 0, 2 * Math.PI); else { d.beginPath(), d.moveTo(C.vertices[0].x, C.vertices[0].y); for (var E = 1; E < C.vertices.length; E++)!C.vertices[E - 1].isInternal || S ? d.lineTo(C.vertices[E].x, C.vertices[E].y) : d.moveTo(C.vertices[E].x, C.vertices[E].y), C.vertices[E].isInternal && !S && d.moveTo(C.vertices[(E + 1) % C.vertices.length].x, C.vertices[(E + 1) % C.vertices.length].y); d.lineTo(C.vertices[0].x, C.vertices[0].y), d.closePath() } P.wireframes ? (d.lineWidth = 1, d.strokeStyle = g.options.wireframeStrokeStyle, d.stroke()) : (d.fillStyle = C.render.fillStyle, C.render.lineWidth && (d.lineWidth = C.render.lineWidth, d.strokeStyle = C.render.strokeStyle, d.stroke()), d.fill()) } d.globalAlpha = 1 } } }, e.bodyWireframes = function (g, v, m) { var d = m, P = g.options.showInternalEdges, S, D, C, A, L; for (d.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.render.visible) for (L = S.parts.length > 1 ? 1 : 0; L < S.parts.length; L++) { for (D = S.parts[L], d.moveTo(D.vertices[0].x, D.vertices[0].y), A = 1; A < D.vertices.length; A++)!D.vertices[A - 1].isInternal || P ? d.lineTo(D.vertices[A].x, D.vertices[A].y) : d.moveTo(D.vertices[A].x, D.vertices[A].y), D.vertices[A].isInternal && !P && d.moveTo(D.vertices[(A + 1) % D.vertices.length].x, D.vertices[(A + 1) % D.vertices.length].y); d.lineTo(D.vertices[0].x, D.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = g.options.wireframeStrokeStyle, d.stroke() }, e.bodyConvexHulls = function (g, v, m) { var d = m, P, S, D; for (d.beginPath(), S = 0; S < v.length; S++)if (P = v[S], !(!P.render.visible || P.parts.length === 1)) { for (d.moveTo(P.vertices[0].x, P.vertices[0].y), D = 1; D < P.vertices.length; D++)d.lineTo(P.vertices[D].x, P.vertices[D].y); d.lineTo(P.vertices[0].x, P.vertices[0].y) } d.lineWidth = 1, d.strokeStyle = "rgba(255,255,255,0.2)", d.stroke() }, e.vertexNumbers = function (g, v, m) { var d = m, P, S, D; for (P = 0; P < v.length; P++) { var C = v[P].parts; for (D = C.length > 1 ? 1 : 0; D < C.length; D++) { var A = C[D]; for (S = 0; S < A.vertices.length; S++)d.fillStyle = "rgba(255,255,255,0.2)", d.fillText(P + "_" + S, A.position.x + (A.vertices[S].x - A.position.x) * .8, A.position.y + (A.vertices[S].y - A.position.y) * .8) } } }, e.mousePosition = function (g, v, m) { var d = m; d.fillStyle = "rgba(255,255,255,0.8)", d.fillText(v.position.x + "  " + v.position.y, v.position.x + 5, v.position.y - 5) }, e.bodyBounds = function (g, v, m) { var d = m; g.engine; var P = g.options; d.beginPath(); for (var S = 0; S < v.length; S++) { var D = v[S]; if (D.render.visible) for (var C = v[S].parts, A = C.length > 1 ? 1 : 0; A < C.length; A++) { var L = C[A]; d.rect(L.bounds.min.x, L.bounds.min.y, L.bounds.max.x - L.bounds.min.x, L.bounds.max.y - L.bounds.min.y) } } P.wireframes ? d.strokeStyle = "rgba(255,255,255,0.08)" : d.strokeStyle = "rgba(0,0,0,0.1)", d.lineWidth = 1, d.stroke() }, e.bodyAxes = function (g, v, m) { var d = m; g.engine; var P = g.options, S, D, C, A; for (d.beginPath(), D = 0; D < v.length; D++) { var L = v[D], I = L.parts; if (L.render.visible) if (P.showAxes) for (C = I.length > 1 ? 1 : 0; C < I.length; C++)for (S = I[C], A = 0; A < S.axes.length; A++) { var B = S.axes[A]; d.moveTo(S.position.x, S.position.y), d.lineTo(S.position.x + B.x * 20, S.position.y + B.y * 20) } else for (C = I.length > 1 ? 1 : 0; C < I.length; C++)for (S = I[C], A = 0; A < S.axes.length; A++)d.moveTo(S.position.x, S.position.y), d.lineTo((S.vertices[0].x + S.vertices[S.vertices.length - 1].x) / 2, (S.vertices[0].y + S.vertices[S.vertices.length - 1].y) / 2) } P.wireframes ? (d.strokeStyle = "indianred", d.lineWidth = 1) : (d.strokeStyle = "rgba(255, 255, 255, 0.4)", d.globalCompositeOperation = "overlay", d.lineWidth = 2), d.stroke(), d.globalCompositeOperation = "source-over" }, e.bodyPositions = function (g, v, m) { var d = m; g.engine; var P = g.options, S, D, C, A; for (d.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.render.visible) for (A = 0; A < S.parts.length; A++)D = S.parts[A], d.arc(D.position.x, D.position.y, 3, 0, 2 * Math.PI, !1), d.closePath(); for (P.wireframes ? d.fillStyle = "indianred" : d.fillStyle = "rgba(0,0,0,0.5)", d.fill(), d.beginPath(), C = 0; C < v.length; C++)S = v[C], S.render.visible && (d.arc(S.positionPrev.x, S.positionPrev.y, 2, 0, 2 * Math.PI, !1), d.closePath()); d.fillStyle = "rgba(255,165,0,0.8)", d.fill() }, e.bodyVelocity = function (g, v, m) { var d = m; d.beginPath(); for (var P = 0; P < v.length; P++) { var S = v[P]; if (S.render.visible) { var D = a.getVelocity(S); d.moveTo(S.position.x, S.position.y), d.lineTo(S.position.x + D.x, S.position.y + D.y) } } d.lineWidth = 3, d.strokeStyle = "cornflowerblue", d.stroke() }, e.bodyIds = function (g, v, m) { var d = m, P, S; for (P = 0; P < v.length; P++)if (v[P].render.visible) { var D = v[P].parts; for (S = D.length > 1 ? 1 : 0; S < D.length; S++) { var C = D[S]; d.font = "12px Arial", d.fillStyle = "rgba(255,255,255,0.5)", d.fillText(C.id, C.position.x + 10, C.position.y - 10) } } }, e.collisions = function (g, v, m) { var d = m, P = g.options, S, D, C, A; for (d.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.isActive) for (D = S.collision, A = 0; A < S.contactCount; A++) { var L = S.contacts[A], I = L.vertex; d.rect(I.x - 1.5, I.y - 1.5, 3.5, 3.5) } for (P.wireframes ? d.fillStyle = "rgba(255,255,255,0.7)" : d.fillStyle = "orange", d.fill(), d.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.isActive && (D = S.collision, S.contactCount > 0)) { var B = S.contacts[0].vertex.x, E = S.contacts[0].vertex.y; S.contactCount === 2 && (B = (S.contacts[0].vertex.x + S.contacts[1].vertex.x) / 2, E = (S.contacts[0].vertex.y + S.contacts[1].vertex.y) / 2), D.bodyB === D.supports[0].body || D.bodyA.isStatic === !0 ? d.moveTo(B - D.normal.x * 8, E - D.normal.y * 8) : d.moveTo(B + D.normal.x * 8, E + D.normal.y * 8), d.lineTo(B, E) } P.wireframes ? d.strokeStyle = "rgba(255,165,0,0.7)" : d.strokeStyle = "orange", d.lineWidth = 1, d.stroke() }, e.separations = function (g, v, m) { var d = m, P = g.options, S, D, C, A, L; for (d.beginPath(), L = 0; L < v.length; L++)if (S = v[L], !!S.isActive) { D = S.collision, C = D.bodyA, A = D.bodyB; var I = 1; !A.isStatic && !C.isStatic && (I = .5), A.isStatic && (I = 0), d.moveTo(A.position.x, A.position.y), d.lineTo(A.position.x - D.penetration.x * I, A.position.y - D.penetration.y * I), I = 1, !A.isStatic && !C.isStatic && (I = .5), C.isStatic && (I = 0), d.moveTo(C.position.x, C.position.y), d.lineTo(C.position.x + D.penetration.x * I, C.position.y + D.penetration.y * I) } P.wireframes ? d.strokeStyle = "rgba(255,165,0,0.5)" : d.strokeStyle = "orange", d.stroke() }, e.inspector = function (g, v) { g.engine; var m = g.selected, d = g.render, P = d.options, S; if (P.hasBounds) { var D = d.bounds.max.x - d.bounds.min.x, C = d.bounds.max.y - d.bounds.min.y, A = D / d.options.width, L = C / d.options.height; v.scale(1 / A, 1 / L), v.translate(-d.bounds.min.x, -d.bounds.min.y) } for (var I = 0; I < m.length; I++) { var B = m[I].data; switch (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.9)", v.setLineDash([1, 2]), B.type) { case "body": S = B.bounds, v.beginPath(), v.rect(Math.floor(S.min.x - 3), Math.floor(S.min.y - 3), Math.floor(S.max.x - S.min.x + 6), Math.floor(S.max.y - S.min.y + 6)), v.closePath(), v.stroke(); break; case "constraint": var E = B.pointA; B.bodyA && (E = B.pointB), v.beginPath(), v.arc(E.x, E.y, 10, 0, 2 * Math.PI), v.closePath(), v.stroke(); break }v.setLineDash([]), v.translate(-.5, -.5) } g.selectStart !== null && (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.6)", v.fillStyle = "rgba(255,165,0,0.1)", S = g.selectBounds, v.beginPath(), v.rect(Math.floor(S.min.x), Math.floor(S.min.y), Math.floor(S.max.x - S.min.x), Math.floor(S.max.y - S.min.y)), v.closePath(), v.stroke(), v.fill(), v.translate(-.5, -.5)), P.hasBounds && v.setTransform(1, 0, 0, 1, 0, 0) }; var i = function (g, v) { var m = g.engine, d = g.timing, P = d.historySize, S = m.timing.timestamp; d.delta = v - d.lastTime || e._goodDelta, d.lastTime = v, d.timestampElapsed = S - d.lastTimestamp || 0, d.lastTimestamp = S, d.deltaHistory.unshift(d.delta), d.deltaHistory.length = Math.min(d.deltaHistory.length, P), d.engineDeltaHistory.unshift(m.timing.lastDelta), d.engineDeltaHistory.length = Math.min(d.engineDeltaHistory.length, P), d.timestampElapsedHistory.unshift(d.timestampElapsed), d.timestampElapsedHistory.length = Math.min(d.timestampElapsedHistory.length, P), d.engineUpdatesHistory.unshift(m.timing.lastUpdatesPerFrame), d.engineUpdatesHistory.length = Math.min(d.engineUpdatesHistory.length, P), d.engineElapsedHistory.unshift(m.timing.lastElapsed), d.engineElapsedHistory.length = Math.min(d.engineElapsedHistory.length, P), d.elapsedHistory.unshift(d.lastElapsed), d.elapsedHistory.length = Math.min(d.elapsedHistory.length, P) }, c = function (g) { for (var v = 0, m = 0; m < g.length; m += 1)v += g[m]; return v / g.length || 0 }, p = function (g, v) { var m = document.createElement("canvas"); return m.width = g, m.height = v, m.oncontextmenu = function () { return !1 }, m.onselectstart = function () { return !1 }, m }, y = function (g) { var v = g.getContext("2d"), m = window.devicePixelRatio || 1, d = v.webkitBackingStorePixelRatio || v.mozBackingStorePixelRatio || v.msBackingStorePixelRatio || v.oBackingStorePixelRatio || v.backingStorePixelRatio || 1; return m / d }, w = function (g, v) { var m = g.textures[v]; return m || (m = g.textures[v] = new Image, m.src = v, m) }, O = function (g, v) { var m = v; /(jpg|gif|png)$/.test(v) && (m = "url(" + v + ")"), g.canvas.style.background = m, g.canvas.style.backgroundSize = "contain", g.currentBackground = v } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(5), l = u(17), r = u(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (n) { var f = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, o = r.extend(f, n); return o.fps = 0, o }, e.run = function (n, f) { return n.timeBuffer = e._frameDeltaFallback, function o(t) { n.frameRequestId = e._onNextFrame(n, o), t && n.enabled && e.tick(n, f, t) }(), n }, e.tick = function (n, f, o) { var t = r.now(), s = n.delta, i = 0, c = o - n.timeLastTick; if ((!c || !n.timeLastTick || c > Math.max(e._maxFrameDelta, n.maxFrameTime)) && (c = n.frameDelta || e._frameDeltaFallback), n.frameDeltaSmoothing) { n.frameDeltaHistory.push(c), n.frameDeltaHistory = n.frameDeltaHistory.slice(-n.frameDeltaHistorySize); var p = n.frameDeltaHistory.slice(0).sort(), y = n.frameDeltaHistory.slice(p.length * e._smoothingLowerBound, p.length * e._smoothingUpperBound), w = h(y); c = w || c } n.frameDeltaSnapping && (c = 1e3 / Math.round(1e3 / c)), n.frameDelta = c, n.timeLastTick = o, n.timeBuffer += n.frameDelta, n.timeBuffer = r.clamp(n.timeBuffer, 0, n.frameDelta + s * e._timeBufferMargin), n.lastUpdatesDeferred = 0; var O = n.maxUpdates || Math.ceil(n.maxFrameTime / s), g = { timestamp: f.timing.timestamp }; a.trigger(n, "beforeTick", g), a.trigger(n, "tick", g); for (var v = r.now(); s > 0 && n.timeBuffer >= s * e._timeBufferMargin;) { a.trigger(n, "beforeUpdate", g), l.update(f, s), a.trigger(n, "afterUpdate", g), n.timeBuffer -= s, i += 1; var m = r.now() - t, d = r.now() - v, P = m + e._elapsedNextEstimate * d / i; if (i >= O || P > n.maxFrameTime) { n.lastUpdatesDeferred = Math.round(Math.max(0, n.timeBuffer / s - e._timeBufferMargin)); break } } f.timing.lastUpdatesPerFrame = i, a.trigger(n, "afterTick", g), n.frameDeltaHistory.length >= 100 && (n.lastUpdatesDeferred && Math.round(n.frameDelta / s) > O ? r.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : n.lastUpdatesDeferred && r.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof n.isFixed < "u" && r.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (n.deltaMin || n.deltaMax) && r.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), n.fps !== 0 && r.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (n) { e._cancelNextFrame(n) }, e._onNextFrame = function (n, f) { if (typeof window < "u" && window.requestAnimationFrame) n.frameRequestId = window.requestAnimationFrame(f); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return n.frameRequestId }, e._cancelNextFrame = function (n) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(n.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var h = function (n) { for (var f = 0, o = n.length, t = 0; t < o; t += 1)f += n[t]; return f / o || 0 } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(8), l = u(0), r = l.deprecated; (function () { e.collides = function (h, n) { return a.collides(h, n) }, r(e, "collides", "SAT.collides ➤ replaced by Collision.collides") })() }, function (x, T, u) { var e = {}; x.exports = e, u(1); var a = u(0); (function () { e.pathToVertices = function (l, r) { typeof window < "u" && !("SVGPathSeg" in window) && a.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var h, n, f, o, t, s, i, c, p, y, w = [], O, g, v = 0, m = 0, d = 0; r = r || 15; var P = function (D, C, A) { var L = A % 2 === 1 && A > 1; if (!p || D != p.x || C != p.y) { p && L ? (O = p.x, g = p.y) : (O = 0, g = 0); var I = { x: O + D, y: g + C }; (L || !p) && (p = I), w.push(I), m = O + D, d = g + C } }, S = function (D) { var C = D.pathSegTypeAsLetter.toUpperCase(); if (C !== "Z") { switch (C) { case "M": case "L": case "T": case "C": case "S": case "Q": m = D.x, d = D.y; break; case "H": m = D.x; break; case "V": d = D.y; break }P(m, d, D.pathSegType) } }; for (e._svgPathToAbsolute(l), f = l.getTotalLength(), s = [], h = 0; h < l.pathSegList.numberOfItems; h += 1)s.push(l.pathSegList.getItem(h)); for (i = s.concat(); v < f;) { if (y = l.getPathSegAtLength(v), t = s[y], t != c) { for (; i.length && i[0] != t;)S(i.shift()); c = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": o = l.getPointAtLength(v), P(o.x, o.y, 0); break }v += r } for (h = 0, n = i.length; h < n; ++h)S(i[h]); return w }, e._svgPathToAbsolute = function (l) { for (var r, h, n, f, o, t, s = l.pathSegList, i = 0, c = 0, p = s.numberOfItems, y = 0; y < p; ++y) { var w = s.getItem(y), O = w.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(O)) "x" in w && (i = w.x), "y" in w && (c = w.y); else switch ("x1" in w && (n = i + w.x1), "x2" in w && (o = i + w.x2), "y1" in w && (f = c + w.y1), "y2" in w && (t = c + w.y2), "x" in w && (i += w.x), "y" in w && (c += w.y), O) { case "m": s.replaceItem(l.createSVGPathSegMovetoAbs(i, c), y); break; case "l": s.replaceItem(l.createSVGPathSegLinetoAbs(i, c), y); break; case "h": s.replaceItem(l.createSVGPathSegLinetoHorizontalAbs(i), y); break; case "v": s.replaceItem(l.createSVGPathSegLinetoVerticalAbs(c), y); break; case "c": s.replaceItem(l.createSVGPathSegCurvetoCubicAbs(i, c, n, f, o, t), y); break; case "s": s.replaceItem(l.createSVGPathSegCurvetoCubicSmoothAbs(i, c, o, t), y); break; case "q": s.replaceItem(l.createSVGPathSegCurvetoQuadraticAbs(i, c, n, f), y); break; case "t": s.replaceItem(l.createSVGPathSegCurvetoQuadraticSmoothAbs(i, c), y); break; case "a": s.replaceItem(l.createSVGPathSegArcAbs(i, c, w.r1, w.r2, w.angle, w.largeArcFlag, w.sweepFlag), y); break; case "z": case "Z": i = r, c = h; break }(O == "M" || O == "m") && (r = i, h = c) } } })() }, function (x, T, u) { var e = {}; x.exports = e; var a = u(6); u(0), function () { e.create = a.create, e.add = a.add, e.remove = a.remove, e.clear = a.clear, e.addComposite = a.addComposite, e.addBody = a.addBody, e.addConstraint = a.addConstraint }() }]) }) })(Bt); const ie = dt(le); class Rt { constructor(M) { F(this, "widthCanvas", document.body.clientWidth); F(this, "heightCanvas"); F(this, "DOM"); F(this, "dataImgs", []); F(this, "MatterJS"); F(this, "sizeCustom"); this.DOM = { el: M }, this.MatterJS = { Engine: void 0, Render: void 0 }, this.sizeCustom = { mobile: { radius: G(5), scaleRatio: G(5) / 133, scaleCircleMain: 171 / 50, xLeftWall: 0 - G(9), xRightWall: window.innerWidth + G(9), yMainCircle: G(72.2) + G(17) }, tablet: { radius: G(5), scaleRatio: G(5) / 133, scaleCircleMain: 190 / 50, xLeftWall: 0 - G(9), xRightWall: window.innerWidth + G(9), yMainCircle: G(72.2) + G(19) }, desktop: { radius: G(13.3), scaleRatio: G(13.3) / 133, scaleCircleMain: 293 / 133, xLeftWall: 0, xRightWall: window.innerWidth, yMainCircle: G(51.2) + G(29.3) } }, this.heightCanvas = this.DOM.el.clientHeight, M == null || M.querySelectorAll(".home-bubble-item").forEach(x => { var u; const T = (u = x.querySelector("img")) == null ? void 0 : u.getAttribute("src"); T && this.dataImgs.push(T), x.style.pointerEvents = "none", x.style.opacity = "0" }) } render() { var u, e, a, l; this.init(); const M = ie.Runner.create(), x = (e = (u = this.MatterJS).Engine) == null ? void 0 : e.call(u), T = (l = (a = this.MatterJS).Render) == null ? void 0 : l.call(a); se.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !x || !T || (ie.Render.run(T), ie.Runner.run(M, x)) } }) } init() { const M = this.sizeCustom[fe].radius, x = this.sizeCustom[fe].scaleRatio, T = this.sizeCustom[fe].scaleCircleMain, u = this.sizeCustom[fe].xLeftWall, e = this.sizeCustom[fe].xRightWall, a = this.sizeCustom[fe].yMainCircle, l = ie.Engine.create(), r = ie.Render.create({ element: this.DOM.el, engine: l, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), h = Math.floor(window.innerWidth / (M * 2)), f = (window.innerWidth - h * M * 2) / (h - 1); let o = 0; for (let w = 0; w < Math.round(this.dataImgs.length / h) && this.dataImgs[o]; w++) { for (let O = 0; O < h && this.dataImgs[o]; O++) { const g = O * M * 2 + f * O, v = -w * M * 2 - M * 2 - f * w, m = le.Bodies.circle(g, v, M, { friction: .001, frictionAir: .01, restitution: .8, timeScale: 1.05, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[o], xScale: x, yScale: x } } }); if (o++, ie.Composite.add(l.world, m), o >= this.dataImgs.length) break } if (o >= this.dataImgs.length) break } const t = le.Bodies.circle(this.DOM.el.clientWidth / 2, a, M * T, { render: { fillStyle: "transparent" }, isStatic: !0 }), s = le.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight, this.DOM.el.clientWidth * 10, 1, { isStatic: !0, render: { fillStyle: "transparent" } }), i = le.Bodies.rectangle(u, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }), c = le.Bodies.rectangle(e, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }); ie.Composite.add(l.world, [s, i, c, t]); const p = ie.Mouse.create(r.canvas), y = ie.MouseConstraint.create(l, { mouse: p, constraint: { stiffness: .2, render: { visible: !1 } } }); ie.Composite.add(l.world, y), y.mouse.element.removeEventListener("touchstart", y.mouse.mousedown), y.mouse.element.removeEventListener("touchmove", y.mouse.mousemove), y.mouse.element.removeEventListener("touchend", y.mouse.mouseup), y.mouse.element.addEventListener("touchstart", y.mouse.mousedown, { passive: !0 }), y.mouse.element.addEventListener("touchmove", w => { y.body && y.mouse.mousemove(w) }), y.mouse.element.addEventListener("touchend", w => { y.body && y.mouse.mouseup(w) }), this.MatterJS.Render = () => r, this.MatterJS.Engine = () => l } } class kt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { const M = this.DOM.el.querySelectorAll(".home-hero-brands-wrap"), x = this.DOM.el.querySelector(".home-bubble"), T = this.DOM.el.querySelector(".home-book-img-inner"); M.length && M.forEach(u => { new Oe({ wrap: u, listSplide: u.querySelectorAll(".home-hero-brands") }) }), new Et(this.DOM.el), x && new Rt(x).render(), T && new Ae({ el: T, offset: 30, direction: -1 }), this.heroVideoAction(), this.handleParallaxTitle(), this.initMotion() } clear() { this.initParticles() } initMotion() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } heroVideoAction() { const M = this.DOM.el.querySelector(".home-hero-img-btn"), x = this.DOM.el.querySelector(".home-hero-poup-video"), T = this.DOM.el.querySelector(".home-hero--poup-ic"), u = this.DOM.el.querySelector(".home-hero-poup-video-content"); M.addEventListener("click", () => { x.classList.add("is-show") }), T.addEventListener("click", () => e()), vt({ element: u, action: () => e() }); const e = () => { x.classList.remove("is-show") } } handleParallaxTitle() { const M = this.DOM.el.querySelector(".home-feature-top-inner"), x = this.DOM.el.querySelector(".home-bubble"); if (!M || !x) return; const T = U.fromTo(M, { y: M.clientHeight / 2 }, { y: `-${window.innerHeight / 2 - M.clientHeight / 2}px`, ease: "none", duration: 3 }); se.create({ trigger: x, start: () => "bottom bottom", end: "bottom top", animation: T, scrub: !0 }) } } class Ft { constructor(M) { F(this, "DOM"); F(this, "pricing"); F(this, "pricingBase"); F(this, "pricingAgent"); F(this, "planCurrent"); F(this, "planOptions", { month: { planUser: 35, basePrice: 75, valSaleUp: 0, type: "month" }, year: { planUser: 35, basePrice: 75, valSaleUp: 10, type: "year" } }); this.DOM = { el: M }, this.planCurrent = this.planOptions.month, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { const M = this.DOM.el.querySelector(".home-book-img-inner"); M && new Ae({ el: M, offset: 30, direction: -1 }); const x = this.DOM.el.querySelectorAll(".pricing-testimonials-brands"); x.length && x.forEach(T => { new Oe({ wrap: T, listSplide: this.DOM.el.querySelectorAll(".pricing-testimonials-brands") }) }), new Oe({ wrap: this.DOM.el.querySelector(".book-brands-wrap"), listSplide: this.DOM.el.querySelectorAll(".home-hero-brands") }), this.initMotions(), this.handleInitPricing(), this.handleLoadMorePrice(), this.handleSubmitForm(), this.handleRoateIconSale() } initMotions() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.fadeWrap(this.DOM.el) } handleRoateIconSale() { const M = this.DOM.el.querySelector(".pricing-hero-tab-tag"), x = () => { U.killTweensOf(M), U.to(M, { keyframes: { rotation: [16, -12, 8, -4, 2, 0] }, ease: "bounce.out", duration: 1.6 }) }; return Ne({ el: M, animIn: x }), x } handleLoadMorePrice() { if (!this.DOM.el) return; const M = this.DOM.el.querySelectorAll("#tablePricing .pricing_table_row"), x = this.DOM.el.querySelector("#loadMoreTable"); let T = 10; x.addEventListener("click", function () { const u = T + 11; for (let e = T; e < u && e < M.length; e++)if (e > 10) { const a = M[e], l = ze(e, T, u, 0, 1); a.style.animationDelay = `${l}s`, a.classList.add("show_row") } T = u, T >= M.length && (this.style.display = "none"), se.refresh() }) } handleSelectTypePlan() { const M = this.DOM.el.querySelector(".pricing-hero-bg-wrap"), x = this.DOM.el.querySelector(".pricing-hero-bg"), T = this.DOM.el.querySelectorAll(".js-text-timer"); M && this.DOM.el.querySelectorAll(".pricing-hero-tab-item").forEach(u => { u.addEventListener("click", () => { var t, s, i, c, p; const e = u.getAttribute("data-plan-pricing"); if (!this.pricing || e === ((t = this.planCurrent) == null ? void 0 : t.type)) return; e === "year" && this.handleRoateIconSale(); const a = M.getBoundingClientRect().x, l = u.getBoundingClientRect().x, r = u.getBoundingClientRect().width, h = this.planOptions[e]; this.planCurrent = h, T.forEach((y, w, O) => { const g = y.querySelectorAll(".txt.txt-18"); e === "month" ? U.to(g, { y: 0, ease: "power3", duration: 1.2, delay: w * .3 + 1 }) : U.fromTo(g, { y: "0%" }, { y: "-100%", ease: "power3", duration: 1.2, delay: (O.length - w) * .3 + 1 }) }); const n = e === "year", f = (n ? 12 * (100 - h.valSaleUp) / 100 : 1) * h.planUser, o = (n ? 12 * (100 - h.valSaleUp) / 100 : 1) * h.basePrice; !this.pricingAgent || !this.pricingBase || ((s = this.pricingAgent.textSplit) == null || s.revert(), (i = this.pricingBase.textSplit) == null || i.revert(), this.pricingBase.DOM.el.innerHTML = `${o}`, this.pricingAgent.DOM.el.innerHTML = `${f}`, this.pricingAgent.init(), this.pricingBase.init(), (c = this.pricingAgent) == null || c.animIn(), (p = this.pricingBase) == null || p.animIn(.1), U.to(x, { x: -(a - l), duration: .5, width: r, ease: "power3.out" }), this.pricing.handleCalcPricing({ ...h, isReinit: !0 })) }) }) } handleSubmitForm() { const M = this.DOM.el.querySelector(".pricing-range-form-inner"), x = this.DOM.el.querySelector('[data-name="Name"]'), T = this.DOM.el.querySelector('[data-name="Total Price"]'), u = this.DOM.el.querySelector(".pricing-message-success"); M == null || M.addEventListener("submit", () => { var a; x.value = "Anonymous", T.value = ((a = this.pricing) == null ? void 0 : a.DOM.el.innerHTML) || "0" }); let e; setInterval(() => { u.style.display === "block" && (clearInterval(e), setTimeout(() => { U.to(u, { opacity: 0, duration: 1.2, ease: "power3.out", onComplete: () => { u.style.display = "none" } }) }, 2e3)) }, 100) } handleInitPricing() { var h; const M = (h = this.DOM.el.querySelector(".txt-168.txt-bold")) == null ? void 0 : h.querySelector(".js-text-counter"), x = this.DOM.el.querySelector(".text-pricing-agent"), T = this.DOM.el.querySelector(".text-pricing-base"), u = document.querySelector(".fs-rangeslider_input__custom"), e = !0, a = new we(M, u, e), l = new we(T, void 0, e), r = new we(x, void 0, e); this.pricingAgent = r, this.pricingBase = l, this.pricing = a, this.handleSelectTypePlan(), this.handleActionPlanPricing() } handleActionPlanPricing() { setTimeout(() => { var M, x, T, u; this.pricing && this.pricing.handleSlide({ type: ((M = this.planCurrent) == null ? void 0 : M.type) || "month", planUser: ((x = this.planCurrent) == null ? void 0 : x.planUser) || 35, valSaleUp: ((T = this.planCurrent) == null ? void 0 : T.valSaleUp) || 0, basePrice: ((u = this.planCurrent) == null ? void 0 : u.basePrice) || 75 }) }, 1e3) } clear() { this.initParticles() } } class Ht { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)), this.handleTotalArticle() } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } handleTotalArticle() { const M = this.DOM.el.querySelectorAll(".sc-result-card-wrap"); M.length && mt(() => { for (let x = 0; x < M.length; x++) { const T = M[x].querySelectorAll(".w-dyn-item"), u = M[x].querySelector(".sc-result-card-content-total"); if (!u) return; const e = T.length; e ? u.innerHTML = `${e < 10 ? "0" + e : e}` : u.innerHTML = "0" } }, 1200)() } } class bt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Wt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Vt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Ut { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Gt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, b.emit(Q), this.initParticles = this.initParticles.bind(this), b.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { k.maskText(this.DOM.el), k.fadeText(this.DOM.el), k.countText(this.DOM.el), k.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } U.registerPlugin(se); class qt { constructor() { this.init(), this.bindEvents() } init() { const x = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", x), x) return; const T = document.querySelector("div[data-page]"); if (!T) return; const u = T.getAttribute("data-page") || "home", e = { home: () => { new kt(T) }, about: () => { new It(T) }, pricing: () => { new Ft(T) }, "support-center": () => { new Ht(T) }, changelog: () => { new Lt(T) }, "blog-detail": () => { new Mt(T) }, "contact-us": () => { new bt(T) }, impressum: () => { new Wt(T) }, "request-trial": () => { new Vt(T) }, "ask-a-question": () => { new Ut(T) }, "sign-up": () => { new Gt(T) } }; e[u] && e[u](), xt.init(), k.init(), new Ot, new Ct } bindEvents() { b.on(yt, this.init.bind(this)), qe.simple(), qe.simpleLoaded() } } new qt;
