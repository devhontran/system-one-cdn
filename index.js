var nt = Object.defineProperty; var st = (k, M, m) => M in k ? nt(k, M, { enumerable: !0, configurable: !0, writable: !0, value: m }) : k[M] = m; var F = (k, M, m) => (st(k, typeof M != "symbol" ? M + "" : M, m), m); import { b as W, P as Q, d as J, u as Z, e as R, f as Ne, S as se, g as b, r as rt, i as ot, s as He, L as at, h as lt, A as ct, j as ft, D as ut, k as ht, l as dt, R as be, U as We, m as Ce, n as ze, a as q, F as pt, T as gt, c as Me, o as vt, p as fe, M as Oe, q as mt, t as we, v as xt, _ as yt, w as St } from "./global.js";/*!
 * ScrollToPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Y, $e, oe, ne, ce, Xe, Ye, xe, Ke = function () { return typeof window < "u" }, Qe = function () { return Y || Ke() && (Y = window.gsap) && Y.registerPlugin && Y }, Je = function (M) { return typeof M == "string" }, Ve = function (M) { return typeof M == "function" }, he = function (M, m) { var T = m === "x" ? "Width" : "Height", f = "scroll" + T, e = "client" + T; return M === oe || M === ne || M === ce ? Math.max(ne[f], ce[f]) - (oe["inner" + T] || ne[e] || ce[e]) : M[f] - M["offset" + T] }, de = function (M, m) { var T = "scroll" + (m === "x" ? "Left" : "Top"); return M === oe && (M.pageXOffset != null ? T = "page" + m.toUpperCase() + "Offset" : M = ne[T] != null ? ne : ce), function () { return M[T] } }, Mt = function (M, m, T, f) { if (Ve(M) && (M = M(m, T, f)), typeof M != "object") return Je(M) && M !== "max" && M.charAt(1) !== "=" ? { x: M, y: M } : { y: M }; if (M.nodeType) return { y: M, x: M }; var e = {}, o; for (o in M) e[o] = o !== "onAutoKill" && Ve(M[o]) ? M[o](m, T, f) : M[o]; return e }, Ze = function (M, m) { if (M = Xe(M)[0], !M || !M.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || { x: 0, y: 0 }; var T = M.getBoundingClientRect(), f = !m || m === oe || m === ce, e = f ? { top: ne.clientTop - (oe.pageYOffset || ne.scrollTop || ce.scrollTop || 0), left: ne.clientLeft - (oe.pageXOffset || ne.scrollLeft || ce.scrollLeft || 0) } : m.getBoundingClientRect(), o = { x: T.left - e.left, y: T.top - e.top }; return !f && m && (o.x += de(m, "x")(), o.y += de(m, "y")()), o }, Ue = function (M, m, T, f, e) { return !isNaN(M) && typeof M != "object" ? parseFloat(M) - e : Je(M) && M.charAt(1) === "=" ? parseFloat(M.substr(2)) * (M.charAt(0) === "-" ? -1 : 1) + f - e : M === "max" ? he(m, T) - e : Math.min(he(m, T), Ze(M, m)[T] - e) }, qe = function () { Y = Qe(), Ke() && Y && typeof document < "u" && document.body && (oe = window, ce = document.body, ne = document.documentElement, Xe = Y.utils.toArray, Y.config({ autoKillThreshold: 7 }), Ye = Y.config(), $e = 1) }, pe = { version: "3.12.5", name: "scrollTo", rawVars: 1, register: function (M) { Y = M, qe() }, init: function (M, m, T, f, e) { $e || qe(); var o = this, l = Y.getProperty(M, "scrollSnapType"); o.isWin = M === oe, o.target = M, o.tween = T, m = Mt(m, f, M, e), o.vars = m, o.autoKill = !!m.autoKill, o.getX = de(M, "x"), o.getY = de(M, "y"), o.x = o.xPrev = o.getX(), o.y = o.yPrev = o.getY(), xe || (xe = Y.core.globals().ScrollTrigger), Y.getProperty(M, "scrollBehavior") === "smooth" && Y.set(M, { scrollBehavior: "auto" }), l && l !== "none" && (o.snap = 1, o.snapInline = M.style.scrollSnapType, M.style.scrollSnapType = "none"), m.x != null ? (o.add(o, "x", o.x, Ue(m.x, M, "x", o.x, m.offsetX || 0), f, e), o._props.push("scrollTo_x")) : o.skipX = 1, m.y != null ? (o.add(o, "y", o.y, Ue(m.y, M, "y", o.y, m.offsetY || 0), f, e), o._props.push("scrollTo_y")) : o.skipY = 1 }, render: function (M, m) { for (var T = m._pt, f = m.target, e = m.tween, o = m.autoKill, l = m.xPrev, r = m.yPrev, h = m.isWin, n = m.snap, u = m.snapInline, a, t, s, i, c; T;)T.r(M, T.d), T = T._next; a = h || !m.skipX ? m.getX() : l, t = h || !m.skipY ? m.getY() : r, s = t - r, i = a - l, c = Ye.autoKillThreshold, m.x < 0 && (m.x = 0), m.y < 0 && (m.y = 0), o && (!m.skipX && (i > c || i < -c) && a < he(f, "x") && (m.skipX = 1), !m.skipY && (s > c || s < -c) && t < he(f, "y") && (m.skipY = 1), m.skipX && m.skipY && (e.kill(), m.vars.onAutoKill && m.vars.onAutoKill.apply(e, m.vars.onAutoKillParams || []))), h ? oe.scrollTo(m.skipX ? a : m.x, m.skipY ? t : m.y) : (m.skipY || (f.scrollTop = m.y), m.skipX || (f.scrollLeft = m.x)), n && (M === 1 || M === 0) && (t = f.scrollTop, a = f.scrollLeft, u ? f.style.scrollSnapType = u : f.style.removeProperty("scroll-snap-type"), f.scrollTop = t + 1, f.scrollLeft = a + 1, f.scrollTop = t, f.scrollLeft = a), m.xPrev = m.x, m.yPrev = m.y, xe && xe.update() }, kill: function (M) { var m = M === "scrollTo", T = this._props.indexOf(M); return (m || M === "scrollTo_x") && (this.skipX = 1), (m || M === "scrollTo_y") && (this.skipY = 1), T > -1 && this._props.splice(T, 1), !this._props.length } }; pe.max = he; pe.getOffset = Ze; pe.buildGetter = de; Qe() && Y.registerPlugin(pe); const Te = (k, M, m, T, f) => parseFloat(((k - M) * (f - T) / (m - M) + T).toFixed(3)), Pe = k => { const M = parseFloat(getComputedStyle(document.documentElement).fontSize); return k / M }; class wt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)), this.handleAppendComponent() } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } handleAppendComponent() { const M = this.DOM.el.querySelector(".blog-quote"), m = this.DOM.el.querySelector("#content_blog"), T = "{{quote}}", f = m.textContent; f != null && f.includes(T) || (M.style.display = "none") } } const Pt = "_parallax_79i64_1", Dt = "_wrapper_79i64_5", Ct = "_inner_79i64_12", De = { parallax: Pt, wrapper: Dt, inner: Ct }; class Ae { constructor({ el: M, offset: m, scale: T, direction: f, ...e }) { F(this, "DOM"); F(this, "offset"); F(this, "scale"); F(this, "direction"); F(this, "options"); this.DOM = { el: M }, this.offset = m || 0, this.scale = T || 1.1, this.direction = f || -1, this.options = e, this.init() } init() { const M = this.DOM.el.cloneNode(!0); for (; this.DOM.el.firstChild;)this.DOM.el.removeChild(this.DOM.el.firstChild); const m = document.createElement("div"); m.style.scale = `${this.scale}`, m.style.transformOrigin = `${this.direction > 0 ? "bottom" : "top"} center`, m.classList.add(De.inner), M.classList.add(De.parallax), this.DOM.el.classList.add(De.wrapper), m.appendChild(M), this.DOM.el.appendChild(m), this.DOM.elInner = this.DOM.el; const { removeEvent: T } = Ne({ el: this.DOM.el, animIn: () => { this.animIn(), T() } }); Z(() => { T() }) } animIn() { var f; if (!this.DOM.elInner) return; const M = 100 + this.offset * 2, m = this.offset * M / 100 * this.direction, T = { trigger: this.DOM.el, start: "top bottom+=5%", end: "bottom top", scrub: 1 }; se.create({ trigger: (f = this.DOM.el) == null ? void 0 : f.parentElement, start: "top-=100% bottom", once: !0, onEnter: () => { se.refresh() } }), b.timeline({ scrollTrigger: T }).to(this.DOM.elInner, { y: `${m}%` }) } } class Ot { constructor() { F(this, "DOM"); this.DOM = { el: document.querySelector(".footer") }, this.DOM.el && (this.hander(), this.movingImageFooter(), this.initMotion()) } initMotion() { this.DOM.el && (R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el)) } hander() { var m; const M = (m = this.DOM.el) == null ? void 0 : m.querySelector(".footer-bottom-inner-back"); b.registerPlugin(pe), M == null || M.addEventListener("click", () => { b.to(window, { scrollTo: 0, duration: 1.2, ease: "power3.inOut" }) }) } movingImageFooter() { var o, l, r, h, n; const M = (o = this.DOM.el) == null ? void 0 : o.querySelector(".footer-middle-inner-img"), m = (l = this.DOM.el) == null ? void 0 : l.querySelector(".footer-middle-list-imgs"); new Ae({ el: m, offset: 25, direction: 1, scale: 1.3 }); const T = (r = this.DOM.el) == null ? void 0 : r.querySelectorAll(".footer-middle-list-imgs-item"), f = b.quickTo(M, "x", { duration: .9, ease: "power3.out" }), e = u => { T == null || T.forEach((a, t) => { t === u ? b.to(a, { opacity: 1, ease: "power3.out", duration: .6, willChange: "opacity" }) : b.to(a, { opacity: 0, ease: "power3.out", duration: .6 }) }) }; e(1), M.style.willChange = "transform", (h = this.DOM.el) == null || h.addEventListener("mousemove", u => { if (!this.DOM.el) return; const a = u.pageX, t = Te(a, 0, window.innerWidth, -1, 1), s = Math.floor(Te(a, 0, window.innerWidth, 0, (T == null ? void 0 : T.length) || 3)), i = (this.DOM.el.clientWidth - M.clientWidth) / 2; f(t * i), e(s) }), (n = this.DOM.el) == null || n.addEventListener("mouseleave", () => { f(0), e(1) }) } } class Tt { constructor() { F(this, "DOM"); this.DOM = { el: document.querySelector(".header"), footer: document.querySelector(".footer") }, this.show(), this.handleDropdownHoverLink(), this.handleDropdownToggle() } show() { var o, l; let M = 0; const m = document.querySelector('[data-page="support-center"]'); let T; if (!this.DOM.el) return; let f = !1, e = !1; m && ((o = this.DOM.el) == null || o.addEventListener("mouseenter", () => { var r; T && clearTimeout(T), (r = this.DOM.el) == null || r.classList.add("scrollDown"), e = !0 }), (l = this.DOM.el) == null || l.addEventListener("mouseleave", () => { T && clearTimeout(T), T = setTimeout(() => { var r; e = !1, f || (r = this.DOM.el) == null || r.classList.remove("scrollDown") }, 900) })), window.addEventListener("scroll", () => { var t; if (!this.DOM.el) return; const r = window.pageYOffset || document.documentElement.scrollTop || 0; f = r > this.DOM.el.clientHeight; const h = ((t = this.DOM.footer) == null ? void 0 : t.getBoundingClientRect().y) - this.DOM.el.clientHeight < 0, u = M < r && r > this.DOM.el.clientHeight * 2 || h, a = M > r && !h; if (u) this.DOM.el.classList.add("hidden"); else if (a) if (this.DOM.el.classList.remove("hidden"), f) this.DOM.el.classList.add("scrollDown"); else { if (e) return; this.DOM.el.classList.remove("scrollDown") } M = r }) } handleDropdownToggle() { if (!this.DOM.el) return; this.DOM.el.querySelectorAll(".header-nav-item-container").forEach(m => { const T = m.querySelector(".header-nav-item-ic"), f = m.querySelector(".header-dropdown"), e = m.querySelector(".header-nav-item-wrap"); if (!T || !f || !e) return; b.set(".header-dropdown", { height: 0, opacity: 1, overflow: "hidden" }); const o = () => { var h; const r = (h = f == null ? void 0 : f.querySelector(".header-dropdown-wrap")) == null ? void 0 : h.clientHeight; f.classList.remove("pre-none"), b.killTweensOf(m), b.to(T, { ease: "power3", duration: .4, rotate: 180 }), b.to(f, { ease: "power3.out", opacity: 1, height: r, duration: 1, overwrite: "auto", zIndex: 2 }) }, l = () => { f.classList.add("pre-none"), b.killTweensOf(m), b.to(T, { ease: "power3", duration: .4, rotate: 0 }), b.to(f, { ease: "power3.in", duration: .8, height: 0, zIndex: 1, overwrite: "auto" }) }; rt(() => { e.addEventListener("mouseenter", o), e.addEventListener("mouseleave", l), f.addEventListener("mouseenter", o), f.addEventListener("mouseleave", l) }) }) } handleDropdownHoverLink() { var T; if (!this.DOM.el) return; const M = this.DOM.el.querySelectorAll(".header-dropdown-link-txt"), m = (T = this.DOM.el.querySelector(".header-nav")) == null ? void 0 : T.childNodes; console.log("link", m), m.forEach((f, e) => { f.addEventListener("mouseenter", function () { const o = f.querySelector(".header-nav-item"), l = Array.from(m).indexOf(this); b.to(".header-nav-item", { opacity: .56, ease: "power3.out", duration: .8, overwrite: "auto", stagger: 0 }), e === l && b.to(o, { opacity: 1, ease: "power3.out", duration: .8, overwrite: "auto", stagger: 0 }) }), f.addEventListener("mouseleave", function () { b.to(".header-nav-item", { opacity: 1, ease: "power3.out", duration: .8, overwrite: "auto", stagger: 0 }) }) }), M.length && M.forEach(f => { f.addEventListener("mouseenter", function () { b.set(".header-dropdown-link-txt", { opacity: .56 }), b.set(f, { opacity: 1 }) }), f.addEventListener("mouseleave", function () { b.set(".header-dropdown-link-txt", { opacity: 1 }) }) }) } } const At = ({ el: k, isGsap: M = !0, isDebug: m, inScreen: T, onEnterBack: f, outScreen: e, threshold: o = 0, onToggle: l, onToggleOb: r, start: h, end: n }) => { let u = !1, a = null, t; return !ot() || M ? He(() => { a = se.create({ trigger: k, start: h || `top+=${o * 100}% bottom`, end: n || "bottom top", markers: m, onToggle: c => { u = c.isActive, l && l(c), u ? T && T() : e && e() }, onEnterBack: f, invalidateOnRefresh: !0 }) }) : He(() => { t = new IntersectionObserver(c => { u = c[0].isIntersecting, r && r(u), u ? T && T() : e && e() }, { threshold: o }), t.observe(k) }), { isInViewPointer: () => u, removeOb: () => { t && (t.unobserve(k), t.disconnect()), u = !1, a == null || a.kill(), a = null } } }; class Lt { constructor() { F(this, "DOM"); F(this, "isReady"); F(this, "inited"); F(this, "windowIsBlur"); F(this, "isSimpleLoader"); F(this, "minProgress"); F(this, "processing"); F(this, "registerCount"); F(this, "lowNet"); F(this, "strokeDashoffset"); F(this, "obServerAPI"); F(this, "idAnimationLoop"); F(this, "runAnimation"); F(this, "delayPageEnter"); F(this, "delaLoadingOut"); this.registerLoader = this.registerLoader.bind(this), this.unRegisterLoader = this.unRegisterLoader.bind(this), this.init() } init() { this.DOM = { main: document.querySelector(".page-loading") }, document.body.classList.add("js-ready", "is-loading"), W.emit(at), this.inited = !!this.DOM.main, this.isReady = !1, this.windowIsBlur = !1, this.isSimpleLoader = !1, this.minProgress = 98, this.delayPageEnter = 1.2, this.delaLoadingOut = .3, this.processing = { delta: 0, percentStuck: 0, runWidth: 0 }, this.registerCount = 0, this.lowNet = 0, this.strokeDashoffset = 829, this.hideLoading = this.hideLoading.bind(this), lt(() => (W.on(be, this.registerLoader), W.on(We, this.unRegisterLoader), window.addEventListener("DOMContentLoaded", this.hideLoading), () => { W.off(be, this.registerLoader), W.off(We, this.unRegisterLoader), window.removeEventListener("DOMContentLoaded", this.hideLoading) })) } simpleLoaded() { var M; (M = this.DOM.main) == null || M.classList.add("is-simple"), this.isSimpleLoader = !0, this.pageLoaded() } simple() { this.obServerAPI = At({ el: document.body }), this.isSimpleLoader = !0, this.isReady = !0, W.emit(ct), document.body.classList.add("is-ready") } hideLoading() { W.emit(ft) } hide() { ut(() => { this.DOM.main && (this.DOM.main.style.visibility = "hidden") }) } pageLoaded() { this.idAnimationLoop && cancelAnimationFrame(this.idAnimationLoop), document.body.classList.remove("is-loading"), document.body.classList.remove("is-simple"), W.emit(J), W.emit(ht), console.log("this.isSimpleLoader", this.isSimpleLoader), this.isSimpleLoader && (console.log("run_______"), this.DOM.main && b.to(this.DOM.main, { opacity: 0, duration: this.delayPageEnter, ease: "power3.inOut", onComplete: () => { setTimeout(() => this.hide(), 100), W.emit(Q), W.emit(dt) } })) } registerLoader() { this.registerCount++ } unRegisterLoader() { this.registerCount-- } } const Ge = new Lt; class It { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el), this.handleStackCard() } clear() { this.initParticles() } handleStackCard() { var n; const M = this.DOM.el.querySelector(".about-vision-sticky-inner"), T = this.DOM.el.querySelector(".about-vision-sticky-left").querySelectorAll(".about-sticky-left-card"), f = this.DOM.el.querySelector(".about-vision-sticky-right-inner"), e = (n = this.DOM.el.querySelector(".about-vision-sticky-right-inner")) == null ? void 0 : n.querySelectorAll(".about-sticky-right-img"), o = Pe((window.innerHeight - f.clientHeight) / 2); this.DOM.listImagesDesk = e; const l = () => { let u = null; console.log("preId", u); const a = b.timeline({ scrollTrigger: { trigger: ".about-vision-sticky", start: "top top", end() { return `bottom+=${window.innerHeight - f.clientHeight} bottom` }, scrub: 1, onUpdate: i => { const { progress: c } = i, p = Math.min(T.length - 1, Math.floor(ze(c, 0, 1, 0, T.length + 1 - .01))); s(p), u = p } } }); (i => { const c = Pe((f.clientHeight - q(3.2) * 2) / T.length); T.forEach(p => { a.to(p, { height: `${c}rem`, ease: "none", overwrite: "auto" }) }) })(); const s = i => { !Ce || !(e != null && e.length) || e.forEach((c, p) => { p === i ? (b.killTweensOf(c), b.to(c, { opacity: 1, ease: "power3", duration: .8 })) : b.to(c, { opacity: 0, ease: "power3", duration: .8 }) }) }; s(0), M.style.top = `${o}rem` }, r = () => { this.DOM.el.querySelectorAll(".about-sticky-left-card").forEach(a => { const t = a.querySelector(".about-sticky-left-card-inner-title"), s = (t == null ? void 0 : t.clientHeight) || 0, i = { root: null, rootMargin: "0px", threshold: 1 }, c = Pe(s) + 3.2 * 2; i.threshold = 0, h.call(this, i, c).observe(a) }) }; function h(u, a) { const t = new IntersectionObserver(s => { s.forEach(i => { if (i.isIntersecting) { const c = i.target; b.timeline({ scrollTrigger: { trigger: c, markers: !1, start: () => `top top+=${c.clientHeight + q(3.2) > window.innerHeight ? "0" : q(16)}`, end: () => `+=${q(16)}`, scrub: 1 } }).to(c, { height: `${a}rem`, ease: "none", onComplete: () => { se.refresh() } }), t.unobserve(c) } }) }, u); return t } Ce ? l() : (r(), this.handleReplaceUrlImg()) } handleReplaceUrlImg() { var T; const M = this.DOM.el.querySelectorAll(".about-img-mb"), m = (T = this.DOM.el.querySelector(".about-vision-sticky-right-inner")) == null ? void 0 : T.querySelectorAll(".about-sticky-right-img"); M.forEach((f, e) => { var h, n; const o = f.querySelector("img"); if (!m.length || !o) return; const l = (h = m[e].querySelector("img")) == null ? void 0 : h.getAttribute("src"), r = (n = m[e].querySelector("img")) == null ? void 0 : n.getAttribute("srcset"); l && r && (o.setAttribute("src", l), o.setAttribute("srcset", r)) }) } } class Et { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { this.initMotion(), this.handleDrawLine(), this.handleAction() } handleDrawLine() { const M = this.DOM.el.querySelectorAll(".changelog-item"); se.refresh(), console.log("listBlog_______", M), M.forEach((m, T) => { const f = m.querySelector(".line-draws"); if (f && (f.style.willChange = "transform", se.create({ trigger: m, start: () => `top ${T === 0 ? "bottom" : "center"}`, scrub: 1, end: "bottom center", onUpdate: ({ progress: e }) => { f.style.transform = `scaleY(${e})` } }), T > 3)) { const e = m.querySelectorAll(".js-fade"), o = m.querySelectorAll(".js-text-mask"); setTimeout(() => { e.forEach((l, r) => { new pt(l, { delay: r / 10 }) }), o.forEach((l, r) => { new gt(l, { delay: .05 }) }) }, 100) } }) } handleAction() { const M = this.DOM.el.querySelector(".changelog-more"); M == null || M.addEventListener("click", () => { console.log("run_________"), setTimeout(() => { this.handleDrawLine() }, 300) }), this.handleSubmit() } handleSubmit() { const M = this.DOM.el.querySelectorAll(".changelog-detail-right-btn-wrap"), m = this.DOM.el.querySelector('input[name="type"]'), T = this.DOM.el.querySelector('input[name="link"]'); M.forEach(f => { f.addEventListener("click", () => { var o; const e = (o = f.querySelector("[data-type-access]")) == null ? void 0 : o.getAttribute("data-type-access"); m.value = e || "", T.value = location.href, f.classList.add("active") }) }) } initMotion() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Bt { constructor(M) { F(this, "DOM"); this.DOM = { wrapper: M.querySelector(".home-feature-cards"), listCards: M.querySelectorAll(".home-feature-card") }, this.init() } init() { this.DOM.listCards.forEach((M, m, T) => { if (!Ce) return; const f = T[0].clientHeight, e = (window.innerHeight - f) / 2, o = T.length * q(8), l = Te(m, 0, T.length - 1, .8125, 1); M.style.top = `${e + o}px`, M.style.transform = `translateY(-${(T.length - m) * q(8)}px)`, b.timeline({ scrollTrigger: { trigger: M, start: () => "top center", end: `+=${(T.length - m) * f} `, scrub: 1 } }).to(M, { scale: l, transformOrigin: "top center", ease: "none" }, 0) }) } } var le = {}, kt = { get exports() { return le }, set exports(k) { le = k } };/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function (k, M) { (function (T, f) { k.exports = f() })(Me, function () { return function (m) { var T = {}; function f(e) { if (T[e]) return T[e].exports; var o = T[e] = { i: e, l: !1, exports: {} }; return m[e].call(o.exports, o, o.exports, f), o.l = !0, o.exports } return f.m = m, f.c = T, f.d = function (e, o, l) { f.o(e, o) || Object.defineProperty(e, o, { enumerable: !0, get: l }) }, f.r = function (e) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, f.t = function (e, o) { if (o & 1 && (e = f(e)), o & 8 || o & 4 && typeof e == "object" && e && e.__esModule) return e; var l = Object.create(null); if (f.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: e }), o & 2 && typeof e != "string") for (var r in e) f.d(l, r, function (h) { return e[h] }.bind(null, r)); return l }, f.n = function (e) { var o = e && e.__esModule ? function () { return e.default } : function () { return e }; return f.d(o, "a", o), o }, f.o = function (e, o) { return Object.prototype.hasOwnProperty.call(e, o) }, f.p = "", f(f.s = 20) }([function (m, T) { var f = {}; m.exports = f, function () { f._baseDelta = 1e3 / 60, f._nextId = 0, f._seed = 0, f._nowStartTime = +new Date, f._warnedOnce = {}, f._decomp = null, f.extend = function (o, l) { var r, h; typeof l == "boolean" ? (r = 2, h = l) : (r = 1, h = !0); for (var n = r; n < arguments.length; n++) { var u = arguments[n]; if (u) for (var a in u) h && u[a] && u[a].constructor === Object && (!o[a] || o[a].constructor === Object) ? (o[a] = o[a] || {}, f.extend(o[a], h, u[a])) : o[a] = u[a] } return o }, f.clone = function (o, l) { return f.extend({}, l, o) }, f.keys = function (o) { if (Object.keys) return Object.keys(o); var l = []; for (var r in o) l.push(r); return l }, f.values = function (o) { var l = []; if (Object.keys) { for (var r = Object.keys(o), h = 0; h < r.length; h++)l.push(o[r[h]]); return l } for (var n in o) l.push(o[n]); return l }, f.get = function (o, l, r, h) { l = l.split(".").slice(r, h); for (var n = 0; n < l.length; n += 1)o = o[l[n]]; return o }, f.set = function (o, l, r, h, n) { var u = l.split(".").slice(h, n); return f.get(o, l, 0, -1)[u[u.length - 1]] = r, r }, f.shuffle = function (o) { for (var l = o.length - 1; l > 0; l--) { var r = Math.floor(f.random() * (l + 1)), h = o[l]; o[l] = o[r], o[r] = h } return o }, f.choose = function (o) { return o[Math.floor(f.random() * o.length)] }, f.isElement = function (o) { return typeof HTMLElement < "u" ? o instanceof HTMLElement : !!(o && o.nodeType && o.nodeName) }, f.isArray = function (o) { return Object.prototype.toString.call(o) === "[object Array]" }, f.isFunction = function (o) { return typeof o == "function" }, f.isPlainObject = function (o) { return typeof o == "object" && o.constructor === Object }, f.isString = function (o) { return toString.call(o) === "[object String]" }, f.clamp = function (o, l, r) { return o < l ? l : o > r ? r : o }, f.sign = function (o) { return o < 0 ? -1 : 1 }, f.now = function () { if (typeof window < "u" && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - f._nowStartTime }, f.random = function (o, l) { return o = typeof o < "u" ? o : 0, l = typeof l < "u" ? l : 1, o + e() * (l - o) }; var e = function () { return f._seed = (f._seed * 9301 + 49297) % 233280, f._seed / 233280 }; f.colorToNumber = function (o) { return o = o.replace("#", ""), o.length == 3 && (o = o.charAt(0) + o.charAt(0) + o.charAt(1) + o.charAt(1) + o.charAt(2) + o.charAt(2)), parseInt(o, 16) }, f.logLevel = 1, f.log = function () { console && f.logLevel > 0 && f.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, f.info = function () { console && f.logLevel > 0 && f.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, f.warn = function () { console && f.logLevel > 0 && f.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, f.warnOnce = function () { var o = Array.prototype.slice.call(arguments).join(" "); f._warnedOnce[o] || (f.warn(o), f._warnedOnce[o] = !0) }, f.deprecated = function (o, l, r) { o[l] = f.chain(function () { f.warnOnce("🔅 deprecated 🔅", r) }, o[l]) }, f.nextId = function () { return f._nextId++ }, f.indexOf = function (o, l) { if (o.indexOf) return o.indexOf(l); for (var r = 0; r < o.length; r++)if (o[r] === l) return r; return -1 }, f.map = function (o, l) { if (o.map) return o.map(l); for (var r = [], h = 0; h < o.length; h += 1)r.push(l(o[h])); return r }, f.topologicalSort = function (o) { var l = [], r = [], h = []; for (var n in o) !r[n] && !h[n] && f._topologicalSort(n, r, h, o, l); return l }, f._topologicalSort = function (o, l, r, h, n) { var u = h[o] || []; r[o] = !0; for (var a = 0; a < u.length; a += 1) { var t = u[a]; r[t] || l[t] || f._topologicalSort(t, l, r, h, n) } r[o] = !1, l[o] = !0, n.push(o) }, f.chain = function () { for (var o = [], l = 0; l < arguments.length; l += 1) { var r = arguments[l]; r._chained ? o.push.apply(o, r._chained) : o.push(r) } var h = function () { for (var n, u = new Array(arguments.length), a = 0, t = arguments.length; a < t; a++)u[a] = arguments[a]; for (a = 0; a < o.length; a += 1) { var s = o[a].apply(n, u); typeof s < "u" && (n = s) } return n }; return h._chained = o, h }, f.chainPathBefore = function (o, l, r) { return f.set(o, l, f.chain(r, f.get(o, l))) }, f.chainPathAfter = function (o, l, r) { return f.set(o, l, f.chain(f.get(o, l), r)) }, f.setDecomp = function (o) { f._decomp = o }, f.getDecomp = function () { var o = f._decomp; try { !o && typeof window < "u" && (o = window.decomp), !o && typeof Me < "u" && (o = Me.decomp) } catch { o = null } return o } }() }, function (m, T) { var f = {}; m.exports = f, function () { f.create = function (e) { var o = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && f.update(o, e), o }, f.update = function (e, o, l) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var r = 0; r < o.length; r++) { var h = o[r]; h.x > e.max.x && (e.max.x = h.x), h.x < e.min.x && (e.min.x = h.x), h.y > e.max.y && (e.max.y = h.y), h.y < e.min.y && (e.min.y = h.y) } l && (l.x > 0 ? e.max.x += l.x : e.min.x += l.x, l.y > 0 ? e.max.y += l.y : e.min.y += l.y) }, f.contains = function (e, o) { return o.x >= e.min.x && o.x <= e.max.x && o.y >= e.min.y && o.y <= e.max.y }, f.overlaps = function (e, o) { return e.min.x <= o.max.x && e.max.x >= o.min.x && e.max.y >= o.min.y && e.min.y <= o.max.y }, f.translate = function (e, o) { e.min.x += o.x, e.max.x += o.x, e.min.y += o.y, e.max.y += o.y }, f.shift = function (e, o) { var l = e.max.x - e.min.x, r = e.max.y - e.min.y; e.min.x = o.x, e.max.x = o.x + l, e.min.y = o.y, e.max.y = o.y + r } }() }, function (m, T) { var f = {}; m.exports = f, function () { f.create = function (e, o) { return { x: e || 0, y: o || 0 } }, f.clone = function (e) { return { x: e.x, y: e.y } }, f.magnitude = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, f.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }, f.rotate = function (e, o, l) { var r = Math.cos(o), h = Math.sin(o); l || (l = {}); var n = e.x * r - e.y * h; return l.y = e.x * h + e.y * r, l.x = n, l }, f.rotateAbout = function (e, o, l, r) { var h = Math.cos(o), n = Math.sin(o); r || (r = {}); var u = l.x + ((e.x - l.x) * h - (e.y - l.y) * n); return r.y = l.y + ((e.x - l.x) * n + (e.y - l.y) * h), r.x = u, r }, f.normalise = function (e) { var o = f.magnitude(e); return o === 0 ? { x: 0, y: 0 } : { x: e.x / o, y: e.y / o } }, f.dot = function (e, o) { return e.x * o.x + e.y * o.y }, f.cross = function (e, o) { return e.x * o.y - e.y * o.x }, f.cross3 = function (e, o, l) { return (o.x - e.x) * (l.y - e.y) - (o.y - e.y) * (l.x - e.x) }, f.add = function (e, o, l) { return l || (l = {}), l.x = e.x + o.x, l.y = e.y + o.y, l }, f.sub = function (e, o, l) { return l || (l = {}), l.x = e.x - o.x, l.y = e.y - o.y, l }, f.mult = function (e, o) { return { x: e.x * o, y: e.y * o } }, f.div = function (e, o) { return { x: e.x / o, y: e.y / o } }, f.perp = function (e, o) { return o = o === !0 ? -1 : 1, { x: o * -e.y, y: o * e.x } }, f.neg = function (e) { return { x: -e.x, y: -e.y } }, f.angle = function (e, o) { return Math.atan2(o.y - e.y, o.x - e.x) }, f._temp = [f.create(), f.create(), f.create(), f.create(), f.create(), f.create()] }() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(2), l = f(0); (function () { e.create = function (r, h) { for (var n = [], u = 0; u < r.length; u++) { var a = r[u], t = { x: a.x, y: a.y, index: u, body: h, isInternal: !1 }; n.push(t) } return n }, e.fromPath = function (r, h) { var n = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, u = []; return r.replace(n, function (a, t, s) { u.push({ x: parseFloat(t), y: parseFloat(s) }) }), e.create(u, h) }, e.centre = function (r) { for (var h = e.area(r, !0), n = { x: 0, y: 0 }, u, a, t, s = 0; s < r.length; s++)t = (s + 1) % r.length, u = o.cross(r[s], r[t]), a = o.mult(o.add(r[s], r[t]), u), n = o.add(n, a); return o.div(n, 6 * h) }, e.mean = function (r) { for (var h = { x: 0, y: 0 }, n = 0; n < r.length; n++)h.x += r[n].x, h.y += r[n].y; return o.div(h, r.length) }, e.area = function (r, h) { for (var n = 0, u = r.length - 1, a = 0; a < r.length; a++)n += (r[u].x - r[a].x) * (r[u].y + r[a].y), u = a; return h ? n / 2 : Math.abs(n) / 2 }, e.inertia = function (r, h) { for (var n = 0, u = 0, a = r, t, s, i = 0; i < a.length; i++)s = (i + 1) % a.length, t = Math.abs(o.cross(a[s], a[i])), n += t * (o.dot(a[s], a[s]) + o.dot(a[s], a[i]) + o.dot(a[i], a[i])), u += t; return h / 6 * (n / u) }, e.translate = function (r, h, n) { n = typeof n < "u" ? n : 1; var u = r.length, a = h.x * n, t = h.y * n, s; for (s = 0; s < u; s++)r[s].x += a, r[s].y += t; return r }, e.rotate = function (r, h, n) { if (h !== 0) { var u = Math.cos(h), a = Math.sin(h), t = n.x, s = n.y, i = r.length, c, p, y, w; for (w = 0; w < i; w++)c = r[w], p = c.x - t, y = c.y - s, c.x = t + (p * u - y * a), c.y = s + (p * a + y * u); return r } }, e.contains = function (r, h) { for (var n = h.x, u = h.y, a = r.length, t = r[a - 1], s, i = 0; i < a; i++) { if (s = r[i], (n - t.x) * (s.y - t.y) + (u - t.y) * (t.x - s.x) > 0) return !1; t = s } return !0 }, e.scale = function (r, h, n, u) { if (h === 1 && n === 1) return r; u = u || e.centre(r); for (var a, t, s = 0; s < r.length; s++)a = r[s], t = o.sub(a, u), r[s].x = u.x + t.x * h, r[s].y = u.y + t.y * n; return r }, e.chamfer = function (r, h, n, u, a) { typeof h == "number" ? h = [h] : h = h || [8], n = typeof n < "u" ? n : -1, u = u || 2, a = a || 14; for (var t = [], s = 0; s < r.length; s++) { var i = r[s - 1 >= 0 ? s - 1 : r.length - 1], c = r[s], p = r[(s + 1) % r.length], y = h[s < h.length ? s : h.length - 1]; if (y === 0) { t.push(c); continue } var w = o.normalise({ x: c.y - i.y, y: i.x - c.x }), O = o.normalise({ x: p.y - c.y, y: c.x - p.x }), d = Math.sqrt(2 * Math.pow(y, 2)), v = o.mult(l.clone(w), y), x = o.normalise(o.mult(o.add(w, O), .5)), g = o.sub(c, o.mult(x, d)), P = n; n === -1 && (P = Math.pow(y, .32) * 1.75), P = l.clamp(P, u, a), P % 2 === 1 && (P += 1); for (var S = Math.acos(o.dot(w, O)), D = S / P, C = 0; C < P; C++)t.push(o.add(o.rotate(v, D * C), g)) } return t }, e.clockwiseSort = function (r) { var h = e.mean(r); return r.sort(function (n, u) { return o.angle(h, n) - o.angle(h, u) }), r }, e.isConvex = function (r) { var h = 0, n = r.length, u, a, t, s; if (n < 3) return null; for (u = 0; u < n; u++)if (a = (u + 1) % n, t = (u + 2) % n, s = (r[a].x - r[u].x) * (r[t].y - r[a].y), s -= (r[a].y - r[u].y) * (r[t].x - r[a].x), s < 0 ? h |= 1 : s > 0 && (h |= 2), h === 3) return !1; return h !== 0 ? !0 : null }, e.hull = function (r) { var h = [], n = [], u, a; for (r = r.slice(0), r.sort(function (t, s) { var i = t.x - s.x; return i !== 0 ? i : t.y - s.y }), a = 0; a < r.length; a += 1) { for (u = r[a]; n.length >= 2 && o.cross3(n[n.length - 2], n[n.length - 1], u) <= 0;)n.pop(); n.push(u) } for (a = r.length - 1; a >= 0; a -= 1) { for (u = r[a]; h.length >= 2 && o.cross3(h[h.length - 2], h[h.length - 1], u) <= 0;)h.pop(); h.push(u) } return h.pop(), n.pop(), h.concat(n) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(2), r = f(7), h = f(0), n = f(1), u = f(11); (function () { e._timeCorrection = !0, e._inertiaScale = 4, e._nextCollidingGroupId = 1, e._nextNonCollidingGroupId = -1, e._nextCategory = 1, e._baseDelta = 1e3 / 60, e.create = function (t) { var s = { id: h.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, deltaTime: 16.666666666666668, _original: null }, i = h.extend(s, t); return a(i, t), i }, e.nextGroup = function (t) { return t ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++ }, e.nextCategory = function () { return e._nextCategory = e._nextCategory << 1, e._nextCategory }; var a = function (t, s) { s = s || {}, e.set(t, { bounds: t.bounds || n.create(t.vertices), positionPrev: t.positionPrev || l.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), o.rotate(t.vertices, t.angle, t.position), u.rotate(t.axes, t.angle), n.update(t.bounds, t.vertices, t.velocity), e.set(t, { axes: s.axes || t.axes, area: s.area || t.area, mass: s.mass || t.mass, inertia: s.inertia || t.inertia }); var i = t.isStatic ? "#14151f" : h.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), c = t.isStatic ? "#555" : "#ccc", p = t.isStatic && t.render.fillStyle === null ? 1 : 0; t.render.fillStyle = t.render.fillStyle || i, t.render.strokeStyle = t.render.strokeStyle || c, t.render.lineWidth = t.render.lineWidth || p, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y) }; e.set = function (t, s, i) { var c; typeof s == "string" && (c = s, s = {}, s[c] = i); for (c in s) if (Object.prototype.hasOwnProperty.call(s, c)) switch (i = s[c], c) { case "isStatic": e.setStatic(t, i); break; case "isSleeping": r.set(t, i); break; case "mass": e.setMass(t, i); break; case "density": e.setDensity(t, i); break; case "inertia": e.setInertia(t, i); break; case "vertices": e.setVertices(t, i); break; case "position": e.setPosition(t, i); break; case "angle": e.setAngle(t, i); break; case "velocity": e.setVelocity(t, i); break; case "angularVelocity": e.setAngularVelocity(t, i); break; case "speed": e.setSpeed(t, i); break; case "angularSpeed": e.setAngularSpeed(t, i); break; case "parts": e.setParts(t, i); break; case "centre": e.setCentre(t, i); break; default: t[c] = i } }, e.setStatic = function (t, s) { for (var i = 0; i < t.parts.length; i++) { var c = t.parts[i]; s ? (c.isStatic || (c._original = { restitution: c.restitution, friction: c.friction, mass: c.mass, inertia: c.inertia, density: c.density, inverseMass: c.inverseMass, inverseInertia: c.inverseInertia }), c.restitution = 0, c.friction = 1, c.mass = c.inertia = c.density = 1 / 0, c.inverseMass = c.inverseInertia = 0, c.positionPrev.x = c.position.x, c.positionPrev.y = c.position.y, c.anglePrev = c.angle, c.angularVelocity = 0, c.speed = 0, c.angularSpeed = 0, c.motion = 0) : c._original && (c.restitution = c._original.restitution, c.friction = c._original.friction, c.mass = c._original.mass, c.inertia = c._original.inertia, c.density = c._original.density, c.inverseMass = c._original.inverseMass, c.inverseInertia = c._original.inverseInertia, c._original = null), c.isStatic = s } }, e.setMass = function (t, s) { var i = t.inertia / (t.mass / 6); t.inertia = i * (s / 6), t.inverseInertia = 1 / t.inertia, t.mass = s, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, e.setDensity = function (t, s) { e.setMass(t, s * t.area), t.density = s }, e.setInertia = function (t, s) { t.inertia = s, t.inverseInertia = 1 / t.inertia }, e.setVertices = function (t, s) { s[0].body === t ? t.vertices = s : t.vertices = o.create(s, t), t.axes = u.fromVertices(t.vertices), t.area = o.area(t.vertices), e.setMass(t, t.density * t.area); var i = o.centre(t.vertices); o.translate(t.vertices, i, -1), e.setInertia(t, e._inertiaScale * o.inertia(t.vertices, t.mass)), o.translate(t.vertices, t.position), n.update(t.bounds, t.vertices, t.velocity) }, e.setParts = function (t, s, i) { var c; for (s = s.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, c = 0; c < s.length; c++) { var p = s[c]; p !== t && (p.parent = t, t.parts.push(p)) } if (t.parts.length !== 1) { if (i = typeof i < "u" ? i : !0, i) { var y = []; for (c = 0; c < s.length; c++)y = y.concat(s[c].vertices); o.clockwiseSort(y); var w = o.hull(y), O = o.centre(w); e.setVertices(t, w), o.translate(t.vertices, O) } var d = e._totalProperties(t); t.area = d.area, t.parent = t, t.position.x = d.centre.x, t.position.y = d.centre.y, t.positionPrev.x = d.centre.x, t.positionPrev.y = d.centre.y, e.setMass(t, d.mass), e.setInertia(t, d.inertia), e.setPosition(t, d.centre) } }, e.setCentre = function (t, s, i) { i ? (t.positionPrev.x += s.x, t.positionPrev.y += s.y, t.position.x += s.x, t.position.y += s.y) : (t.positionPrev.x = s.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = s.y - (t.position.y - t.positionPrev.y), t.position.x = s.x, t.position.y = s.y) }, e.setPosition = function (t, s, i) { var c = l.sub(s, t.position); i ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = c.x, t.velocity.y = c.y, t.speed = l.magnitude(c)) : (t.positionPrev.x += c.x, t.positionPrev.y += c.y); for (var p = 0; p < t.parts.length; p++) { var y = t.parts[p]; y.position.x += c.x, y.position.y += c.y, o.translate(y.vertices, c), n.update(y.bounds, y.vertices, t.velocity) } }, e.setAngle = function (t, s, i) { var c = s - t.angle; i ? (t.anglePrev = t.angle, t.angularVelocity = c, t.angularSpeed = Math.abs(c)) : t.anglePrev += c; for (var p = 0; p < t.parts.length; p++) { var y = t.parts[p]; y.angle += c, o.rotate(y.vertices, c, t.position), u.rotate(y.axes, c), n.update(y.bounds, y.vertices, t.velocity), p > 0 && l.rotateAbout(y.position, c, t.position, y.position) } }, e.setVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.positionPrev.x = t.position.x - s.x * i, t.positionPrev.y = t.position.y - s.y * i, t.velocity.x = (t.position.x - t.positionPrev.x) / i, t.velocity.y = (t.position.y - t.positionPrev.y) / i, t.speed = l.magnitude(t.velocity) }, e.getVelocity = function (t) { var s = e._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * s, y: (t.position.y - t.positionPrev.y) * s } }, e.getSpeed = function (t) { return l.magnitude(e.getVelocity(t)) }, e.setSpeed = function (t, s) { e.setVelocity(t, l.mult(l.normalise(e.getVelocity(t)), s)) }, e.setAngularVelocity = function (t, s) { var i = t.deltaTime / e._baseDelta; t.anglePrev = t.angle - s * i, t.angularVelocity = (t.angle - t.anglePrev) / i, t.angularSpeed = Math.abs(t.angularVelocity) }, e.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * e._baseDelta / t.deltaTime }, e.getAngularSpeed = function (t) { return Math.abs(e.getAngularVelocity(t)) }, e.setAngularSpeed = function (t, s) { e.setAngularVelocity(t, h.sign(e.getAngularVelocity(t)) * s) }, e.translate = function (t, s, i) { e.setPosition(t, l.add(t.position, s), i) }, e.rotate = function (t, s, i, c) { if (!i) e.setAngle(t, t.angle + s, c); else { var p = Math.cos(s), y = Math.sin(s), w = t.position.x - i.x, O = t.position.y - i.y; e.setPosition(t, { x: i.x + (w * p - O * y), y: i.y + (w * y + O * p) }, c), e.setAngle(t, t.angle + s, c) } }, e.scale = function (t, s, i, c) { var p = 0, y = 0; c = c || t.position; for (var w = 0; w < t.parts.length; w++) { var O = t.parts[w]; o.scale(O.vertices, s, i, c), O.axes = u.fromVertices(O.vertices), O.area = o.area(O.vertices), e.setMass(O, t.density * O.area), o.translate(O.vertices, { x: -O.position.x, y: -O.position.y }), e.setInertia(O, e._inertiaScale * o.inertia(O.vertices, O.mass)), o.translate(O.vertices, { x: O.position.x, y: O.position.y }), w > 0 && (p += O.area, y += O.inertia), O.position.x = c.x + (O.position.x - c.x) * s, O.position.y = c.y + (O.position.y - c.y) * i, n.update(O.bounds, O.vertices, t.velocity) } t.parts.length > 1 && (t.area = p, t.isStatic || (e.setMass(t, t.density * p), e.setInertia(t, y))), t.circleRadius && (s === i ? t.circleRadius *= s : t.circleRadius = null) }, e.update = function (t, s) { s = (typeof s < "u" ? s : 1e3 / 60) * t.timeScale; var i = s * s, c = e._timeCorrection ? s / (t.deltaTime || s) : 1, p = 1 - t.frictionAir * (s / h._baseDelta), y = (t.position.x - t.positionPrev.x) * c, w = (t.position.y - t.positionPrev.y) * c; t.velocity.x = y * p + t.force.x / t.mass * i, t.velocity.y = w * p + t.force.y / t.mass * i, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = s, t.angularVelocity = (t.angle - t.anglePrev) * p * c + t.torque / t.inertia * i, t.anglePrev = t.angle, t.angle += t.angularVelocity; for (var O = 0; O < t.parts.length; O++) { var d = t.parts[O]; o.translate(d.vertices, t.velocity), O > 0 && (d.position.x += t.velocity.x, d.position.y += t.velocity.y), t.angularVelocity !== 0 && (o.rotate(d.vertices, t.angularVelocity, t.position), u.rotate(d.axes, t.angularVelocity), O > 0 && l.rotateAbout(d.position, t.angularVelocity, t.position, d.position)), n.update(d.bounds, d.vertices, t.velocity) } }, e.updateVelocities = function (t) { var s = e._baseDelta / t.deltaTime, i = t.velocity; i.x = (t.position.x - t.positionPrev.x) * s, i.y = (t.position.y - t.positionPrev.y) * s, t.speed = Math.sqrt(i.x * i.x + i.y * i.y), t.angularVelocity = (t.angle - t.anglePrev) * s, t.angularSpeed = Math.abs(t.angularVelocity) }, e.applyForce = function (t, s, i) { var c = { x: s.x - t.position.x, y: s.y - t.position.y }; t.force.x += i.x, t.force.y += i.y, t.torque += c.x * i.y - c.y * i.x }, e._totalProperties = function (t) { for (var s = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { var c = t.parts[i], p = c.mass !== 1 / 0 ? c.mass : 1; s.mass += p, s.area += c.area, s.inertia += c.inertia, s.centre = l.add(s.centre, l.mult(c.position, p)) } return s.centre = l.div(s.centre, s.mass), s } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(0); (function () { e.on = function (l, r, h) { for (var n = r.split(" "), u, a = 0; a < n.length; a++)u = n[a], l.events = l.events || {}, l.events[u] = l.events[u] || [], l.events[u].push(h); return h }, e.off = function (l, r, h) { if (!r) { l.events = {}; return } typeof r == "function" && (h = r, r = o.keys(l.events).join(" ")); for (var n = r.split(" "), u = 0; u < n.length; u++) { var a = l.events[n[u]], t = []; if (h && a) for (var s = 0; s < a.length; s++)a[s] !== h && t.push(a[s]); l.events[n[u]] = t } }, e.trigger = function (l, r, h) { var n, u, a, t, s = l.events; if (s && o.keys(s).length > 0) { h || (h = {}), n = r.split(" "); for (var i = 0; i < n.length; i++)if (u = n[i], a = s[u], a) { t = o.clone(h, !1), t.name = u, t.source = l; for (var c = 0; c < a.length; c++)a[c].apply(l, [t]) } } } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(5), l = f(0), r = f(1), h = f(4); (function () { e.create = function (n) { return l.extend({ id: l.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, n) }, e.setModified = function (n, u, a, t) { if (n.isModified = u, u && n.cache && (n.cache.allBodies = null, n.cache.allConstraints = null, n.cache.allComposites = null), a && n.parent && e.setModified(n.parent, u, a, t), t) for (var s = 0; s < n.composites.length; s++) { var i = n.composites[s]; e.setModified(i, u, a, t) } }, e.add = function (n, u) { var a = [].concat(u); o.trigger(n, "beforeAdd", { object: u }); for (var t = 0; t < a.length; t++) { var s = a[t]; switch (s.type) { case "body": if (s.parent !== s) { l.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } e.addBody(n, s); break; case "constraint": e.addConstraint(n, s); break; case "composite": e.addComposite(n, s); break; case "mouseConstraint": e.addConstraint(n, s.constraint); break } } return o.trigger(n, "afterAdd", { object: u }), n }, e.remove = function (n, u, a) { var t = [].concat(u); o.trigger(n, "beforeRemove", { object: u }); for (var s = 0; s < t.length; s++) { var i = t[s]; switch (i.type) { case "body": e.removeBody(n, i, a); break; case "constraint": e.removeConstraint(n, i, a); break; case "composite": e.removeComposite(n, i, a); break; case "mouseConstraint": e.removeConstraint(n, i.constraint); break } } return o.trigger(n, "afterRemove", { object: u }), n }, e.addComposite = function (n, u) { return n.composites.push(u), u.parent = n, e.setModified(n, !0, !0, !1), n }, e.removeComposite = function (n, u, a) { var t = l.indexOf(n.composites, u); if (t !== -1) { var s = e.allBodies(u); e.removeCompositeAt(n, t); for (var i = 0; i < s.length; i++)s[i].sleepCounter = 0 } if (a) for (var i = 0; i < n.composites.length; i++)e.removeComposite(n.composites[i], u, !0); return n }, e.removeCompositeAt = function (n, u) { return n.composites.splice(u, 1), e.setModified(n, !0, !0, !1), n }, e.addBody = function (n, u) { return n.bodies.push(u), e.setModified(n, !0, !0, !1), n }, e.removeBody = function (n, u, a) { var t = l.indexOf(n.bodies, u); if (t !== -1 && (e.removeBodyAt(n, t), u.sleepCounter = 0), a) for (var s = 0; s < n.composites.length; s++)e.removeBody(n.composites[s], u, !0); return n }, e.removeBodyAt = function (n, u) { return n.bodies.splice(u, 1), e.setModified(n, !0, !0, !1), n }, e.addConstraint = function (n, u) { return n.constraints.push(u), e.setModified(n, !0, !0, !1), n }, e.removeConstraint = function (n, u, a) { var t = l.indexOf(n.constraints, u); if (t !== -1 && e.removeConstraintAt(n, t), a) for (var s = 0; s < n.composites.length; s++)e.removeConstraint(n.composites[s], u, !0); return n }, e.removeConstraintAt = function (n, u) { return n.constraints.splice(u, 1), e.setModified(n, !0, !0, !1), n }, e.clear = function (n, u, a) { if (a) for (var t = 0; t < n.composites.length; t++)e.clear(n.composites[t], u, !0); return u ? n.bodies = n.bodies.filter(function (s) { return s.isStatic }) : n.bodies.length = 0, n.constraints.length = 0, n.composites.length = 0, e.setModified(n, !0, !0, !1), n }, e.allBodies = function (n) { if (n.cache && n.cache.allBodies) return n.cache.allBodies; for (var u = [].concat(n.bodies), a = 0; a < n.composites.length; a++)u = u.concat(e.allBodies(n.composites[a])); return n.cache && (n.cache.allBodies = u), u }, e.allConstraints = function (n) { if (n.cache && n.cache.allConstraints) return n.cache.allConstraints; for (var u = [].concat(n.constraints), a = 0; a < n.composites.length; a++)u = u.concat(e.allConstraints(n.composites[a])); return n.cache && (n.cache.allConstraints = u), u }, e.allComposites = function (n) { if (n.cache && n.cache.allComposites) return n.cache.allComposites; for (var u = [].concat(n.composites), a = 0; a < n.composites.length; a++)u = u.concat(e.allComposites(n.composites[a])); return n.cache && (n.cache.allComposites = u), u }, e.get = function (n, u, a) { var t, s; switch (a) { case "body": t = e.allBodies(n); break; case "constraint": t = e.allConstraints(n); break; case "composite": t = e.allComposites(n).concat(n); break }return t ? (s = t.filter(function (i) { return i.id.toString() === u.toString() }), s.length === 0 ? null : s[0]) : null }, e.move = function (n, u, a) { return e.remove(n, u), e.add(a, u), n }, e.rebase = function (n) { for (var u = e.allBodies(n).concat(e.allConstraints(n)).concat(e.allComposites(n)), a = 0; a < u.length; a++)u[a].id = l.nextId(); return n }, e.translate = function (n, u, a) { for (var t = a ? e.allBodies(n) : n.bodies, s = 0; s < t.length; s++)h.translate(t[s], u); return n }, e.rotate = function (n, u, a, t) { for (var s = Math.cos(u), i = Math.sin(u), c = t ? e.allBodies(n) : n.bodies, p = 0; p < c.length; p++) { var y = c[p], w = y.position.x - a.x, O = y.position.y - a.y; h.setPosition(y, { x: a.x + (w * s - O * i), y: a.y + (w * i + O * s) }), h.rotate(y, u) } return n }, e.scale = function (n, u, a, t, s) { for (var i = s ? e.allBodies(n) : n.bodies, c = 0; c < i.length; c++) { var p = i[c], y = p.position.x - t.x, w = p.position.y - t.y; h.setPosition(p, { x: t.x + y * u, y: t.y + w * a }), h.scale(p, u, a) } return n }, e.bounds = function (n) { for (var u = e.allBodies(n), a = [], t = 0; t < u.length; t += 1) { var s = u[t]; a.push(s.bounds.min, s.bounds.max) } return r.create(a) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(4), l = f(5), r = f(0); (function () { e._motionWakeThreshold = .18, e._motionSleepThreshold = .08, e._minBias = .9, e.update = function (h, n) { for (var u = n / r._baseDelta, a = e._motionSleepThreshold, t = 0; t < h.length; t++) { var s = h[t], i = o.getSpeed(s), c = o.getAngularSpeed(s), p = i * i + c * c; if (s.force.x !== 0 || s.force.y !== 0) { e.set(s, !1); continue } var y = Math.min(s.motion, p), w = Math.max(s.motion, p); s.motion = e._minBias * y + (1 - e._minBias) * w, s.sleepThreshold > 0 && s.motion < a ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold / u && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1) } }, e.afterCollisions = function (h) { for (var n = e._motionSleepThreshold, u = 0; u < h.length; u++) { var a = h[u]; if (a.isActive) { var t = a.collision, s = t.bodyA.parent, i = t.bodyB.parent; if (!(s.isSleeping && i.isSleeping || s.isStatic || i.isStatic) && (s.isSleeping || i.isSleeping)) { var c = s.isSleeping && !s.isStatic ? s : i, p = c === s ? i : s; !c.isStatic && p.motion > n && e.set(c, !1) } } } }, e.set = function (h, n) { var u = h.isSleeping; n ? (h.isSleeping = !0, h.sleepCounter = h.sleepThreshold, h.positionImpulse.x = 0, h.positionImpulse.y = 0, h.positionPrev.x = h.position.x, h.positionPrev.y = h.position.y, h.anglePrev = h.angle, h.speed = 0, h.angularSpeed = 0, h.motion = 0, u || l.trigger(h, "sleepStart")) : (h.isSleeping = !1, h.sleepCounter = 0, u && l.trigger(h, "sleepEnd")) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(9); (function () { var r = [], h = { overlap: 0, axis: null }, n = { overlap: 0, axis: null }; e.create = function (u, a) { return { pair: null, collided: !1, bodyA: u, bodyB: a, parentA: u.parent, parentB: a.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [null, null], supportCount: 0 } }, e.collides = function (u, a, t) { if (e._overlapAxes(h, u.vertices, a.vertices, u.axes), h.overlap <= 0 || (e._overlapAxes(n, a.vertices, u.vertices, a.axes), n.overlap <= 0)) return null; var s = t && t.table[l.id(u, a)], i; s ? i = s.collision : (i = e.create(u, a), i.collided = !0, i.bodyA = u.id < a.id ? u : a, i.bodyB = u.id < a.id ? a : u, i.parentA = i.bodyA.parent, i.parentB = i.bodyB.parent), u = i.bodyA, a = i.bodyB; var c; h.overlap < n.overlap ? c = h : c = n; var p = i.normal, y = i.tangent, w = i.penetration, O = i.supports, d = c.overlap, v = c.axis, x = v.x, g = v.y, P = a.position.x - u.position.x, S = a.position.y - u.position.y; x * P + g * S >= 0 && (x = -x, g = -g), p.x = x, p.y = g, y.x = -g, y.y = x, w.x = x * d, w.y = g * d, i.depth = d; var D = e._findSupports(u, a, p, 1), C = 0; if (o.contains(u.vertices, D[0]) && (O[C++] = D[0]), o.contains(u.vertices, D[1]) && (O[C++] = D[1]), C < 2) { var A = e._findSupports(a, u, p, -1); o.contains(a.vertices, A[0]) && (O[C++] = A[0]), C < 2 && o.contains(a.vertices, A[1]) && (O[C++] = A[1]) } return C === 0 && (O[C++] = D[0]), i.supportCount = C, i }, e._overlapAxes = function (u, a, t, s) { var i = a.length, c = t.length, p = a[0].x, y = a[0].y, w = t[0].x, O = t[0].y, d = s.length, v = Number.MAX_VALUE, x = 0, g, P, S, D, C, A; for (C = 0; C < d; C++) { var I = s[C], L = I.x, B = I.y, E = p * L + y * B, H = w * L + O * B, U = E, G = H; for (A = 1; A < i; A += 1)D = a[A].x * L + a[A].y * B, D > U ? U = D : D < E && (E = D); for (A = 1; A < c; A += 1)D = t[A].x * L + t[A].y * B, D > G ? G = D : D < H && (H = D); if (P = U - H, S = G - E, g = P < S ? P : S, g < v && (v = g, x = C, g <= 0)) break } u.axis = s[x], u.overlap = v }, e._findSupports = function (u, a, t, s) { var i = a.vertices, c = i.length, p = u.position.x, y = u.position.y, w = t.x * s, O = t.y * s, d = i[0], v = d, x = w * (p - v.x) + O * (y - v.y), g, P, S; for (S = 1; S < c; S += 1)v = i[S], P = w * (p - v.x) + O * (y - v.y), P < x && (x = P, d = v); return g = i[(c + d.index - 1) % c], x = w * (p - g.x) + O * (y - g.y), v = i[(d.index + 1) % c], w * (p - v.x) + O * (y - v.y) < x ? (r[0] = d, r[1] = v, r) : (r[0] = d, r[1] = g, r) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(16); (function () { e.create = function (l, r) { var h = l.bodyA, n = l.bodyB, u = { id: e.id(h, n), bodyA: h, bodyB: n, collision: l, contacts: [o.create(), o.create()], contactCount: 0, separation: 0, isActive: !0, isSensor: h.isSensor || n.isSensor, timeCreated: r, timeUpdated: r, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return e.update(u, l, r), u }, e.update = function (l, r, h) { var n = r.supports, u = r.supportCount, a = l.contacts, t = r.parentA, s = r.parentB; l.isActive = !0, l.timeUpdated = h, l.collision = r, l.separation = r.depth, l.inverseMass = t.inverseMass + s.inverseMass, l.friction = t.friction < s.friction ? t.friction : s.friction, l.frictionStatic = t.frictionStatic > s.frictionStatic ? t.frictionStatic : s.frictionStatic, l.restitution = t.restitution > s.restitution ? t.restitution : s.restitution, l.slop = t.slop > s.slop ? t.slop : s.slop, l.contactCount = u, r.pair = l; var i = n[0], c = a[0], p = n[1], y = a[1]; (y.vertex === i || c.vertex === p) && (a[1] = c, a[0] = c = y, y = a[1]), c.vertex = i, y.vertex = p }, e.setActive = function (l, r, h) { r ? (l.isActive = !0, l.timeUpdated = h) : (l.isActive = !1, l.contactCount = 0) }, e.id = function (l, r) { return l.id < r.id ? l.id.toString(36) + ":" + r.id.toString(36) : r.id.toString(36) + ":" + l.id.toString(36) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(2), r = f(7), h = f(1), n = f(11), u = f(0); (function () { e._warming = .4, e._torqueDampen = 1, e._minLength = 1e-6, e.create = function (a) { var t = a; t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var s = t.bodyA ? l.add(t.bodyA.position, t.pointA) : t.pointA, i = t.bodyB ? l.add(t.bodyB.position, t.pointB) : t.pointB, c = l.magnitude(l.sub(s, i)); t.length = typeof t.length < "u" ? t.length : c, t.id = t.id || u.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var p = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return t.length === 0 && t.stiffness > .1 ? (p.type = "pin", p.anchors = !1) : t.stiffness < .9 && (p.type = "spring"), t.render = u.extend(p, t.render), t }, e.preSolveAll = function (a) { for (var t = 0; t < a.length; t += 1) { var s = a[t], i = s.constraintImpulse; s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0 || (s.position.x += i.x, s.position.y += i.y, s.angle += i.angle) } }, e.solveAll = function (a, t) { for (var s = u.clamp(t / u._baseDelta, 0, 1), i = 0; i < a.length; i += 1) { var c = a[i], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, y = !c.bodyB || c.bodyB && c.bodyB.isStatic; (p || y) && e.solve(a[i], s) } for (i = 0; i < a.length; i += 1)c = a[i], p = !c.bodyA || c.bodyA && c.bodyA.isStatic, y = !c.bodyB || c.bodyB && c.bodyB.isStatic, !p && !y && e.solve(a[i], s) }, e.solve = function (a, t) { var s = a.bodyA, i = a.bodyB, c = a.pointA, p = a.pointB; if (!(!s && !i)) { s && !s.isStatic && (l.rotate(c, s.angle - a.angleA, c), a.angleA = s.angle), i && !i.isStatic && (l.rotate(p, i.angle - a.angleB, p), a.angleB = i.angle); var y = c, w = p; if (s && (y = l.add(s.position, c)), i && (w = l.add(i.position, p)), !(!y || !w)) { var O = l.sub(y, w), d = l.magnitude(O); d < e._minLength && (d = e._minLength); var v = (d - a.length) / d, x = a.stiffness >= 1 || a.length === 0, g = x ? a.stiffness * t : a.stiffness * t * t, P = a.damping * t, S = l.mult(O, v * g), D = (s ? s.inverseMass : 0) + (i ? i.inverseMass : 0), C = (s ? s.inverseInertia : 0) + (i ? i.inverseInertia : 0), A = D + C, I, L, B, E, H; if (P > 0) { var U = l.create(); B = l.div(O, d), H = l.sub(i && l.sub(i.position, i.positionPrev) || U, s && l.sub(s.position, s.positionPrev) || U), E = l.dot(B, H) } s && !s.isStatic && (L = s.inverseMass / D, s.constraintImpulse.x -= S.x * L, s.constraintImpulse.y -= S.y * L, s.position.x -= S.x * L, s.position.y -= S.y * L, P > 0 && (s.positionPrev.x -= P * B.x * E * L, s.positionPrev.y -= P * B.y * E * L), I = l.cross(c, S) / A * e._torqueDampen * s.inverseInertia * (1 - a.angularStiffness), s.constraintImpulse.angle -= I, s.angle -= I), i && !i.isStatic && (L = i.inverseMass / D, i.constraintImpulse.x += S.x * L, i.constraintImpulse.y += S.y * L, i.position.x += S.x * L, i.position.y += S.y * L, P > 0 && (i.positionPrev.x += P * B.x * E * L, i.positionPrev.y += P * B.y * E * L), I = l.cross(p, S) / A * e._torqueDampen * i.inverseInertia * (1 - a.angularStiffness), i.constraintImpulse.angle += I, i.angle += I) } } }, e.postSolveAll = function (a) { for (var t = 0; t < a.length; t++) { var s = a[t], i = s.constraintImpulse; if (!(s.isStatic || i.x === 0 && i.y === 0 && i.angle === 0)) { r.set(s, !1); for (var c = 0; c < s.parts.length; c++) { var p = s.parts[c]; o.translate(p.vertices, i), c > 0 && (p.position.x += i.x, p.position.y += i.y), i.angle !== 0 && (o.rotate(p.vertices, i.angle, s.position), n.rotate(p.axes, i.angle), c > 0 && l.rotateAbout(p.position, i.angle, s.position, p.position)), h.update(p.bounds, p.vertices, s.velocity) } i.angle *= e._warming, i.x *= e._warming, i.y *= e._warming } } }, e.pointAWorld = function (a) { return { x: (a.bodyA ? a.bodyA.position.x : 0) + (a.pointA ? a.pointA.x : 0), y: (a.bodyA ? a.bodyA.position.y : 0) + (a.pointA ? a.pointA.y : 0) } }, e.pointBWorld = function (a) { return { x: (a.bodyB ? a.bodyB.position.x : 0) + (a.pointB ? a.pointB.x : 0), y: (a.bodyB ? a.bodyB.position.y : 0) + (a.pointB ? a.pointB.y : 0) } }, e.currentLength = function (a) { var t = (a.bodyA ? a.bodyA.position.x : 0) + (a.pointA ? a.pointA.x : 0), s = (a.bodyA ? a.bodyA.position.y : 0) + (a.pointA ? a.pointA.y : 0), i = (a.bodyB ? a.bodyB.position.x : 0) + (a.pointB ? a.pointB.x : 0), c = (a.bodyB ? a.bodyB.position.y : 0) + (a.pointB ? a.pointB.y : 0), p = t - i, y = s - c; return Math.sqrt(p * p + y * y) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(2), l = f(0); (function () { e.fromVertices = function (r) { for (var h = {}, n = 0; n < r.length; n++) { var u = (n + 1) % r.length, a = o.normalise({ x: r[u].y - r[n].y, y: r[n].x - r[u].x }), t = a.y === 0 ? 1 / 0 : a.x / a.y; t = t.toFixed(3).toString(), h[t] = a } return l.values(h) }, e.rotate = function (r, h) { if (h !== 0) for (var n = Math.cos(h), u = Math.sin(h), a = 0; a < r.length; a++) { var t = r[a], s; s = t.x * n - t.y * u, t.y = t.x * u + t.y * n, t.x = s } } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(0), r = f(4), h = f(1), n = f(2); (function () { e.rectangle = function (u, a, t, s, i) { i = i || {}; var c = { label: "Rectangle Body", position: { x: u, y: a }, vertices: o.fromPath("L 0 0 L " + t + " 0 L " + t + " " + s + " L 0 " + s) }; if (i.chamfer) { var p = i.chamfer; c.vertices = o.chamfer(c.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete i.chamfer } return r.create(l.extend({}, c, i)) }, e.trapezoid = function (u, a, t, s, i, c) { c = c || {}, i >= 1 && l.warn("Bodies.trapezoid: slope parameter must be < 1."), i *= .5; var p = (1 - i * 2) * t, y = t * i, w = y + p, O = w + y, d; i < .5 ? d = "L 0 0 L " + y + " " + -s + " L " + w + " " + -s + " L " + O + " 0" : d = "L 0 0 L " + w + " " + -s + " L " + O + " 0"; var v = { label: "Trapezoid Body", position: { x: u, y: a }, vertices: o.fromPath(d) }; if (c.chamfer) { var x = c.chamfer; v.vertices = o.chamfer(v.vertices, x.radius, x.quality, x.qualityMin, x.qualityMax), delete c.chamfer } return r.create(l.extend({}, v, c)) }, e.circle = function (u, a, t, s, i) { s = s || {}; var c = { label: "Circle Body", circleRadius: t }; i = i || 25; var p = Math.ceil(Math.max(10, Math.min(i, t))); return p % 2 === 1 && (p += 1), e.polygon(u, a, p, t, l.extend({}, c, s)) }, e.polygon = function (u, a, t, s, i) { if (i = i || {}, t < 3) return e.circle(u, a, s, i); for (var c = 2 * Math.PI / t, p = "", y = c * .5, w = 0; w < t; w += 1) { var O = y + w * c, d = Math.cos(O) * s, v = Math.sin(O) * s; p += "L " + d.toFixed(3) + " " + v.toFixed(3) + " " } var x = { label: "Polygon Body", position: { x: u, y: a }, vertices: o.fromPath(p) }; if (i.chamfer) { var g = i.chamfer; x.vertices = o.chamfer(x.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete i.chamfer } return r.create(l.extend({}, x, i)) }, e.fromVertices = function (u, a, t, s, i, c, p, y) { var w = l.getDecomp(), O, d, v, x, g, P, S, D, C, A, I; for (O = !!(w && w.quickDecomp), s = s || {}, v = [], i = typeof i < "u" ? i : !1, c = typeof c < "u" ? c : .01, p = typeof p < "u" ? p : 10, y = typeof y < "u" ? y : .01, l.isArray(t[0]) || (t = [t]), A = 0; A < t.length; A += 1)if (P = t[A], x = o.isConvex(P), g = !x, g && !O && l.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), x || !O) x ? P = o.clockwiseSort(P) : P = o.hull(P), v.push({ position: { x: u, y: a }, vertices: P }); else { var L = P.map(function (V) { return [V.x, V.y] }); w.makeCCW(L), c !== !1 && w.removeCollinearPoints(L, c), y !== !1 && w.removeDuplicatePoints && w.removeDuplicatePoints(L, y); var B = w.quickDecomp(L); for (S = 0; S < B.length; S++) { var E = B[S], H = E.map(function (V) { return { x: V[0], y: V[1] } }); p > 0 && o.area(H) < p || v.push({ position: o.centre(H), vertices: H }) } } for (S = 0; S < v.length; S++)v[S] = r.create(l.extend(v[S], s)); if (i) { var U = 5; for (S = 0; S < v.length; S++) { var G = v[S]; for (D = S + 1; D < v.length; D++) { var N = v[D]; if (h.overlaps(G.bounds, N.bounds)) { var z = G.vertices, X = N.vertices; for (C = 0; C < G.vertices.length; C++)for (I = 0; I < N.vertices.length; I++) { var ae = n.magnitudeSquared(n.sub(z[(C + 1) % z.length], X[I])), j = n.magnitudeSquared(n.sub(z[C], X[(I + 1) % X.length])); ae < U && j < U && (z[C].isInternal = !0, X[I].isInternal = !0) } } } } } return v.length > 1 ? (d = r.create(l.extend({ parts: v.slice(0) }, s)), r.setPosition(d, { x: u, y: a }), d) : v[0] } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(0), l = f(8); (function () { e.create = function (r) { var h = { bodies: [], collisions: [], pairs: null }; return o.extend(h, r) }, e.setBodies = function (r, h) { r.bodies = h.slice(0) }, e.clear = function (r) { r.bodies = [], r.collisions = [] }, e.collisions = function (r) { var h = r.pairs, n = r.bodies, u = n.length, a = e.canCollide, t = l.collides, s = r.collisions, i = 0, c, p; for (n.sort(e._compareBoundsX), c = 0; c < u; c++) { var y = n[c], w = y.bounds, O = y.bounds.max.x, d = y.bounds.max.y, v = y.bounds.min.y, x = y.isStatic || y.isSleeping, g = y.parts.length, P = g === 1; for (p = c + 1; p < u; p++) { var S = n[p], D = S.bounds; if (D.min.x > O) break; if (!(d < D.min.y || v > D.max.y) && !(x && (S.isStatic || S.isSleeping)) && a(y.collisionFilter, S.collisionFilter)) { var C = S.parts.length; if (P && C === 1) { var A = t(y, S, h); A && (s[i++] = A) } else for (var I = g > 1 ? 1 : 0, L = C > 1 ? 1 : 0, B = I; B < g; B++)for (var E = y.parts[B], w = E.bounds, H = L; H < C; H++) { var U = S.parts[H], D = U.bounds; if (!(w.min.x > D.max.x || w.max.x < D.min.x || w.max.y < D.min.y || w.min.y > D.max.y)) { var A = t(E, U, h); A && (s[i++] = A) } } } } } return s.length !== i && (s.length = i), s }, e.canCollide = function (r, h) { return r.group === h.group && r.group !== 0 ? r.group > 0 : (r.mask & h.category) !== 0 && (h.mask & r.category) !== 0 }, e._compareBoundsX = function (r, h) { return r.bounds.min.x - h.bounds.min.x } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(0); (function () { e.create = function (l) { var r = {}; return l || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), r.element = l || document.body, r.absolute = { x: 0, y: 0 }, r.position = { x: 0, y: 0 }, r.mousedownPosition = { x: 0, y: 0 }, r.mouseupPosition = { x: 0, y: 0 }, r.offset = { x: 0, y: 0 }, r.scale = { x: 1, y: 1 }, r.wheelDelta = 0, r.button = -1, r.pixelRatio = parseInt(r.element.getAttribute("data-pixel-ratio"), 10) || 1, r.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, r.mousemove = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), u = h.changedTouches; u && (r.button = 0, h.preventDefault()), r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.sourceEvents.mousemove = h }, r.mousedown = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), u = h.changedTouches; u ? (r.button = 0, h.preventDefault()) : r.button = h.button, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mousedownPosition.x = r.position.x, r.mousedownPosition.y = r.position.y, r.sourceEvents.mousedown = h }, r.mouseup = function (h) { var n = e._getRelativeMousePosition(h, r.element, r.pixelRatio), u = h.changedTouches; u && h.preventDefault(), r.button = -1, r.absolute.x = n.x, r.absolute.y = n.y, r.position.x = r.absolute.x * r.scale.x + r.offset.x, r.position.y = r.absolute.y * r.scale.y + r.offset.y, r.mouseupPosition.x = r.position.x, r.mouseupPosition.y = r.position.y, r.sourceEvents.mouseup = h }, r.mousewheel = function (h) { r.wheelDelta = Math.max(-1, Math.min(1, h.wheelDelta || -h.detail)), h.preventDefault(), r.sourceEvents.mousewheel = h }, e.setElement(r, r.element), r }, e.setElement = function (l, r) { l.element = r, r.addEventListener("mousemove", l.mousemove, { passive: !0 }), r.addEventListener("mousedown", l.mousedown, { passive: !0 }), r.addEventListener("mouseup", l.mouseup, { passive: !0 }), r.addEventListener("wheel", l.mousewheel, { passive: !1 }), r.addEventListener("touchmove", l.mousemove, { passive: !1 }), r.addEventListener("touchstart", l.mousedown, { passive: !1 }), r.addEventListener("touchend", l.mouseup, { passive: !1 }) }, e.clearSourceEvents = function (l) { l.sourceEvents.mousemove = null, l.sourceEvents.mousedown = null, l.sourceEvents.mouseup = null, l.sourceEvents.mousewheel = null, l.wheelDelta = 0 }, e.setOffset = function (l, r) { l.offset.x = r.x, l.offset.y = r.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y }, e.setScale = function (l, r) { l.scale.x = r.x, l.scale.y = r.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y }, e._getRelativeMousePosition = function (l, r, h) { var n = r.getBoundingClientRect(), u = document.documentElement || document.body.parentNode || document.body, a = window.pageXOffset !== void 0 ? window.pageXOffset : u.scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : u.scrollTop, s = l.changedTouches, i, c; return s ? (i = s[0].pageX - n.left - a, c = s[0].pageY - n.top - t) : (i = l.pageX - n.left - a, c = l.pageY - n.top - t), { x: i / (r.clientWidth / (r.width || r.clientWidth) * h), y: c / (r.clientHeight / (r.height || r.clientHeight) * h) } } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(0); (function () { e._registry = {}, e.register = function (l) { if (e.isPlugin(l) || o.warn("Plugin.register:", e.toString(l), "does not implement all required fields."), l.name in e._registry) { var r = e._registry[l.name], h = e.versionParse(l.version).number, n = e.versionParse(r.version).number; h > n ? (o.warn("Plugin.register:", e.toString(r), "was upgraded to", e.toString(l)), e._registry[l.name] = l) : h < n ? o.warn("Plugin.register:", e.toString(r), "can not be downgraded to", e.toString(l)) : l !== r && o.warn("Plugin.register:", e.toString(l), "is already registered to different plugin object") } else e._registry[l.name] = l; return l }, e.resolve = function (l) { return e._registry[e.dependencyParse(l).name] }, e.toString = function (l) { return typeof l == "string" ? l : (l.name || "anonymous") + "@" + (l.version || l.range || "0.0.0") }, e.isPlugin = function (l) { return l && l.name && l.version && l.install }, e.isUsed = function (l, r) { return l.used.indexOf(r) > -1 }, e.isFor = function (l, r) { var h = l.for && e.dependencyParse(l.for); return !l.for || r.name === h.name && e.versionSatisfies(r.version, h.range) }, e.use = function (l, r) { if (l.uses = (l.uses || []).concat(r || []), l.uses.length === 0) { o.warn("Plugin.use:", e.toString(l), "does not specify any dependencies to install."); return } for (var h = e.dependencies(l), n = o.topologicalSort(h), u = [], a = 0; a < n.length; a += 1)if (n[a] !== l.name) { var t = e.resolve(n[a]); if (!t) { u.push("❌ " + n[a]); continue } e.isUsed(l, t.name) || (e.isFor(t, l) || (o.warn("Plugin.use:", e.toString(t), "is for", t.for, "but installed on", e.toString(l) + "."), t._warned = !0), t.install ? t.install(l) : (o.warn("Plugin.use:", e.toString(t), "does not specify an install function."), t._warned = !0), t._warned ? (u.push("🔶 " + e.toString(t)), delete t._warned) : u.push("✅ " + e.toString(t)), l.used.push(t.name)) } u.length > 0 && o.info(u.join("  ")) }, e.dependencies = function (l, r) { var h = e.dependencyParse(l), n = h.name; if (r = r || {}, !(n in r)) { l = e.resolve(l) || l, r[n] = o.map(l.uses || [], function (a) { e.isPlugin(a) && e.register(a); var t = e.dependencyParse(a), s = e.resolve(a); return s && !e.versionSatisfies(s.version, t.range) ? (o.warn("Plugin.dependencies:", e.toString(s), "does not satisfy", e.toString(t), "used by", e.toString(h) + "."), s._warned = !0, l._warned = !0) : s || (o.warn("Plugin.dependencies:", e.toString(a), "used by", e.toString(h), "could not be resolved."), l._warned = !0), t.name }); for (var u = 0; u < r[n].length; u += 1)e.dependencies(r[n][u], r); return r } }, e.dependencyParse = function (l) { if (o.isString(l)) { var r = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/; return r.test(l) || o.warn("Plugin.dependencyParse:", l, "is not a valid dependency string."), { name: l.split("@")[0], range: l.split("@")[1] || "*" } } return { name: l.name, range: l.range || l.version } }, e.versionParse = function (l) { var r = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; r.test(l) || o.warn("Plugin.versionParse:", l, "is not a valid version or range."); var h = r.exec(l), n = Number(h[4]), u = Number(h[5]), a = Number(h[6]); return { isRange: !!(h[1] || h[2]), version: h[3], range: l, operator: h[1] || h[2] || "", major: n, minor: u, patch: a, parts: [n, u, a], prerelease: h[7], number: n * 1e8 + u * 1e4 + a } }, e.versionSatisfies = function (l, r) { r = r || "*"; var h = e.versionParse(r), n = e.versionParse(l); if (h.isRange) { if (h.operator === "*" || l === "*") return !0; if (h.operator === ">") return n.number > h.number; if (h.operator === ">=") return n.number >= h.number; if (h.operator === "~") return n.major === h.major && n.minor === h.minor && n.patch >= h.patch; if (h.operator === "^") return h.major > 0 ? n.major === h.major && n.number >= h.number : h.minor > 0 ? n.minor === h.minor && n.patch >= h.patch : n.patch === h.patch } return l === r || l === "*" } })() }, function (m, T) { var f = {}; m.exports = f, function () { f.create = function (e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(7), l = f(18), r = f(13), h = f(19), n = f(5), u = f(6), a = f(10), t = f(0), s = f(4); (function () { e._deltaMax = 1e3 / 60, e.create = function (i) { i = i || {}; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0, lastUpdatesPerFrame: 0 } }, p = t.extend(c, i); return p.world = i.world || u.create({ label: "World" }), p.pairs = i.pairs || h.create(), p.detector = i.detector || r.create(), p.detector.pairs = p.pairs, p.grid = { buckets: [] }, p.world.gravity = p.gravity, p.broadphase = p.grid, p.metrics = {}, p }, e.update = function (i, c) { var p = t.now(), y = i.world, w = i.detector, O = i.pairs, d = i.timing, v = d.timestamp, x; c > e._deltaMax && t.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", e._deltaMax.toFixed(3), "ms."), c = typeof c < "u" ? c : t._baseDelta, c *= d.timeScale, d.timestamp += c, d.lastDelta = c; var g = { timestamp: d.timestamp, delta: c }; n.trigger(i, "beforeUpdate", g); var P = u.allBodies(y), S = u.allConstraints(y); for (y.isModified && (r.setBodies(w, P), u.setModified(y, !1, !1, !0)), i.enableSleeping && o.update(P, c), e._bodiesApplyGravity(P, i.gravity), c > 0 && e._bodiesUpdate(P, c), n.trigger(i, "beforeSolve", g), a.preSolveAll(P), x = 0; x < i.constraintIterations; x++)a.solveAll(S, c); a.postSolveAll(P); var D = r.collisions(w); h.update(O, D, v), i.enableSleeping && o.afterCollisions(O.list), O.collisionStart.length > 0 && n.trigger(i, "collisionStart", { pairs: O.collisionStart, timestamp: d.timestamp, delta: c }); var C = t.clamp(20 / i.positionIterations, 0, 1); for (l.preSolvePosition(O.list), x = 0; x < i.positionIterations; x++)l.solvePosition(O.list, c, C); for (l.postSolvePosition(P), a.preSolveAll(P), x = 0; x < i.constraintIterations; x++)a.solveAll(S, c); for (a.postSolveAll(P), l.preSolveVelocity(O.list), x = 0; x < i.velocityIterations; x++)l.solveVelocity(O.list, c); return e._bodiesUpdateVelocities(P), O.collisionActive.length > 0 && n.trigger(i, "collisionActive", { pairs: O.collisionActive, timestamp: d.timestamp, delta: c }), O.collisionEnd.length > 0 && n.trigger(i, "collisionEnd", { pairs: O.collisionEnd, timestamp: d.timestamp, delta: c }), e._bodiesClearForces(P), n.trigger(i, "afterUpdate", g), i.timing.lastElapsed = t.now() - p, i }, e.merge = function (i, c) { if (t.extend(i, c), c.world) { i.world = c.world, e.clear(i); for (var p = u.allBodies(i.world), y = 0; y < p.length; y++) { var w = p[y]; o.set(w, !1), w.id = t.nextId() } } }, e.clear = function (i) { h.clear(i.pairs), r.clear(i.detector) }, e._bodiesClearForces = function (i) { for (var c = i.length, p = 0; p < c; p++) { var y = i[p]; y.force.x = 0, y.force.y = 0, y.torque = 0 } }, e._bodiesApplyGravity = function (i, c) { var p = typeof c.scale < "u" ? c.scale : .001, y = i.length; if (!(c.x === 0 && c.y === 0 || p === 0)) for (var w = 0; w < y; w++) { var O = i[w]; O.isStatic || O.isSleeping || (O.force.y += O.mass * c.y * p, O.force.x += O.mass * c.x * p) } }, e._bodiesUpdate = function (i, c) { for (var p = i.length, y = 0; y < p; y++) { var w = i[y]; w.isStatic || w.isSleeping || s.update(w, c) } }, e._bodiesUpdateVelocities = function (i) { for (var c = i.length, p = 0; p < c; p++)s.updateVelocities(i[p]) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(0), r = f(1); (function () { e._restingThresh = 2, e._restingThreshTangent = Math.sqrt(6), e._positionDampen = .9, e._positionWarming = .8, e._frictionNormalMultiplier = 5, e._frictionMaxStatic = Number.MAX_VALUE, e.preSolvePosition = function (h) { var n, u, a, t = h.length; for (n = 0; n < t; n++)u = h[n], u.isActive && (a = u.contactCount, u.collision.parentA.totalContacts += a, u.collision.parentB.totalContacts += a) }, e.solvePosition = function (h, n, u) { var a, t, s, i, c, p, y, w, O = e._positionDampen * (u || 1), d = l.clamp(n / l._baseDelta, 0, 1), v = h.length; for (a = 0; a < v; a++)t = h[a], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, c = s.parentB, p = s.normal, t.separation = s.depth + p.x * (c.positionImpulse.x - i.positionImpulse.x) + p.y * (c.positionImpulse.y - i.positionImpulse.y)); for (a = 0; a < v; a++)t = h[a], !(!t.isActive || t.isSensor) && (s = t.collision, i = s.parentA, c = s.parentB, p = s.normal, w = t.separation - t.slop * d, (i.isStatic || c.isStatic) && (w *= 2), i.isStatic || i.isSleeping || (y = O / i.totalContacts, i.positionImpulse.x += p.x * w * y, i.positionImpulse.y += p.y * w * y), c.isStatic || c.isSleeping || (y = O / c.totalContacts, c.positionImpulse.x -= p.x * w * y, c.positionImpulse.y -= p.y * w * y)) }, e.postSolvePosition = function (h) { for (var n = e._positionWarming, u = h.length, a = o.translate, t = r.update, s = 0; s < u; s++) { var i = h[s], c = i.positionImpulse, p = c.x, y = c.y, w = i.velocity; if (i.totalContacts = 0, p !== 0 || y !== 0) { for (var O = 0; O < i.parts.length; O++) { var d = i.parts[O]; a(d.vertices, c), t(d.bounds, d.vertices, w), d.position.x += p, d.position.y += y } i.positionPrev.x += p, i.positionPrev.y += y, p * w.x + y * w.y < 0 ? (c.x = 0, c.y = 0) : (c.x *= n, c.y *= n) } } }, e.preSolveVelocity = function (h) { var n = h.length, u, a; for (u = 0; u < n; u++) { var t = h[u]; if (!(!t.isActive || t.isSensor)) { var s = t.contacts, i = t.contactCount, c = t.collision, p = c.parentA, y = c.parentB, w = c.normal, O = c.tangent; for (a = 0; a < i; a++) { var d = s[a], v = d.vertex, x = d.normalImpulse, g = d.tangentImpulse; if (x !== 0 || g !== 0) { var P = w.x * x + O.x * g, S = w.y * x + O.y * g; p.isStatic || p.isSleeping || (p.positionPrev.x += P * p.inverseMass, p.positionPrev.y += S * p.inverseMass, p.anglePrev += p.inverseInertia * ((v.x - p.position.x) * S - (v.y - p.position.y) * P)), y.isStatic || y.isSleeping || (y.positionPrev.x -= P * y.inverseMass, y.positionPrev.y -= S * y.inverseMass, y.anglePrev -= y.inverseInertia * ((v.x - y.position.x) * S - (v.y - y.position.y) * P)) } } } } }, e.solveVelocity = function (h, n) { var u = n / l._baseDelta, a = u * u, t = a * u, s = -e._restingThresh * u, i = e._restingThreshTangent, c = e._frictionNormalMultiplier * u, p = e._frictionMaxStatic, y = h.length, w, O, d, v; for (d = 0; d < y; d++) { var x = h[d]; if (!(!x.isActive || x.isSensor)) { var g = x.collision, P = g.parentA, S = g.parentB, D = g.normal.x, C = g.normal.y, A = g.tangent.x, I = g.tangent.y, L = x.inverseMass, B = x.friction * x.frictionStatic * c, E = x.contacts, H = x.contactCount, U = 1 / H, G = P.position.x - P.positionPrev.x, N = P.position.y - P.positionPrev.y, z = P.angle - P.anglePrev, X = S.position.x - S.positionPrev.x, ae = S.position.y - S.positionPrev.y, j = S.angle - S.anglePrev; for (v = 0; v < H; v++) { var V = E[v], _ = V.vertex, $ = _.x - P.position.x, ue = _.y - P.position.y, ee = _.x - S.position.x, te = _.y - S.position.y, K = G - ue * z, je = N + $ * z, _e = X - te * j, et = ae + ee * j, Le = K - _e, Ie = je - et, ye = D * Le + C * Ie, re = A * Le + I * Ie, Ee = x.separation + ye, Se = Math.min(Ee, 1); Se = Ee < 0 ? 0 : Se; var Be = Se * B; re < -Be || re > Be ? (O = re > 0 ? re : -re, w = x.friction * (re > 0 ? 1 : -1) * t, w < -O ? w = -O : w > O && (w = O)) : (w = re, O = p); var ke = $ * C - ue * D, Re = ee * C - te * D, Fe = U / (L + P.inverseInertia * ke * ke + S.inverseInertia * Re * Re), ge = (1 + x.restitution) * ye * Fe; if (w *= Fe, ye < s) V.normalImpulse = 0; else { var tt = V.normalImpulse; V.normalImpulse += ge, V.normalImpulse > 0 && (V.normalImpulse = 0), ge = V.normalImpulse - tt } if (re < -i || re > i) V.tangentImpulse = 0; else { var it = V.tangentImpulse; V.tangentImpulse += w, V.tangentImpulse < -O && (V.tangentImpulse = -O), V.tangentImpulse > O && (V.tangentImpulse = O), w = V.tangentImpulse - it } var ve = D * ge + A * w, me = C * ge + I * w; P.isStatic || P.isSleeping || (P.positionPrev.x += ve * P.inverseMass, P.positionPrev.y += me * P.inverseMass, P.anglePrev += ($ * me - ue * ve) * P.inverseInertia), S.isStatic || S.isSleeping || (S.positionPrev.x -= ve * S.inverseMass, S.positionPrev.y -= me * S.inverseMass, S.anglePrev -= (ee * me - te * ve) * S.inverseInertia) } } } } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(9), l = f(0); (function () { e.create = function (r) { return l.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, r) }, e.update = function (r, h, n) { var u = o.update, a = o.create, t = o.setActive, s = r.table, i = r.list, c = i.length, p = c, y = r.collisionStart, w = r.collisionEnd, O = r.collisionActive, d = h.length, v = 0, x = 0, g = 0, P, S, D; for (D = 0; D < d; D++)P = h[D], S = P.pair, S ? (S.isActive && (O[g++] = S), u(S, P, n)) : (S = a(P, n), s[S.id] = S, y[v++] = S, i[p++] = S); for (p = 0, c = i.length, D = 0; D < c; D++)S = i[D], S.timeUpdated >= n ? i[p++] = S : (t(S, !1, n), S.collision.bodyA.sleepCounter > 0 && S.collision.bodyB.sleepCounter > 0 ? i[p++] = S : (w[x++] = S, delete s[S.id])); i.length !== p && (i.length = p), y.length !== v && (y.length = v), w.length !== x && (w.length = x), O.length !== g && (O.length = g) }, e.clear = function (r) { return r.table = {}, r.list.length = 0, r.collisionStart.length = 0, r.collisionActive.length = 0, r.collisionEnd.length = 0, r } })() }, function (m, T, f) { var e = m.exports = f(21); e.Axes = f(11), e.Bodies = f(12), e.Body = f(4), e.Bounds = f(1), e.Collision = f(8), e.Common = f(0), e.Composite = f(6), e.Composites = f(22), e.Constraint = f(10), e.Contact = f(16), e.Detector = f(13), e.Engine = f(17), e.Events = f(5), e.Grid = f(23), e.Mouse = f(14), e.MouseConstraint = f(24), e.Pair = f(9), e.Pairs = f(19), e.Plugin = f(15), e.Query = f(25), e.Render = f(26), e.Resolver = f(18), e.Runner = f(27), e.SAT = f(28), e.Sleeping = f(7), e.Svg = f(29), e.Vector = f(2), e.Vertices = f(3), e.World = f(30), e.Engine.run = e.Runner.run, e.Common.deprecated(e.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function (m, T, f) { var e = {}; m.exports = e; var o = f(15), l = f(0); (function () { e.name = "matter-js", e.version = "0.20.0", e.uses = [], e.used = [], e.use = function () { o.use(e, Array.prototype.slice.call(arguments)) }, e.before = function (r, h) { return r = r.replace(/^Matter./, ""), l.chainPathBefore(e, r, h) }, e.after = function (r, h) { return r = r.replace(/^Matter./, ""), l.chainPathAfter(e, r, h) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(6), l = f(10), r = f(0), h = f(4), n = f(12), u = r.deprecated; (function () { e.stack = function (a, t, s, i, c, p, y) { for (var w = o.create({ label: "Stack" }), O = a, d = t, v, x = 0, g = 0; g < i; g++) { for (var P = 0, S = 0; S < s; S++) { var D = y(O, d, S, g, v, x); if (D) { var C = D.bounds.max.y - D.bounds.min.y, A = D.bounds.max.x - D.bounds.min.x; C > P && (P = C), h.translate(D, { x: A * .5, y: C * .5 }), O = D.bounds.max.x + c, o.addBody(w, D), v = D, x += 1 } else O += c } d += P + p, O = a } return w }, e.chain = function (a, t, s, i, c, p) { for (var y = a.bodies, w = 1; w < y.length; w++) { var O = y[w - 1], d = y[w], v = O.bounds.max.y - O.bounds.min.y, x = O.bounds.max.x - O.bounds.min.x, g = d.bounds.max.y - d.bounds.min.y, P = d.bounds.max.x - d.bounds.min.x, S = { bodyA: O, pointA: { x: x * t, y: v * s }, bodyB: d, pointB: { x: P * i, y: g * c } }, D = r.extend(S, p); o.addConstraint(a, l.create(D)) } return a.label += " Chain", a }, e.mesh = function (a, t, s, i, c) { var p = a.bodies, y, w, O, d, v; for (y = 0; y < s; y++) { for (w = 1; w < t; w++)O = p[w - 1 + y * t], d = p[w + y * t], o.addConstraint(a, l.create(r.extend({ bodyA: O, bodyB: d }, c))); if (y > 0) for (w = 0; w < t; w++)O = p[w + (y - 1) * t], d = p[w + y * t], o.addConstraint(a, l.create(r.extend({ bodyA: O, bodyB: d }, c))), i && w > 0 && (v = p[w - 1 + (y - 1) * t], o.addConstraint(a, l.create(r.extend({ bodyA: v, bodyB: d }, c)))), i && w < t - 1 && (v = p[w + 1 + (y - 1) * t], o.addConstraint(a, l.create(r.extend({ bodyA: v, bodyB: d }, c)))) } return a.label += " Mesh", a }, e.pyramid = function (a, t, s, i, c, p, y) { return e.stack(a, t, s, i, c, p, function (w, O, d, v, x, g) { var P = Math.min(i, Math.ceil(s / 2)), S = x ? x.bounds.max.x - x.bounds.min.x : 0; if (!(v > P)) { v = P - v; var D = v, C = s - 1 - v; if (!(d < D || d > C)) { g === 1 && h.translate(x, { x: (d + (s % 2 === 1 ? 1 : -1)) * S, y: 0 }); var A = x ? d * S : 0; return y(a + A + d * c, O, d, v, x, g) } } }) }, e.newtonsCradle = function (a, t, s, i, c) { for (var p = o.create({ label: "Newtons Cradle" }), y = 0; y < s; y++) { var w = 1.9, O = n.circle(a + y * (i * w), t + c, i, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), d = l.create({ pointA: { x: a + y * (i * w), y: t }, bodyB: O }); o.addBody(p, O), o.addConstraint(p, d) } return p }, u(e, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), e.car = function (a, t, s, i, c) { var p = h.nextGroup(!0), y = 20, w = -s * .5 + y, O = s * .5 - y, d = 0, v = o.create({ label: "Car" }), x = n.rectangle(a, t, s, i, { collisionFilter: { group: p }, chamfer: { radius: i * .5 }, density: 2e-4 }), g = n.circle(a + w, t + d, c, { collisionFilter: { group: p }, friction: .8 }), P = n.circle(a + O, t + d, c, { collisionFilter: { group: p }, friction: .8 }), S = l.create({ bodyB: x, pointB: { x: w, y: d }, bodyA: g, stiffness: 1, length: 0 }), D = l.create({ bodyB: x, pointB: { x: O, y: d }, bodyA: P, stiffness: 1, length: 0 }); return o.addBody(v, x), o.addBody(v, g), o.addBody(v, P), o.addConstraint(v, S), o.addConstraint(v, D), v }, u(e, "car", "Composites.car ➤ moved to car example"), e.softBody = function (a, t, s, i, c, p, y, w, O, d) { O = r.extend({ inertia: 1 / 0 }, O), d = r.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, d); var v = e.stack(a, t, s, i, c, p, function (x, g) { return n.circle(x, g, w, O) }); return e.mesh(v, s, i, y, d), v.label = "Soft Body", v }, u(e, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(9), l = f(0), r = l.deprecated; (function () { e.create = function (h) { var n = { buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return l.extend(n, h) }, e.update = function (h, n, u, a) { var t, s, i, c = u.world, p = h.buckets, y, w, O = !1; for (t = 0; t < n.length; t++) { var d = n[t]; if (!(d.isSleeping && !a) && !(c.bounds && (d.bounds.max.x < c.bounds.min.x || d.bounds.min.x > c.bounds.max.x || d.bounds.max.y < c.bounds.min.y || d.bounds.min.y > c.bounds.max.y))) { var v = e._getRegion(h, d); if (!d.region || v.id !== d.region.id || a) { (!d.region || a) && (d.region = v); var x = e._regionUnion(v, d.region); for (s = x.startCol; s <= x.endCol; s++)for (i = x.startRow; i <= x.endRow; i++) { w = e._getBucketId(s, i), y = p[w]; var g = s >= v.startCol && s <= v.endCol && i >= v.startRow && i <= v.endRow, P = s >= d.region.startCol && s <= d.region.endCol && i >= d.region.startRow && i <= d.region.endRow; !g && P && P && y && e._bucketRemoveBody(h, y, d), (d.region === v || g && !P || a) && (y || (y = e._createBucket(p, w)), e._bucketAddBody(h, y, d)) } d.region = v, O = !0 } } } O && (h.pairsList = e._createActivePairsList(h)) }, r(e, "update", "Grid.update ➤ replaced by Matter.Detector"), e.clear = function (h) { h.buckets = {}, h.pairs = {}, h.pairsList = [] }, r(e, "clear", "Grid.clear ➤ replaced by Matter.Detector"), e._regionUnion = function (h, n) { var u = Math.min(h.startCol, n.startCol), a = Math.max(h.endCol, n.endCol), t = Math.min(h.startRow, n.startRow), s = Math.max(h.endRow, n.endRow); return e._createRegion(u, a, t, s) }, e._getRegion = function (h, n) { var u = n.bounds, a = Math.floor(u.min.x / h.bucketWidth), t = Math.floor(u.max.x / h.bucketWidth), s = Math.floor(u.min.y / h.bucketHeight), i = Math.floor(u.max.y / h.bucketHeight); return e._createRegion(a, t, s, i) }, e._createRegion = function (h, n, u, a) { return { id: h + "," + n + "," + u + "," + a, startCol: h, endCol: n, startRow: u, endRow: a } }, e._getBucketId = function (h, n) { return "C" + h + "R" + n }, e._createBucket = function (h, n) { var u = h[n] = []; return u }, e._bucketAddBody = function (h, n, u) { var a = h.pairs, t = o.id, s = n.length, i; for (i = 0; i < s; i++) { var c = n[i]; if (!(u.id === c.id || u.isStatic && c.isStatic)) { var p = t(u, c), y = a[p]; y ? y[2] += 1 : a[p] = [u, c, 1] } } n.push(u) }, e._bucketRemoveBody = function (h, n, u) { var a = h.pairs, t = o.id, s; n.splice(l.indexOf(n, u), 1); var i = n.length; for (s = 0; s < i; s++) { var c = a[t(u, n[s])]; c && (c[2] -= 1) } }, e._createActivePairsList = function (h) { var n, u = h.pairs, a = l.keys(u), t = a.length, s = [], i; for (i = 0; i < t; i++)n = u[a[i]], n[2] > 0 ? s.push(n) : delete u[a[i]]; return s } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(3), l = f(7), r = f(14), h = f(5), n = f(13), u = f(10), a = f(6), t = f(0), s = f(1); (function () { e.create = function (i, c) { var p = (i ? i.mouse : null) || (c ? c.mouse : null); p || (i && i.render && i.render.canvas ? p = r.create(i.render.canvas) : c && c.element ? p = r.create(c.element) : (p = r.create(), t.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var y = u.create({ label: "Mouse Constraint", pointA: p.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), w = { type: "mouseConstraint", mouse: p, element: null, body: null, constraint: y, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, O = t.extend(w, c); return h.on(i, "beforeUpdate", function () { var d = a.allBodies(i.world); e.update(O, d), e._triggerEvents(O) }), O }, e.update = function (i, c) { var p = i.mouse, y = i.constraint, w = i.body; if (p.button === 0) { if (y.bodyB) l.set(y.bodyB, !1), y.pointA = p.position; else for (var O = 0; O < c.length; O++)if (w = c[O], s.contains(w.bounds, p.position) && n.canCollide(w.collisionFilter, i.collisionFilter)) for (var d = w.parts.length > 1 ? 1 : 0; d < w.parts.length; d++) { var v = w.parts[d]; if (o.contains(v.vertices, p.position)) { y.pointA = p.position, y.bodyB = i.body = w, y.pointB = { x: p.position.x - w.position.x, y: p.position.y - w.position.y }, y.angleB = w.angle, l.set(w, !1), h.trigger(i, "startdrag", { mouse: p, body: w }); break } } } else y.bodyB = i.body = null, y.pointB = null, w && h.trigger(i, "enddrag", { mouse: p, body: w }) }, e._triggerEvents = function (i) { var c = i.mouse, p = c.sourceEvents; p.mousemove && h.trigger(i, "mousemove", { mouse: c }), p.mousedown && h.trigger(i, "mousedown", { mouse: c }), p.mouseup && h.trigger(i, "mouseup", { mouse: c }), r.clearSourceEvents(c) } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(2), l = f(8), r = f(1), h = f(12), n = f(3); (function () { e.collides = function (u, a) { for (var t = [], s = a.length, i = u.bounds, c = l.collides, p = r.overlaps, y = 0; y < s; y++) { var w = a[y], O = w.parts.length, d = O === 1 ? 0 : 1; if (p(w.bounds, i)) for (var v = d; v < O; v++) { var x = w.parts[v]; if (p(x.bounds, i)) { var g = c(x, u); if (g) { t.push(g); break } } } } return t }, e.ray = function (u, a, t, s) { s = s || 1e-100; for (var i = o.angle(a, t), c = o.magnitude(o.sub(a, t)), p = (t.x + a.x) * .5, y = (t.y + a.y) * .5, w = h.rectangle(p, y, c, s, { angle: i }), O = e.collides(w, u), d = 0; d < O.length; d += 1) { var v = O[d]; v.body = v.bodyB = v.bodyA } return O }, e.region = function (u, a, t) { for (var s = [], i = 0; i < u.length; i++) { var c = u[i], p = r.overlaps(c.bounds, a); (p && !t || !p && t) && s.push(c) } return s }, e.point = function (u, a) { for (var t = [], s = 0; s < u.length; s++) { var i = u[s]; if (r.contains(i.bounds, a)) for (var c = i.parts.length === 1 ? 0 : 1; c < i.parts.length; c++) { var p = i.parts[c]; if (r.contains(p.bounds, a) && n.contains(p.vertices, a)) { t.push(i); break } } } return t } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(4), l = f(0), r = f(6), h = f(1), n = f(5), u = f(2), a = f(14); (function () { var t, s; typeof window < "u" && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (d) { window.setTimeout(function () { d(l.now()) }, 1e3 / 60) }, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e._goodFps = 30, e._goodDelta = 1e3 / 60, e.create = function (d) { var v = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], engineUpdatesHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", wireframeStrokeStyle: "#bbb", hasBounds: !!d.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } }, x = l.extend(v, d); return x.canvas && (x.canvas.width = x.options.width || x.canvas.width, x.canvas.height = x.options.height || x.canvas.height), x.mouse = d.mouse, x.engine = d.engine, x.canvas = x.canvas || p(x.options.width, x.options.height), x.context = x.canvas.getContext("2d"), x.textures = {}, x.bounds = x.bounds || { min: { x: 0, y: 0 }, max: { x: x.canvas.width, y: x.canvas.height } }, x.controller = e, x.options.showBroadphase = !1, x.options.pixelRatio !== 1 && e.setPixelRatio(x, x.options.pixelRatio), l.isElement(x.element) && x.element.appendChild(x.canvas), x }, e.run = function (d) { (function v(x) { d.frameRequestId = t(v), i(d, x), e.world(d, x), d.context.setTransform(d.options.pixelRatio, 0, 0, d.options.pixelRatio, 0, 0), (d.options.showStats || d.options.showDebug) && e.stats(d, d.context, x), (d.options.showPerformance || d.options.showDebug) && e.performance(d, d.context, x), d.context.setTransform(1, 0, 0, 1, 0, 0) })() }, e.stop = function (d) { s(d.frameRequestId) }, e.setPixelRatio = function (d, v) { var x = d.options, g = d.canvas; v === "auto" && (v = y(g)), x.pixelRatio = v, g.setAttribute("data-pixel-ratio", v), g.width = x.width * v, g.height = x.height * v, g.style.width = x.width + "px", g.style.height = x.height + "px" }, e.setSize = function (d, v, x) { d.options.width = v, d.options.height = x, d.bounds.max.x = d.bounds.min.x + v, d.bounds.max.y = d.bounds.min.y + x, d.options.pixelRatio !== 1 ? e.setPixelRatio(d, d.options.pixelRatio) : (d.canvas.width = v, d.canvas.height = x) }, e.lookAt = function (d, v, x, g) { g = typeof g < "u" ? g : !0, v = l.isArray(v) ? v : [v], x = x || { x: 0, y: 0 }; for (var P = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, S = 0; S < v.length; S += 1) { var D = v[S], C = D.bounds ? D.bounds.min : D.min || D.position || D, A = D.bounds ? D.bounds.max : D.max || D.position || D; C && A && (C.x < P.min.x && (P.min.x = C.x), A.x > P.max.x && (P.max.x = A.x), C.y < P.min.y && (P.min.y = C.y), A.y > P.max.y && (P.max.y = A.y)) } var I = P.max.x - P.min.x + 2 * x.x, L = P.max.y - P.min.y + 2 * x.y, B = d.canvas.height, E = d.canvas.width, H = E / B, U = I / L, G = 1, N = 1; U > H ? N = U / H : G = H / U, d.options.hasBounds = !0, d.bounds.min.x = P.min.x, d.bounds.max.x = P.min.x + I * G, d.bounds.min.y = P.min.y, d.bounds.max.y = P.min.y + L * N, g && (d.bounds.min.x += I * .5 - I * G * .5, d.bounds.max.x += I * .5 - I * G * .5, d.bounds.min.y += L * .5 - L * N * .5, d.bounds.max.y += L * .5 - L * N * .5), d.bounds.min.x -= x.x, d.bounds.max.x -= x.x, d.bounds.min.y -= x.y, d.bounds.max.y -= x.y, d.mouse && (a.setScale(d.mouse, { x: (d.bounds.max.x - d.bounds.min.x) / d.canvas.width, y: (d.bounds.max.y - d.bounds.min.y) / d.canvas.height }), a.setOffset(d.mouse, d.bounds.min)) }, e.startViewTransform = function (d) { var v = d.bounds.max.x - d.bounds.min.x, x = d.bounds.max.y - d.bounds.min.y, g = v / d.options.width, P = x / d.options.height; d.context.setTransform(d.options.pixelRatio / g, 0, 0, d.options.pixelRatio / P, 0, 0), d.context.translate(-d.bounds.min.x, -d.bounds.min.y) }, e.endViewTransform = function (d) { d.context.setTransform(d.options.pixelRatio, 0, 0, d.options.pixelRatio, 0, 0) }, e.world = function (d, v) { var x = l.now(), g = d.engine, P = g.world, S = d.canvas, D = d.context, C = d.options, A = d.timing, I = r.allBodies(P), L = r.allConstraints(P), B = C.wireframes ? C.wireframeBackground : C.background, E = [], H = [], U, G = { timestamp: g.timing.timestamp }; if (n.trigger(d, "beforeRender", G), d.currentBackground !== B && O(d, B), D.globalCompositeOperation = "source-in", D.fillStyle = "transparent", D.fillRect(0, 0, S.width, S.height), D.globalCompositeOperation = "source-over", C.hasBounds) { for (U = 0; U < I.length; U++) { var N = I[U]; h.overlaps(N.bounds, d.bounds) && E.push(N) } for (U = 0; U < L.length; U++) { var z = L[U], X = z.bodyA, ae = z.bodyB, j = z.pointA, V = z.pointB; X && (j = u.add(X.position, z.pointA)), ae && (V = u.add(ae.position, z.pointB)), !(!j || !V) && (h.contains(d.bounds, j) || h.contains(d.bounds, V)) && H.push(z) } e.startViewTransform(d), d.mouse && (a.setScale(d.mouse, { x: (d.bounds.max.x - d.bounds.min.x) / d.options.width, y: (d.bounds.max.y - d.bounds.min.y) / d.options.height }), a.setOffset(d.mouse, d.bounds.min)) } else H = L, E = I, d.options.pixelRatio !== 1 && d.context.setTransform(d.options.pixelRatio, 0, 0, d.options.pixelRatio, 0, 0); !C.wireframes || g.enableSleeping && C.showSleeping ? e.bodies(d, E, D) : (C.showConvexHulls && e.bodyConvexHulls(d, E, D), e.bodyWireframes(d, E, D)), C.showBounds && e.bodyBounds(d, E, D), (C.showAxes || C.showAngleIndicator) && e.bodyAxes(d, E, D), C.showPositions && e.bodyPositions(d, E, D), C.showVelocity && e.bodyVelocity(d, E, D), C.showIds && e.bodyIds(d, E, D), C.showSeparations && e.separations(d, g.pairs.list, D), C.showCollisions && e.collisions(d, g.pairs.list, D), C.showVertexNumbers && e.vertexNumbers(d, E, D), C.showMousePosition && e.mousePosition(d, d.mouse, D), e.constraints(H, D), C.hasBounds && e.endViewTransform(d), n.trigger(d, "afterRender", G), A.lastElapsed = l.now() - x }, e.stats = function (d, v, x) { for (var g = d.engine, P = g.world, S = r.allBodies(P), D = 0, C = 55, A = 44, I = 0, L = 0, B = 0; B < S.length; B += 1)D += S[B].parts.length; var E = { Part: D, Body: S.length, Cons: r.allConstraints(P).length, Comp: r.allComposites(P).length, Pair: g.pairs.list.length }; v.fillStyle = "#0e0f19", v.fillRect(I, L, C * 5.5, A), v.font = "12px Arial", v.textBaseline = "top", v.textAlign = "right"; for (var H in E) { var U = E[H]; v.fillStyle = "#aaa", v.fillText(H, I + C, L + 8), v.fillStyle = "#eee", v.fillText(U, I + C, L + 26), I += C } }, e.performance = function (d, v) { var x = d.engine, g = d.timing, P = g.deltaHistory, S = g.elapsedHistory, D = g.timestampElapsedHistory, C = g.engineDeltaHistory, A = g.engineUpdatesHistory, I = g.engineElapsedHistory, L = x.timing.lastUpdatesPerFrame, B = x.timing.lastDelta, E = c(P), H = c(S), U = c(C), G = c(A), N = c(I), z = c(D), X = z / E || 0, ae = Math.round(E / B), j = 1e3 / E || 0, V = 4, _ = 12, $ = 60, ue = 34, ee = 10, te = 69; v.fillStyle = "#0e0f19", v.fillRect(0, 50, _ * 5 + $ * 6 + 22, ue), e.status(v, ee, te, $, V, P.length, Math.round(j) + " fps", j / e._goodFps, function (K) { return P[K] / E - 1 }), e.status(v, ee + _ + $, te, $, V, C.length, B.toFixed(2) + " dt", e._goodDelta / B, function (K) { return C[K] / U - 1 }), e.status(v, ee + (_ + $) * 2, te, $, V, A.length, L + " upf", Math.pow(l.clamp(G / ae || 1, 0, 1), 4), function (K) { return A[K] / G - 1 }), e.status(v, ee + (_ + $) * 3, te, $, V, I.length, N.toFixed(2) + " ut", 1 - L * N / e._goodFps, function (K) { return I[K] / N - 1 }), e.status(v, ee + (_ + $) * 4, te, $, V, S.length, H.toFixed(2) + " rt", 1 - H / e._goodFps, function (K) { return S[K] / H - 1 }), e.status(v, ee + (_ + $) * 5, te, $, V, D.length, X.toFixed(2) + " x", X * X * X, function (K) { return (D[K] / P[K] / X || 0) - 1 }) }, e.status = function (d, v, x, g, P, S, D, C, A) { d.strokeStyle = "#888", d.fillStyle = "#444", d.lineWidth = 1, d.fillRect(v, x + 7, g, 1), d.beginPath(), d.moveTo(v, x + 7 - P * l.clamp(.4 * A(0), -2, 2)); for (var I = 0; I < g; I += 1)d.lineTo(v + I, x + 7 - (I < S ? P * l.clamp(.4 * A(I), -2, 2) : 0)); d.stroke(), d.fillStyle = "hsl(" + l.clamp(25 + 95 * C, 0, 120) + ",100%,60%)", d.fillRect(v, x - 7, 4, 4), d.font = "12px Arial", d.textBaseline = "middle", d.textAlign = "right", d.fillStyle = "#eee", d.fillText(D, v + g, x - 5) }, e.constraints = function (d, v) { for (var x = v, g = 0; g < d.length; g++) { var P = d[g]; if (!(!P.render.visible || !P.pointA || !P.pointB)) { var S = P.bodyA, D = P.bodyB, C, A; if (S ? C = u.add(S.position, P.pointA) : C = P.pointA, P.render.type === "pin") x.beginPath(), x.arc(C.x, C.y, 3, 0, 2 * Math.PI), x.closePath(); else { if (D ? A = u.add(D.position, P.pointB) : A = P.pointB, x.beginPath(), x.moveTo(C.x, C.y), P.render.type === "spring") for (var I = u.sub(A, C), L = u.perp(u.normalise(I)), B = Math.ceil(l.clamp(P.length / 5, 12, 20)), E, H = 1; H < B; H += 1)E = H % 2 === 0 ? 1 : -1, x.lineTo(C.x + I.x * (H / B) + L.x * E * 4, C.y + I.y * (H / B) + L.y * E * 4); x.lineTo(A.x, A.y) } P.render.lineWidth && (x.lineWidth = P.render.lineWidth, x.strokeStyle = P.render.strokeStyle, x.stroke()), P.render.anchors && (x.fillStyle = P.render.strokeStyle, x.beginPath(), x.arc(C.x, C.y, 3, 0, 2 * Math.PI), x.arc(A.x, A.y, 3, 0, 2 * Math.PI), x.closePath(), x.fill()) } } }, e.bodies = function (d, v, x) { var g = x; d.engine; var P = d.options, S = P.showInternalEdges || !P.wireframes, D, C, A, I; for (A = 0; A < v.length; A++)if (D = v[A], !!D.render.visible) { for (I = D.parts.length > 1 ? 1 : 0; I < D.parts.length; I++)if (C = D.parts[I], !!C.render.visible) { if (P.showSleeping && D.isSleeping ? g.globalAlpha = .5 * C.render.opacity : C.render.opacity !== 1 && (g.globalAlpha = C.render.opacity), C.render.sprite && C.render.sprite.texture && !P.wireframes) { var L = C.render.sprite, B = w(d, L.texture); g.translate(C.position.x, C.position.y), g.rotate(C.angle), g.drawImage(B, B.width * -L.xOffset * L.xScale, B.height * -L.yOffset * L.yScale, B.width * L.xScale, B.height * L.yScale), g.rotate(-C.angle), g.translate(-C.position.x, -C.position.y) } else { if (C.circleRadius) g.beginPath(), g.arc(C.position.x, C.position.y, C.circleRadius, 0, 2 * Math.PI); else { g.beginPath(), g.moveTo(C.vertices[0].x, C.vertices[0].y); for (var E = 1; E < C.vertices.length; E++)!C.vertices[E - 1].isInternal || S ? g.lineTo(C.vertices[E].x, C.vertices[E].y) : g.moveTo(C.vertices[E].x, C.vertices[E].y), C.vertices[E].isInternal && !S && g.moveTo(C.vertices[(E + 1) % C.vertices.length].x, C.vertices[(E + 1) % C.vertices.length].y); g.lineTo(C.vertices[0].x, C.vertices[0].y), g.closePath() } P.wireframes ? (g.lineWidth = 1, g.strokeStyle = d.options.wireframeStrokeStyle, g.stroke()) : (g.fillStyle = C.render.fillStyle, C.render.lineWidth && (g.lineWidth = C.render.lineWidth, g.strokeStyle = C.render.strokeStyle, g.stroke()), g.fill()) } g.globalAlpha = 1 } } }, e.bodyWireframes = function (d, v, x) { var g = x, P = d.options.showInternalEdges, S, D, C, A, I; for (g.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.render.visible) for (I = S.parts.length > 1 ? 1 : 0; I < S.parts.length; I++) { for (D = S.parts[I], g.moveTo(D.vertices[0].x, D.vertices[0].y), A = 1; A < D.vertices.length; A++)!D.vertices[A - 1].isInternal || P ? g.lineTo(D.vertices[A].x, D.vertices[A].y) : g.moveTo(D.vertices[A].x, D.vertices[A].y), D.vertices[A].isInternal && !P && g.moveTo(D.vertices[(A + 1) % D.vertices.length].x, D.vertices[(A + 1) % D.vertices.length].y); g.lineTo(D.vertices[0].x, D.vertices[0].y) } g.lineWidth = 1, g.strokeStyle = d.options.wireframeStrokeStyle, g.stroke() }, e.bodyConvexHulls = function (d, v, x) { var g = x, P, S, D; for (g.beginPath(), S = 0; S < v.length; S++)if (P = v[S], !(!P.render.visible || P.parts.length === 1)) { for (g.moveTo(P.vertices[0].x, P.vertices[0].y), D = 1; D < P.vertices.length; D++)g.lineTo(P.vertices[D].x, P.vertices[D].y); g.lineTo(P.vertices[0].x, P.vertices[0].y) } g.lineWidth = 1, g.strokeStyle = "rgba(255,255,255,0.2)", g.stroke() }, e.vertexNumbers = function (d, v, x) { var g = x, P, S, D; for (P = 0; P < v.length; P++) { var C = v[P].parts; for (D = C.length > 1 ? 1 : 0; D < C.length; D++) { var A = C[D]; for (S = 0; S < A.vertices.length; S++)g.fillStyle = "rgba(255,255,255,0.2)", g.fillText(P + "_" + S, A.position.x + (A.vertices[S].x - A.position.x) * .8, A.position.y + (A.vertices[S].y - A.position.y) * .8) } } }, e.mousePosition = function (d, v, x) { var g = x; g.fillStyle = "rgba(255,255,255,0.8)", g.fillText(v.position.x + "  " + v.position.y, v.position.x + 5, v.position.y - 5) }, e.bodyBounds = function (d, v, x) { var g = x; d.engine; var P = d.options; g.beginPath(); for (var S = 0; S < v.length; S++) { var D = v[S]; if (D.render.visible) for (var C = v[S].parts, A = C.length > 1 ? 1 : 0; A < C.length; A++) { var I = C[A]; g.rect(I.bounds.min.x, I.bounds.min.y, I.bounds.max.x - I.bounds.min.x, I.bounds.max.y - I.bounds.min.y) } } P.wireframes ? g.strokeStyle = "rgba(255,255,255,0.08)" : g.strokeStyle = "rgba(0,0,0,0.1)", g.lineWidth = 1, g.stroke() }, e.bodyAxes = function (d, v, x) { var g = x; d.engine; var P = d.options, S, D, C, A; for (g.beginPath(), D = 0; D < v.length; D++) { var I = v[D], L = I.parts; if (I.render.visible) if (P.showAxes) for (C = L.length > 1 ? 1 : 0; C < L.length; C++)for (S = L[C], A = 0; A < S.axes.length; A++) { var B = S.axes[A]; g.moveTo(S.position.x, S.position.y), g.lineTo(S.position.x + B.x * 20, S.position.y + B.y * 20) } else for (C = L.length > 1 ? 1 : 0; C < L.length; C++)for (S = L[C], A = 0; A < S.axes.length; A++)g.moveTo(S.position.x, S.position.y), g.lineTo((S.vertices[0].x + S.vertices[S.vertices.length - 1].x) / 2, (S.vertices[0].y + S.vertices[S.vertices.length - 1].y) / 2) } P.wireframes ? (g.strokeStyle = "indianred", g.lineWidth = 1) : (g.strokeStyle = "rgba(255, 255, 255, 0.4)", g.globalCompositeOperation = "overlay", g.lineWidth = 2), g.stroke(), g.globalCompositeOperation = "source-over" }, e.bodyPositions = function (d, v, x) { var g = x; d.engine; var P = d.options, S, D, C, A; for (g.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.render.visible) for (A = 0; A < S.parts.length; A++)D = S.parts[A], g.arc(D.position.x, D.position.y, 3, 0, 2 * Math.PI, !1), g.closePath(); for (P.wireframes ? g.fillStyle = "indianred" : g.fillStyle = "rgba(0,0,0,0.5)", g.fill(), g.beginPath(), C = 0; C < v.length; C++)S = v[C], S.render.visible && (g.arc(S.positionPrev.x, S.positionPrev.y, 2, 0, 2 * Math.PI, !1), g.closePath()); g.fillStyle = "rgba(255,165,0,0.8)", g.fill() }, e.bodyVelocity = function (d, v, x) { var g = x; g.beginPath(); for (var P = 0; P < v.length; P++) { var S = v[P]; if (S.render.visible) { var D = o.getVelocity(S); g.moveTo(S.position.x, S.position.y), g.lineTo(S.position.x + D.x, S.position.y + D.y) } } g.lineWidth = 3, g.strokeStyle = "cornflowerblue", g.stroke() }, e.bodyIds = function (d, v, x) { var g = x, P, S; for (P = 0; P < v.length; P++)if (v[P].render.visible) { var D = v[P].parts; for (S = D.length > 1 ? 1 : 0; S < D.length; S++) { var C = D[S]; g.font = "12px Arial", g.fillStyle = "rgba(255,255,255,0.5)", g.fillText(C.id, C.position.x + 10, C.position.y - 10) } } }, e.collisions = function (d, v, x) { var g = x, P = d.options, S, D, C, A; for (g.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.isActive) for (D = S.collision, A = 0; A < S.contactCount; A++) { var I = S.contacts[A], L = I.vertex; g.rect(L.x - 1.5, L.y - 1.5, 3.5, 3.5) } for (P.wireframes ? g.fillStyle = "rgba(255,255,255,0.7)" : g.fillStyle = "orange", g.fill(), g.beginPath(), C = 0; C < v.length; C++)if (S = v[C], !!S.isActive && (D = S.collision, S.contactCount > 0)) { var B = S.contacts[0].vertex.x, E = S.contacts[0].vertex.y; S.contactCount === 2 && (B = (S.contacts[0].vertex.x + S.contacts[1].vertex.x) / 2, E = (S.contacts[0].vertex.y + S.contacts[1].vertex.y) / 2), D.bodyB === D.supports[0].body || D.bodyA.isStatic === !0 ? g.moveTo(B - D.normal.x * 8, E - D.normal.y * 8) : g.moveTo(B + D.normal.x * 8, E + D.normal.y * 8), g.lineTo(B, E) } P.wireframes ? g.strokeStyle = "rgba(255,165,0,0.7)" : g.strokeStyle = "orange", g.lineWidth = 1, g.stroke() }, e.separations = function (d, v, x) { var g = x, P = d.options, S, D, C, A, I; for (g.beginPath(), I = 0; I < v.length; I++)if (S = v[I], !!S.isActive) { D = S.collision, C = D.bodyA, A = D.bodyB; var L = 1; !A.isStatic && !C.isStatic && (L = .5), A.isStatic && (L = 0), g.moveTo(A.position.x, A.position.y), g.lineTo(A.position.x - D.penetration.x * L, A.position.y - D.penetration.y * L), L = 1, !A.isStatic && !C.isStatic && (L = .5), C.isStatic && (L = 0), g.moveTo(C.position.x, C.position.y), g.lineTo(C.position.x + D.penetration.x * L, C.position.y + D.penetration.y * L) } P.wireframes ? g.strokeStyle = "rgba(255,165,0,0.5)" : g.strokeStyle = "orange", g.stroke() }, e.inspector = function (d, v) { d.engine; var x = d.selected, g = d.render, P = g.options, S; if (P.hasBounds) { var D = g.bounds.max.x - g.bounds.min.x, C = g.bounds.max.y - g.bounds.min.y, A = D / g.options.width, I = C / g.options.height; v.scale(1 / A, 1 / I), v.translate(-g.bounds.min.x, -g.bounds.min.y) } for (var L = 0; L < x.length; L++) { var B = x[L].data; switch (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.9)", v.setLineDash([1, 2]), B.type) { case "body": S = B.bounds, v.beginPath(), v.rect(Math.floor(S.min.x - 3), Math.floor(S.min.y - 3), Math.floor(S.max.x - S.min.x + 6), Math.floor(S.max.y - S.min.y + 6)), v.closePath(), v.stroke(); break; case "constraint": var E = B.pointA; B.bodyA && (E = B.pointB), v.beginPath(), v.arc(E.x, E.y, 10, 0, 2 * Math.PI), v.closePath(), v.stroke(); break }v.setLineDash([]), v.translate(-.5, -.5) } d.selectStart !== null && (v.translate(.5, .5), v.lineWidth = 1, v.strokeStyle = "rgba(255,165,0,0.6)", v.fillStyle = "rgba(255,165,0,0.1)", S = d.selectBounds, v.beginPath(), v.rect(Math.floor(S.min.x), Math.floor(S.min.y), Math.floor(S.max.x - S.min.x), Math.floor(S.max.y - S.min.y)), v.closePath(), v.stroke(), v.fill(), v.translate(-.5, -.5)), P.hasBounds && v.setTransform(1, 0, 0, 1, 0, 0) }; var i = function (d, v) { var x = d.engine, g = d.timing, P = g.historySize, S = x.timing.timestamp; g.delta = v - g.lastTime || e._goodDelta, g.lastTime = v, g.timestampElapsed = S - g.lastTimestamp || 0, g.lastTimestamp = S, g.deltaHistory.unshift(g.delta), g.deltaHistory.length = Math.min(g.deltaHistory.length, P), g.engineDeltaHistory.unshift(x.timing.lastDelta), g.engineDeltaHistory.length = Math.min(g.engineDeltaHistory.length, P), g.timestampElapsedHistory.unshift(g.timestampElapsed), g.timestampElapsedHistory.length = Math.min(g.timestampElapsedHistory.length, P), g.engineUpdatesHistory.unshift(x.timing.lastUpdatesPerFrame), g.engineUpdatesHistory.length = Math.min(g.engineUpdatesHistory.length, P), g.engineElapsedHistory.unshift(x.timing.lastElapsed), g.engineElapsedHistory.length = Math.min(g.engineElapsedHistory.length, P), g.elapsedHistory.unshift(g.lastElapsed), g.elapsedHistory.length = Math.min(g.elapsedHistory.length, P) }, c = function (d) { for (var v = 0, x = 0; x < d.length; x += 1)v += d[x]; return v / d.length || 0 }, p = function (d, v) { var x = document.createElement("canvas"); return x.width = d, x.height = v, x.oncontextmenu = function () { return !1 }, x.onselectstart = function () { return !1 }, x }, y = function (d) { var v = d.getContext("2d"), x = window.devicePixelRatio || 1, g = v.webkitBackingStorePixelRatio || v.mozBackingStorePixelRatio || v.msBackingStorePixelRatio || v.oBackingStorePixelRatio || v.backingStorePixelRatio || 1; return x / g }, w = function (d, v) { var x = d.textures[v]; return x || (x = d.textures[v] = new Image, x.src = v, x) }, O = function (d, v) { var x = v; /(jpg|gif|png)$/.test(v) && (x = "url(" + v + ")"), d.canvas.style.background = x, d.canvas.style.backgroundSize = "contain", d.currentBackground = v } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(5), l = f(17), r = f(0); (function () { e._maxFrameDelta = 1e3 / 15, e._frameDeltaFallback = 1e3 / 60, e._timeBufferMargin = 1.5, e._elapsedNextEstimate = 1, e._smoothingLowerBound = .1, e._smoothingUpperBound = .9, e.create = function (n) { var u = { delta: 16.666666666666668, frameDelta: null, frameDeltaSmoothing: !0, frameDeltaSnapping: !0, frameDeltaHistory: [], frameDeltaHistorySize: 100, frameRequestId: null, timeBuffer: 0, timeLastTick: null, maxUpdates: null, maxFrameTime: 33.333333333333336, lastUpdatesDeferred: 0, enabled: !0 }, a = r.extend(u, n); return a.fps = 0, a }, e.run = function (n, u) { return n.timeBuffer = e._frameDeltaFallback, function a(t) { n.frameRequestId = e._onNextFrame(n, a), t && n.enabled && e.tick(n, u, t) }(), n }, e.tick = function (n, u, a) { var t = r.now(), s = n.delta, i = 0, c = a - n.timeLastTick; if ((!c || !n.timeLastTick || c > Math.max(e._maxFrameDelta, n.maxFrameTime)) && (c = n.frameDelta || e._frameDeltaFallback), n.frameDeltaSmoothing) { n.frameDeltaHistory.push(c), n.frameDeltaHistory = n.frameDeltaHistory.slice(-n.frameDeltaHistorySize); var p = n.frameDeltaHistory.slice(0).sort(), y = n.frameDeltaHistory.slice(p.length * e._smoothingLowerBound, p.length * e._smoothingUpperBound), w = h(y); c = w || c } n.frameDeltaSnapping && (c = 1e3 / Math.round(1e3 / c)), n.frameDelta = c, n.timeLastTick = a, n.timeBuffer += n.frameDelta, n.timeBuffer = r.clamp(n.timeBuffer, 0, n.frameDelta + s * e._timeBufferMargin), n.lastUpdatesDeferred = 0; var O = n.maxUpdates || Math.ceil(n.maxFrameTime / s), d = { timestamp: u.timing.timestamp }; o.trigger(n, "beforeTick", d), o.trigger(n, "tick", d); for (var v = r.now(); s > 0 && n.timeBuffer >= s * e._timeBufferMargin;) { o.trigger(n, "beforeUpdate", d), l.update(u, s), o.trigger(n, "afterUpdate", d), n.timeBuffer -= s, i += 1; var x = r.now() - t, g = r.now() - v, P = x + e._elapsedNextEstimate * g / i; if (i >= O || P > n.maxFrameTime) { n.lastUpdatesDeferred = Math.round(Math.max(0, n.timeBuffer / s - e._timeBufferMargin)); break } } u.timing.lastUpdatesPerFrame = i, o.trigger(n, "afterTick", d), n.frameDeltaHistory.length >= 100 && (n.lastUpdatesDeferred && Math.round(n.frameDelta / s) > O ? r.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : n.lastUpdatesDeferred && r.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof n.isFixed < "u" && r.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (n.deltaMin || n.deltaMax) && r.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), n.fps !== 0 && r.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.")) }, e.stop = function (n) { e._cancelNextFrame(n) }, e._onNextFrame = function (n, u) { if (typeof window < "u" && window.requestAnimationFrame) n.frameRequestId = window.requestAnimationFrame(u); else throw new Error("Matter.Runner: missing required global window.requestAnimationFrame."); return n.frameRequestId }, e._cancelNextFrame = function (n) { if (typeof window < "u" && window.cancelAnimationFrame) window.cancelAnimationFrame(n.frameRequestId); else throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.") }; var h = function (n) { for (var u = 0, a = n.length, t = 0; t < a; t += 1)u += n[t]; return u / a || 0 } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(8), l = f(0), r = l.deprecated; (function () { e.collides = function (h, n) { return o.collides(h, n) }, r(e, "collides", "SAT.collides ➤ replaced by Collision.collides") })() }, function (m, T, f) { var e = {}; m.exports = e, f(1); var o = f(0); (function () { e.pathToVertices = function (l, r) { typeof window < "u" && !("SVGPathSeg" in window) && o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var h, n, u, a, t, s, i, c, p, y, w = [], O, d, v = 0, x = 0, g = 0; r = r || 15; var P = function (D, C, A) { var I = A % 2 === 1 && A > 1; if (!p || D != p.x || C != p.y) { p && I ? (O = p.x, d = p.y) : (O = 0, d = 0); var L = { x: O + D, y: d + C }; (I || !p) && (p = L), w.push(L), x = O + D, g = d + C } }, S = function (D) { var C = D.pathSegTypeAsLetter.toUpperCase(); if (C !== "Z") { switch (C) { case "M": case "L": case "T": case "C": case "S": case "Q": x = D.x, g = D.y; break; case "H": x = D.x; break; case "V": g = D.y; break }P(x, g, D.pathSegType) } }; for (e._svgPathToAbsolute(l), u = l.getTotalLength(), s = [], h = 0; h < l.pathSegList.numberOfItems; h += 1)s.push(l.pathSegList.getItem(h)); for (i = s.concat(); v < u;) { if (y = l.getPathSegAtLength(v), t = s[y], t != c) { for (; i.length && i[0] != t;)S(i.shift()); c = t } switch (t.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": a = l.getPointAtLength(v), P(a.x, a.y, 0); break }v += r } for (h = 0, n = i.length; h < n; ++h)S(i[h]); return w }, e._svgPathToAbsolute = function (l) { for (var r, h, n, u, a, t, s = l.pathSegList, i = 0, c = 0, p = s.numberOfItems, y = 0; y < p; ++y) { var w = s.getItem(y), O = w.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(O)) "x" in w && (i = w.x), "y" in w && (c = w.y); else switch ("x1" in w && (n = i + w.x1), "x2" in w && (a = i + w.x2), "y1" in w && (u = c + w.y1), "y2" in w && (t = c + w.y2), "x" in w && (i += w.x), "y" in w && (c += w.y), O) { case "m": s.replaceItem(l.createSVGPathSegMovetoAbs(i, c), y); break; case "l": s.replaceItem(l.createSVGPathSegLinetoAbs(i, c), y); break; case "h": s.replaceItem(l.createSVGPathSegLinetoHorizontalAbs(i), y); break; case "v": s.replaceItem(l.createSVGPathSegLinetoVerticalAbs(c), y); break; case "c": s.replaceItem(l.createSVGPathSegCurvetoCubicAbs(i, c, n, u, a, t), y); break; case "s": s.replaceItem(l.createSVGPathSegCurvetoCubicSmoothAbs(i, c, a, t), y); break; case "q": s.replaceItem(l.createSVGPathSegCurvetoQuadraticAbs(i, c, n, u), y); break; case "t": s.replaceItem(l.createSVGPathSegCurvetoQuadraticSmoothAbs(i, c), y); break; case "a": s.replaceItem(l.createSVGPathSegArcAbs(i, c, w.r1, w.r2, w.angle, w.largeArcFlag, w.sweepFlag), y); break; case "z": case "Z": i = r, c = h; break }(O == "M" || O == "m") && (r = i, h = c) } } })() }, function (m, T, f) { var e = {}; m.exports = e; var o = f(6); f(0), function () { e.create = o.create, e.add = o.add, e.remove = o.remove, e.clear = o.clear, e.addComposite = o.addComposite, e.addBody = o.addBody, e.addConstraint = o.addConstraint }() }]) }) })(kt); const ie = vt(le); class Rt { constructor(M) { F(this, "widthCanvas", document.body.clientWidth); F(this, "heightCanvas"); F(this, "DOM"); F(this, "dataImgs", []); F(this, "MatterJS"); F(this, "sizeCustom"); this.DOM = { el: M }, this.MatterJS = { Engine: void 0, Render: void 0 }, this.sizeCustom = { mobile: { radius: q(5), scaleRatio: q(5) / 133, scaleCircleMain: 171 / 50, xLeftWall: 0 - q(9), xRightWall: window.innerWidth + q(9), yMainCircle: q(72.2) + q(17) }, tablet: { radius: q(5), scaleRatio: q(5) / 133, scaleCircleMain: 190 / 50, xLeftWall: 0 - q(9), xRightWall: window.innerWidth + q(9), yMainCircle: q(72.2) + q(19) }, desktop: { radius: q(13.3), scaleRatio: q(13.3) / 133, scaleCircleMain: 293 / 133, xLeftWall: 0, xRightWall: window.innerWidth, yMainCircle: q(51.2) + q(29.3) } }, this.heightCanvas = this.DOM.el.clientHeight, M == null || M.querySelectorAll(".home-bubble-item").forEach(m => { var f; const T = (f = m.querySelector("img")) == null ? void 0 : f.getAttribute("src"); T && this.dataImgs.push(T), m.style.pointerEvents = "none", m.style.opacity = "0" }) } render() { var f, e, o, l; this.init(); const M = ie.Runner.create(), m = (e = (f = this.MatterJS).Engine) == null ? void 0 : e.call(f), T = (l = (o = this.MatterJS).Render) == null ? void 0 : l.call(o); se.create({ trigger: this.DOM.el, start: "top center", end: "bottom center", onEnter: () => { !m || !T || (ie.Render.run(T), ie.Runner.run(M, m)) } }) } init() { const M = this.sizeCustom[fe].radius, m = this.sizeCustom[fe].scaleRatio, T = this.sizeCustom[fe].scaleCircleMain, f = this.sizeCustom[fe].xLeftWall, e = this.sizeCustom[fe].xRightWall, o = this.sizeCustom[fe].yMainCircle, l = ie.Engine.create(), r = ie.Render.create({ element: this.DOM.el, engine: l, options: { width: this.widthCanvas, height: this.heightCanvas, background: "transparent", wireframes: !1, showAngleIndicator: !1 } }), h = Math.floor(window.innerWidth / (M * 2)), u = (window.innerWidth - h * M * 2) / (h - 1); let a = 0; for (let w = 0; w < Math.round(this.dataImgs.length / h) && this.dataImgs[a]; w++) { for (let O = 0; O < h && this.dataImgs[a]; O++) { const d = O * M * 2 + u * O, v = -w * M * 2 - M * 2 - u * w, x = le.Bodies.circle(d, v, M, { friction: .001, frictionAir: .01, restitution: .8, timeScale: 1.05, render: { fillStyle: "#f3f3f3", visible: !0, sprite: { texture: this.dataImgs[a], xScale: m, yScale: m } } }); if (a++, ie.Composite.add(l.world, x), a >= this.dataImgs.length) break } if (a >= this.dataImgs.length) break } const t = le.Bodies.circle(this.DOM.el.clientWidth / 2, o, M * T, { render: { fillStyle: "transparent" }, isStatic: !0 }), s = le.Bodies.rectangle(this.DOM.el.clientWidth / 2, this.DOM.el.clientHeight, this.DOM.el.clientWidth * 10, 1, { isStatic: !0, render: { fillStyle: "transparent" } }), i = le.Bodies.rectangle(f, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }), c = le.Bodies.rectangle(e, this.DOM.el.clientHeight / 2, 1, this.DOM.el.clientHeight * 5, { isStatic: !0, render: { fillStyle: "transparent" } }); ie.Composite.add(l.world, [s, i, c, t]); const p = ie.Mouse.create(r.canvas), y = ie.MouseConstraint.create(l, { mouse: p, constraint: { stiffness: .2, render: { visible: !1 } } }); ie.Composite.add(l.world, y), y.mouse.element.removeEventListener("touchstart", y.mouse.mousedown), y.mouse.element.removeEventListener("touchmove", y.mouse.mousemove), y.mouse.element.removeEventListener("touchend", y.mouse.mouseup), y.mouse.element.addEventListener("touchstart", y.mouse.mousedown, { passive: !0 }), y.mouse.element.addEventListener("touchmove", w => { y.body && y.mouse.mousemove(w) }), y.mouse.element.addEventListener("touchend", w => { y.body && y.mouse.mouseup(w) }), this.MatterJS.Render = () => r, this.MatterJS.Engine = () => l } } class Ft { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { const M = this.DOM.el.querySelectorAll(".home-hero-brands-wrap"), m = this.DOM.el.querySelector(".home-bubble"), T = this.DOM.el.querySelector(".home-book-img-inner"); M.length && M.forEach(f => { new Oe({ wrap: f, listSplide: f.querySelectorAll(".home-hero-brands") }) }), new Bt(this.DOM.el), m && new Rt(m).render(), T && new Ae({ el: T, offset: 30, direction: -1 }), this.heroVideoAction(), this.handleParallaxTitle(), this.initMotion() } clear() { this.initParticles() } initMotion() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } heroVideoAction() { const M = this.DOM.el.querySelector(".home-hero-img-btn"), m = this.DOM.el.querySelector(".home-hero-poup-video"), T = this.DOM.el.querySelector(".home-hero--poup-ic"), f = this.DOM.el.querySelector(".home-hero-poup-video-content"); M.addEventListener("click", () => { m.classList.add("is-show") }), T.addEventListener("click", () => e()), mt({ element: f, action: () => e() }); const e = () => { m.classList.remove("is-show") } } handleParallaxTitle() { const M = this.DOM.el.querySelector(".home-feature-top-inner"), m = this.DOM.el.querySelector(".home-bubble"); if (!M || !m) return; const T = b.fromTo(M, { y: M.clientHeight / 2 }, { y: `-${window.innerHeight / 2 - M.clientHeight / 2}px`, ease: "none", duration: 3 }); se.create({ trigger: m, start: () => "bottom bottom", end: "bottom top", animation: T, scrub: !0 }) } } class Ht { constructor(M) { F(this, "DOM"); F(this, "pricing"); F(this, "pricingBase"); F(this, "pricingAgent"); F(this, "planCurrent"); F(this, "planOptions", { month: { planUser: 35, basePrice: 75, valSaleUp: 0, type: "month" }, year: { planUser: 35, basePrice: 75, valSaleUp: 10, type: "year" } }); this.DOM = { el: M }, this.planCurrent = this.planOptions.month, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { const M = this.DOM.el.querySelector(".home-book-img-inner"); M && new Ae({ el: M, offset: 30, direction: -1 }); const m = this.DOM.el.querySelectorAll(".pricing-testimonials-brands"); m.length && m.forEach(T => { new Oe({ wrap: T, listSplide: this.DOM.el.querySelectorAll(".pricing-testimonials-brands") }) }), new Oe({ wrap: this.DOM.el.querySelector(".book-brands-wrap"), listSplide: this.DOM.el.querySelectorAll(".home-hero-brands") }), this.initMotions(), this.handleInitPricing(), this.handleLoadMorePrice(), this.handleSubmitForm(), this.handleRoateIconSale(), this.handleShowTextMoreLimit() } initMotions() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.fadeWrap(this.DOM.el) } handleRoateIconSale() { const M = this.DOM.el.querySelector(".pricing-hero-tab-tag"), m = () => { b.killTweensOf(M), b.to(M, { keyframes: { rotation: [16, -12, 8, -4, 2, 0] }, ease: "bounce.out", duration: 1.6 }) }; return Ne({ el: M, animIn: m }), m } handleLoadMorePrice() { if (!this.DOM.el) return; const M = this.DOM.el.querySelectorAll("#tablePricing .pricing_table_row"), m = this.DOM.el.querySelector("#loadMoreTable"); let T = 10; m.addEventListener("click", function () { const f = T + 11; for (let e = T; e < f && e < M.length; e++)if (e > 10) { const o = M[e], l = ze(e, T, f, 0, 1); o.style.animationDelay = `${l}s`, o.classList.add("show_row") } T = f, T >= M.length && (this.style.display = "none"), se.refresh() }) } handleSelectTypePlan() { const M = this.DOM.el.querySelector(".pricing-hero-bg-wrap"), m = this.DOM.el.querySelector(".pricing-hero-bg"), T = this.DOM.el.querySelectorAll(".js-text-timer"); M && this.DOM.el.querySelectorAll(".pricing-hero-tab-item").forEach(f => { f.addEventListener("click", () => { var t, s, i, c, p; const e = f.getAttribute("data-plan-pricing"); if (!this.pricing || e === ((t = this.planCurrent) == null ? void 0 : t.type)) return; e === "year" && this.handleRoateIconSale(); const o = M.getBoundingClientRect().x, l = f.getBoundingClientRect().x, r = f.getBoundingClientRect().width, h = this.planOptions[e]; this.planCurrent = h, T.forEach((y, w, O) => { const d = y.querySelectorAll(".txt.txt-18"); e === "month" ? b.to(d, { y: 0, ease: "power3", duration: 1.2, delay: w * .3 + 1 }) : b.fromTo(d, { y: "0%" }, { y: "-100%", ease: "power3", duration: 1.2, delay: (O.length - w) * .3 + 1 }) }); const n = e === "year", u = (n ? 12 * (100 - h.valSaleUp) / 100 : 1) * h.planUser, a = (n ? 12 * (100 - h.valSaleUp) / 100 : 1) * h.basePrice; !this.pricingAgent || !this.pricingBase || ((s = this.pricingAgent.textSplit) == null || s.revert(), (i = this.pricingBase.textSplit) == null || i.revert(), this.pricingBase.DOM.el.innerHTML = `${a}`, this.pricingAgent.DOM.el.innerHTML = `${u}`, this.pricingAgent.init(), this.pricingBase.init(), (c = this.pricingAgent) == null || c.animIn(), (p = this.pricingBase) == null || p.animIn(.1), b.to(m, { x: -(o - l), duration: .5, width: r, ease: "power3.out" }), this.pricing.handleCalcPricing({ ...h, isReinit: !0 })) }) }) } handleSubmitForm() { const M = this.DOM.el.querySelector(".pricing-range-form-inner"), m = this.DOM.el.querySelector('[data-name="Name"]'), T = this.DOM.el.querySelector('[data-name="Total Price"]'), f = this.DOM.el.querySelector(".pricing-message-success"); M == null || M.addEventListener("submit", () => { var o; m.value = "Anonymous", T.value = ((o = this.pricing) == null ? void 0 : o.DOM.el.innerHTML) || "0" }); let e; setInterval(() => { f.style.display === "block" && (clearInterval(e), setTimeout(() => { b.to(f, { opacity: 0, duration: 1.2, ease: "power3.out", onComplete: () => { f.style.display = "none" } }) }, 2e3)) }, 100) } handleInitPricing() { var h; const M = (h = this.DOM.el.querySelector(".txt-168.txt-bold")) == null ? void 0 : h.querySelector(".js-text-counter"), m = this.DOM.el.querySelector(".text-pricing-agent"), T = this.DOM.el.querySelector(".text-pricing-base"), f = document.querySelector(".fs-rangeslider_input__custom"), e = !0, o = new we(M, f, e), l = new we(T, void 0, e), r = new we(m, void 0, e); this.pricingAgent = r, this.pricingBase = l, this.pricing = o, this.handleSelectTypePlan(), this.handleActionPlanPricing() } handleActionPlanPricing() { setTimeout(() => { var M, m, T, f; this.pricing && this.pricing.handleSlide({ type: ((M = this.planCurrent) == null ? void 0 : M.type) || "month", planUser: ((m = this.planCurrent) == null ? void 0 : m.planUser) || 35, valSaleUp: ((T = this.planCurrent) == null ? void 0 : T.valSaleUp) || 0, basePrice: ((f = this.planCurrent) == null ? void 0 : f.basePrice) || 75 }) }, 1e3) } handleShowTextMoreLimit() { const M = document.querySelector(".fs-rangeslider_input__custom"), m = document.querySelector(".pricing-hero-panel-main-range-heading-more"); M.addEventListener("input", function () { M.value === "30" ? (m.style.opacity = "1", m.style.transitionDuration = ".3s", m.style.pointerEvents = "auto") : (m.style.opacity = "0", m.style.transitionDuration = ".3s", m.style.pointerEvents = "none") }) } clear() { this.initParticles() } } class bt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)), this.handleTotalArticle() } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } handleTotalArticle() { const M = this.DOM.el.querySelectorAll(".sc-result-card-wrap"); M.length && xt(() => { for (let m = 0; m < M.length; m++) { const T = M[m].querySelectorAll(".w-dyn-item"), f = M[m].querySelector(".sc-result-card-content-total"); if (!f) return; const e = T.length; e ? f.innerHTML = `${e < 10 ? "0" + e : e}` : f.innerHTML = "0" } }, 1200)() } } class Wt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Vt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Ut { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class qt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } class Gt { constructor(M) { F(this, "DOM"); this.DOM = { el: M }, W.emit(Q), this.initParticles = this.initParticles.bind(this), W.on(J, this.initParticles), Z(this.clear.bind(this)) } initParticles() { R.maskText(this.DOM.el), R.fadeText(this.DOM.el), R.countText(this.DOM.el), R.fadeWrap(this.DOM.el) } clear() { this.initParticles() } } b.registerPlugin(se); class Nt { constructor() { this.init(), this.bindEvents() } init() { const m = new URL(location.href).searchParams.get("dev"); if (console.log("isDev", m), m) return; const T = document.querySelector("div[data-page]"); if (!T) return; const f = T.getAttribute("data-page") || "home", e = { home: () => { new Ft(T) }, about: () => { new It(T) }, pricing: () => { new Ht(T) }, "support-center": () => { new bt(T) }, changelog: () => { new Et(T) }, "blog-detail": () => { new wt(T) }, "contact-us": () => { new Wt(T) }, impressum: () => { new Vt(T) }, "request-trial": () => { new Ut(T) }, "ask-a-question": () => { new qt(T) }, "sign-up": () => { new Gt(T) } }; e[f] && e[f](), yt.init(), R.init(), new Tt, new Ot } bindEvents() { W.on(St, this.init.bind(this)), Ge.simple(), Ge.simpleLoaded() } } new Nt;
